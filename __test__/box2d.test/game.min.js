! function(t) {
    var i = {};

    function o(e) {
        if (i[e]) return i[e].exports;
        var n = i[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return t[e].call(n.exports, n, n.exports, o), n.l = !0, n.exports
    }
    o.m = t, o.c = i, o.d = function(t, i, e) {
        o.o(t, i) || Object.defineProperty(t, i, {
            enumerable: !0,
            get: e
        })
    }, o.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, o.t = function(t, i) {
        if (1 & i && (t = o(t)), 8 & i) return t;
        if (4 & i && "object" == typeof t && t && t.__esModule) return t;
        var e = Object.create(null);
        if (o.r(e), Object.defineProperty(e, "default", {
                enumerable: !0,
                value: t
            }), 2 & i && "string" != typeof t)
            for (var n in t) o.d(e, n, function(i) {
                return t[i]
            }.bind(null, n));
        return e
    }, o.n = function(t) {
        var i = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return o.d(i, "a", i), i
    }, o.o = function(t, i) {
        return Object.prototype.hasOwnProperty.call(t, i)
    }, o.p = "", o(o.s = 8)
}([function(t, i, o) {
    "use strict";
    o.d(i, "a", function() {
        return n
    }), o.d(i, "b", function() {
        return e
    }), o.d(i, "c", function() {
        return s
    });
    class e {
        constructor(t, i, o, e, n) {
            this.entities = [], this.state = {
                container: t,
                size: {
                    x: 512,
                    y: 512
                },
                gravity: {
                    x: 0,
                    y: 0
                },
                friction: {
                    x: 0,
                    y: 0
                }
            }
        }
        addObject(t) {
            return this.entities.push(t)
        }
        removeObject(t) {
            return this.entities.splice(t, 1)
        }
        update() {
            this.entities.forEach(t => {
                switch (t.update(), t.type) {
                    case "dynamic":
                        t.state.vel.x += t.state.accel.x + (t.state.gravity.x + this.state.gravity.x), t.state.vel.y += t.state.accel.y + (t.state.gravity.y + this.state.gravity.y), t.state.pos.x += t.state.vel.x, t.state.pos.y += t.state.vel.y;
                        var i = t.state.friction.x,
                            o = t.state.vel.x + i,
                            e = t.state.vel.x - i,
                            n = t.state.friction.y,
                            s = t.state.vel.y + n,
                            r = t.state.vel.y - n;
                        t.state.vel.x = o < 0 ? o : e > 0 ? e : 0, t.state.vel.y = s < 0 ? s : r > 0 ? r : 0;
                        break;
                    case "kinematic":
                        t.state.vel.x += t.state.accel.x, t.state.vel.y += t.state.accel.y, t.state.pos.x += t.state.vel.x, t.state.pos.y += t.state.vel.y
                }
            })
        }
        render() {
            this.entities.forEach(t => {
                t.render()
            })
        }
    }
    class n extends e {
        constructor() {
            super(), this.state.size = {
                x: 10,
                y: 10
            }, this.state.pos = {
                x: 0,
                y: 0
            }, this.state.vel = {
                x: 0,
                y: 0
            }, this.state.accel = {
                x: 0,
                y: 0
            }, this.state.radius = 10, this.state.angle = 0, this.type = "dynamic"
        }
    }
    class s extends n {
        constructor(t, i) {
            super(), this.scope = t, this.state.pos = i.pos || {
                x: 0,
                y: 0
            }, this.state.crop = {
                x: 0,
                y: 0
            }, this.state.size = i.size || {
                x: 0,
                y: 0
            }, this.state.frames = i.frames || [], this.state.angle = i.angle || 0, this.state.image = i.image || new Image, this.state.delay = i.delay || 5, this.state.tick = i.tick || 0, this.state.orientation = i.orientation || "horizontal"
        }
        update() {
            super.update(), this.state.tick <= 0 && ("vertical" === this.orientation ? (this.state.crop.y = this.state.frames.shift(), this.state.frames.push(this.state.crop.y)) : (this.state.crop.x = this.state.frames.shift(), this.state.frames.push(this.state.crop.x)), this.state.tick = this.state.delay), this.state.tick--
        }
        render() {
            super.render(), this.scope.context.save(), this.scope.context.translate(this.state.crop.x + this.state.size.x / 2, this.state.crop.y + this.state.size.y / 2), this.scope.context.rotate(this.state.angle * (Math.PI / 180)), this.scope.context.translate(-(this.state.crop.x + this.state.size.x / 2), -(this.state.crop.y + this.state.size.y / 2)), this.scope.context.drawImage(this.state.image, this.state.crop.x * this.state.size.x, this.state.crop.y * this.state.size.y, this.state.size.x, this.state.size.y, this.state.pos.x, this.state.pos.y, this.state.size.x, this.state.size.y), this.scope.context.restore()
        }
    }
}, function(t, i, o) {
    t.exports = o(9)
}, function(t, i) {
    var o = {
        SCALE: .1
    };
    ! function(t, i) {
        function o() {}!(Object.prototype.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function(t, i, o) {
            o.get instanceof Function && t.__defineGetter__(i, o.get), o.set instanceof Function && t.__defineSetter__(i, o.set)
        }), t.inherit = function(t, i) {
            o.prototype = i.prototype, t.prototype = new o, t.prototype.constructor = t
        }, t.generateCallback = function(t, i) {
            return function() {
                i.apply(t, arguments)
            }
        }, t.NVector = function(t) {
            t === i && (t = 0);
            for (var o = Array(t || 0), e = 0; e < t; ++e) o[e] = 0;
            return o
        }, t.is = function(t, o) {
            return null !== t && (o instanceof Function && t instanceof o || !(t.constructor.__implements == i || !t.constructor.__implements[o]))
        }, t.parseUInt = function(t) {
            return Math.abs(parseInt(t))
        }
    }(o);
    var e, n, s, r, a, l, m, c, h, _, p, y, u, x, f, d, b, v, C, w, A, g, S, B, M, V, D, I, G, L, J, F, P, T, R, k, z, E, N, j = Array,
        O = o.NVector;
    for (void 0 === o && (o = {}), void 0 === o.Collision && (o.Collision = {}), void 0 === o.Collision.Shapes && (o.Collision.Shapes = {}), void 0 === o.Common && (o.Common = {}), void 0 === o.Common.Math && (o.Common.Math = {}), void 0 === o.Dynamics && (o.Dynamics = {}), void 0 === o.Dynamics.Contacts && (o.Dynamics.Contacts = {}), void 0 === o.Dynamics.Controllers && (o.Dynamics.Controllers = {}), void 0 === o.Dynamics.Joints && (o.Dynamics.Joints = {}), o.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase", o.Collision.b2AABB = function t() {
            t.b2AABB.apply(this, arguments)
        }, o.Collision.b2Bound = function t() {
            t.b2Bound.apply(this, arguments)
        }, o.Collision.b2BoundValues = function t() {
            t.b2BoundValues.apply(this, arguments), this.constructor === t && this.b2BoundValues.apply(this, arguments)
        }, o.Collision.b2Collision = function t() {
            t.b2Collision.apply(this, arguments)
        }, o.Collision.b2ContactID = function t() {
            t.b2ContactID.apply(this, arguments), this.constructor === t && this.b2ContactID.apply(this, arguments)
        }, o.Collision.b2ContactPoint = function t() {
            t.b2ContactPoint.apply(this, arguments)
        }, o.Collision.b2Distance = function t() {
            t.b2Distance.apply(this, arguments)
        }, o.Collision.b2DistanceInput = function t() {
            t.b2DistanceInput.apply(this, arguments)
        }, o.Collision.b2DistanceOutput = function t() {
            t.b2DistanceOutput.apply(this, arguments)
        }, o.Collision.b2DistanceProxy = function t() {
            t.b2DistanceProxy.apply(this, arguments)
        }, o.Collision.b2DynamicTree = function t() {
            t.b2DynamicTree.apply(this, arguments), this.constructor === t && this.b2DynamicTree.apply(this, arguments)
        }, o.Collision.b2DynamicTreeBroadPhase = function t() {
            t.b2DynamicTreeBroadPhase.apply(this, arguments)
        }, o.Collision.b2DynamicTreeNode = function t() {
            t.b2DynamicTreeNode.apply(this, arguments)
        }, o.Collision.b2DynamicTreePair = function t() {
            t.b2DynamicTreePair.apply(this, arguments)
        }, o.Collision.b2Manifold = function t() {
            t.b2Manifold.apply(this, arguments), this.constructor === t && this.b2Manifold.apply(this, arguments)
        }, o.Collision.b2ManifoldPoint = function t() {
            t.b2ManifoldPoint.apply(this, arguments), this.constructor === t && this.b2ManifoldPoint.apply(this, arguments)
        }, o.Collision.b2Point = function t() {
            t.b2Point.apply(this, arguments)
        }, o.Collision.b2RayCastInput = function t() {
            t.b2RayCastInput.apply(this, arguments), this.constructor === t && this.b2RayCastInput.apply(this, arguments)
        }, o.Collision.b2RayCastOutput = function t() {
            t.b2RayCastOutput.apply(this, arguments)
        }, o.Collision.b2Segment = function t() {
            t.b2Segment.apply(this, arguments)
        }, o.Collision.b2SeparationFunction = function t() {
            t.b2SeparationFunction.apply(this, arguments)
        }, o.Collision.b2Simplex = function t() {
            t.b2Simplex.apply(this, arguments), this.constructor === t && this.b2Simplex.apply(this, arguments)
        }, o.Collision.b2SimplexCache = function t() {
            t.b2SimplexCache.apply(this, arguments)
        }, o.Collision.b2SimplexVertex = function t() {
            t.b2SimplexVertex.apply(this, arguments)
        }, o.Collision.b2TimeOfImpact = function t() {
            t.b2TimeOfImpact.apply(this, arguments)
        }, o.Collision.b2TOIInput = function t() {
            t.b2TOIInput.apply(this, arguments)
        }, o.Collision.b2WorldManifold = function t() {
            t.b2WorldManifold.apply(this, arguments), this.constructor === t && this.b2WorldManifold.apply(this, arguments)
        }, o.Collision.ClipVertex = function t() {
            t.ClipVertex.apply(this, arguments)
        }, o.Collision.Features = function t() {
            t.Features.apply(this, arguments)
        }, o.Collision.Shapes.b2CircleShape = function t() {
            t.b2CircleShape.apply(this, arguments), this.constructor === t && this.b2CircleShape.apply(this, arguments)
        }, o.Collision.Shapes.b2EdgeChainDef = function t() {
            t.b2EdgeChainDef.apply(this, arguments), this.constructor === t && this.b2EdgeChainDef.apply(this, arguments)
        }, o.Collision.Shapes.b2EdgeShape = function t() {
            t.b2EdgeShape.apply(this, arguments), this.constructor === t && this.b2EdgeShape.apply(this, arguments)
        }, o.Collision.Shapes.b2MassData = function t() {
            t.b2MassData.apply(this, arguments)
        }, o.Collision.Shapes.b2PolygonShape = function t() {
            t.b2PolygonShape.apply(this, arguments), this.constructor === t && this.b2PolygonShape.apply(this, arguments)
        }, o.Collision.Shapes.b2Shape = function t() {
            t.b2Shape.apply(this, arguments), this.constructor === t && this.b2Shape.apply(this, arguments)
        }, o.Common.b2internal = "Box2D.Common.b2internal", o.Common.b2Color = function t() {
            t.b2Color.apply(this, arguments), this.constructor === t && this.b2Color.apply(this, arguments)
        }, o.Common.b2Settings = function t() {
            t.b2Settings.apply(this, arguments)
        }, o.Common.Math.b2Mat22 = function t() {
            t.b2Mat22.apply(this, arguments), this.constructor === t && this.b2Mat22.apply(this, arguments)
        }, o.Common.Math.b2Mat33 = function t() {
            t.b2Mat33.apply(this, arguments), this.constructor === t && this.b2Mat33.apply(this, arguments)
        }, o.Common.Math.b2Math = function t() {
            t.b2Math.apply(this, arguments)
        }, o.Common.Math.b2Sweep = function t() {
            t.b2Sweep.apply(this, arguments)
        }, o.Common.Math.b2Transform = function t() {
            t.b2Transform.apply(this, arguments), this.constructor === t && this.b2Transform.apply(this, arguments)
        }, o.Common.Math.b2Vec2 = function t() {
            t.b2Vec2.apply(this, arguments), this.constructor === t && this.b2Vec2.apply(this, arguments)
        }, o.Common.Math.b2Vec3 = function t() {
            t.b2Vec3.apply(this, arguments), this.constructor === t && this.b2Vec3.apply(this, arguments)
        }, o.Dynamics.b2Body = function t() {
            t.b2Body.apply(this, arguments), this.constructor === t && this.b2Body.apply(this, arguments)
        }, o.Dynamics.b2BodyDef = function t() {
            t.b2BodyDef.apply(this, arguments), this.constructor === t && this.b2BodyDef.apply(this, arguments)
        }, o.Dynamics.b2ContactFilter = function t() {
            t.b2ContactFilter.apply(this, arguments)
        }, o.Dynamics.b2ContactImpulse = function t() {
            t.b2ContactImpulse.apply(this, arguments)
        }, o.Dynamics.b2ContactListener = function t() {
            t.b2ContactListener.apply(this, arguments)
        }, o.Dynamics.b2ContactManager = function t() {
            t.b2ContactManager.apply(this, arguments), this.constructor === t && this.b2ContactManager.apply(this, arguments)
        }, o.Dynamics.b2DebugDraw = function t() {
            t.b2DebugDraw.apply(this, arguments), this.constructor === t && this.b2DebugDraw.apply(this, arguments)
        }, o.Dynamics.b2DestructionListener = function t() {
            t.b2DestructionListener.apply(this, arguments)
        }, o.Dynamics.b2FilterData = function t() {
            t.b2FilterData.apply(this, arguments)
        }, o.Dynamics.b2Fixture = function t() {
            t.b2Fixture.apply(this, arguments), this.constructor === t && this.b2Fixture.apply(this, arguments)
        }, o.Dynamics.b2FixtureDef = function t() {
            t.b2FixtureDef.apply(this, arguments), this.constructor === t && this.b2FixtureDef.apply(this, arguments)
        }, o.Dynamics.b2Island = function t() {
            t.b2Island.apply(this, arguments), this.constructor === t && this.b2Island.apply(this, arguments)
        }, o.Dynamics.b2TimeStep = function t() {
            t.b2TimeStep.apply(this, arguments)
        }, o.Dynamics.b2World = function t() {
            t.b2World.apply(this, arguments), this.constructor === t && this.b2World.apply(this, arguments)
        }, o.Dynamics.Contacts.b2CircleContact = function t() {
            t.b2CircleContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2Contact = function t() {
            t.b2Contact.apply(this, arguments), this.constructor === t && this.b2Contact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactConstraint = function t() {
            t.b2ContactConstraint.apply(this, arguments), this.constructor === t && this.b2ContactConstraint.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactConstraintPoint = function t() {
            t.b2ContactConstraintPoint.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactEdge = function t() {
            t.b2ContactEdge.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactFactory = function t() {
            t.b2ContactFactory.apply(this, arguments), this.constructor === t && this.b2ContactFactory.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactRegister = function t() {
            t.b2ContactRegister.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactResult = function t() {
            t.b2ContactResult.apply(this, arguments)
        }, o.Dynamics.Contacts.b2ContactSolver = function t() {
            t.b2ContactSolver.apply(this, arguments), this.constructor === t && this.b2ContactSolver.apply(this, arguments)
        }, o.Dynamics.Contacts.b2EdgeAndCircleContact = function t() {
            t.b2EdgeAndCircleContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2NullContact = function t() {
            t.b2NullContact.apply(this, arguments), this.constructor === t && this.b2NullContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2PolyAndCircleContact = function t() {
            t.b2PolyAndCircleContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2PolyAndEdgeContact = function t() {
            t.b2PolyAndEdgeContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2PolygonContact = function t() {
            t.b2PolygonContact.apply(this, arguments)
        }, o.Dynamics.Contacts.b2PositionSolverManifold = function t() {
            t.b2PositionSolverManifold.apply(this, arguments), this.constructor === t && this.b2PositionSolverManifold.apply(this, arguments)
        }, o.Dynamics.Controllers.b2BuoyancyController = function t() {
            t.b2BuoyancyController.apply(this, arguments)
        }, o.Dynamics.Controllers.b2ConstantAccelController = function t() {
            t.b2ConstantAccelController.apply(this, arguments)
        }, o.Dynamics.Controllers.b2ConstantForceController = function t() {
            t.b2ConstantForceController.apply(this, arguments)
        }, o.Dynamics.Controllers.b2Controller = function t() {
            t.b2Controller.apply(this, arguments)
        }, o.Dynamics.Controllers.b2ControllerEdge = function t() {
            t.b2ControllerEdge.apply(this, arguments)
        }, o.Dynamics.Controllers.b2GravityController = function t() {
            t.b2GravityController.apply(this, arguments)
        }, o.Dynamics.Controllers.b2TensorDampingController = function t() {
            t.b2TensorDampingController.apply(this, arguments)
        }, o.Dynamics.Joints.b2DistanceJoint = function t() {
            t.b2DistanceJoint.apply(this, arguments), this.constructor === t && this.b2DistanceJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2DistanceJointDef = function t() {
            t.b2DistanceJointDef.apply(this, arguments), this.constructor === t && this.b2DistanceJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2FrictionJoint = function t() {
            t.b2FrictionJoint.apply(this, arguments), this.constructor === t && this.b2FrictionJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2FrictionJointDef = function t() {
            t.b2FrictionJointDef.apply(this, arguments), this.constructor === t && this.b2FrictionJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2GearJoint = function t() {
            t.b2GearJoint.apply(this, arguments), this.constructor === t && this.b2GearJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2GearJointDef = function t() {
            t.b2GearJointDef.apply(this, arguments), this.constructor === t && this.b2GearJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2Jacobian = function t() {
            t.b2Jacobian.apply(this, arguments)
        }, o.Dynamics.Joints.b2Joint = function t() {
            t.b2Joint.apply(this, arguments), this.constructor === t && this.b2Joint.apply(this, arguments)
        }, o.Dynamics.Joints.b2JointDef = function t() {
            t.b2JointDef.apply(this, arguments), this.constructor === t && this.b2JointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2JointEdge = function t() {
            t.b2JointEdge.apply(this, arguments)
        }, o.Dynamics.Joints.b2LineJoint = function t() {
            t.b2LineJoint.apply(this, arguments), this.constructor === t && this.b2LineJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2LineJointDef = function t() {
            t.b2LineJointDef.apply(this, arguments), this.constructor === t && this.b2LineJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2MouseJoint = function t() {
            t.b2MouseJoint.apply(this, arguments), this.constructor === t && this.b2MouseJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2MouseJointDef = function t() {
            t.b2MouseJointDef.apply(this, arguments), this.constructor === t && this.b2MouseJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2PrismaticJoint = function t() {
            t.b2PrismaticJoint.apply(this, arguments), this.constructor === t && this.b2PrismaticJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2PrismaticJointDef = function t() {
            t.b2PrismaticJointDef.apply(this, arguments), this.constructor === t && this.b2PrismaticJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2PulleyJoint = function t() {
            t.b2PulleyJoint.apply(this, arguments), this.constructor === t && this.b2PulleyJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2PulleyJointDef = function t() {
            t.b2PulleyJointDef.apply(this, arguments), this.constructor === t && this.b2PulleyJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2RevoluteJoint = function t() {
            t.b2RevoluteJoint.apply(this, arguments), this.constructor === t && this.b2RevoluteJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2RevoluteJointDef = function t() {
            t.b2RevoluteJointDef.apply(this, arguments), this.constructor === t && this.b2RevoluteJointDef.apply(this, arguments)
        }, o.Dynamics.Joints.b2WeldJoint = function t() {
            t.b2WeldJoint.apply(this, arguments), this.constructor === t && this.b2WeldJoint.apply(this, arguments)
        }, o.Dynamics.Joints.b2WeldJointDef = function t() {
            t.b2WeldJointDef.apply(this, arguments), this.constructor === t && this.b2WeldJointDef.apply(this, arguments)
        }, o.postDefs = [], e = o.Collision.Shapes.b2CircleShape, n = o.Collision.Shapes.b2PolygonShape, s = o.Collision.Shapes.b2Shape, r = o.Common.b2Settings, a = o.Common.Math.b2Math, l = o.Common.Math.b2Sweep, m = o.Common.Math.b2Transform, c = o.Common.Math.b2Vec2, h = o.Collision.b2AABB, _ = o.Collision.b2Bound, p = o.Collision.b2BoundValues, y = o.Collision.b2Collision, u = o.Collision.b2ContactID, x = o.Collision.b2ContactPoint, f = o.Collision.b2Distance, d = o.Collision.b2DistanceInput, b = o.Collision.b2DistanceOutput, v = o.Collision.b2DistanceProxy, C = o.Collision.b2DynamicTree, w = o.Collision.b2DynamicTreeBroadPhase, A = o.Collision.b2DynamicTreeNode, g = o.Collision.b2DynamicTreePair, S = o.Collision.b2Manifold, B = o.Collision.b2ManifoldPoint, M = o.Collision.b2Point, V = o.Collision.b2RayCastInput, D = o.Collision.b2RayCastOutput, I = o.Collision.b2Segment, G = o.Collision.b2SeparationFunction, L = o.Collision.b2Simplex, J = o.Collision.b2SimplexCache, F = o.Collision.b2SimplexVertex, P = o.Collision.b2TimeOfImpact, T = o.Collision.b2TOIInput, R = o.Collision.b2WorldManifold, k = o.Collision.ClipVertex, z = o.Collision.Features, E = o.Collision.IBroadPhase, h.b2AABB = function() {
            this.lowerBound = new c, this.upperBound = new c
        }, h.prototype.IsValid = function() {
            var t = this.upperBound.y - this.lowerBound.y;
            return (t = this.upperBound.x - this.lowerBound.x >= 0 && t >= 0) && this.lowerBound.IsValid() && this.upperBound.IsValid()
        }, h.prototype.GetCenter = function() {
            return new c((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
        }, h.prototype.GetExtents = function() {
            return new c((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
        }, h.prototype.Contains = function(t) {
            var i = !0;
            return (i = (i = (i = i && this.lowerBound.x <= t.lowerBound.x) && this.lowerBound.y <= t.lowerBound.y) && t.upperBound.x <= this.upperBound.x) && t.upperBound.y <= this.upperBound.y
        }, h.prototype.RayCast = function(t, i) {
            var o = -Number.MAX_VALUE,
                e = Number.MAX_VALUE,
                n = i.p1.x,
                s = i.p1.y,
                r = i.p2.x - i.p1.x,
                a = i.p2.y - i.p1.y,
                l = Math.abs(a),
                m = t.normal,
                c = 0,
                h = 0,
                _ = c = 0;
            if (_ = 0, Math.abs(r) < Number.MIN_VALUE) {
                if (n < this.lowerBound.x || this.upperBound.x < n) return !1
            } else if (c = 1 / r, _ = -1, (h = (this.lowerBound.x - n) * c) > (c = (this.upperBound.x - n) * c) && (_ = h, h = c, c = _, _ = 1), h > o && (m.x = _, m.y = 0, o = h), o > (e = Math.min(e, c))) return !1;
            if (l < Number.MIN_VALUE) {
                if (s < this.lowerBound.y || this.upperBound.y < s) return !1
            } else if (c = 1 / a, _ = -1, (h = (this.lowerBound.y - s) * c) > (c = (this.upperBound.y - s) * c) && (_ = h, h = c, c = _, _ = 1), h > o && (m.y = _, m.x = 0, o = h), o > (e = Math.min(e, c))) return !1;
            return t.fraction = o, !0
        }, h.prototype.TestOverlap = function(t) {
            var i = t.lowerBound.y - this.upperBound.y,
                o = this.lowerBound.y - t.upperBound.y;
            return !(t.lowerBound.x - this.upperBound.x > 0 || i > 0 || this.lowerBound.x - t.upperBound.x > 0 || o > 0)
        }, h.Combine = function(t, i) {
            var o = new h;
            return o.Combine(t, i), o
        }, h.prototype.Combine = function(t, i) {
            this.lowerBound.x = Math.min(t.lowerBound.x, i.lowerBound.x), this.lowerBound.y = Math.min(t.lowerBound.y, i.lowerBound.y), this.upperBound.x = Math.max(t.upperBound.x, i.upperBound.x), this.upperBound.y = Math.max(t.upperBound.y, i.upperBound.y)
        }, _.b2Bound = function() {}, _.prototype.IsLower = function() {
            return 0 == (1 & this.value)
        }, _.prototype.IsUpper = function() {
            return 1 == (1 & this.value)
        }, _.prototype.Swap = function(t) {
            var i = this.value,
                o = this.proxy,
                e = this.stabbingCount;
            this.value = t.value, this.proxy = t.proxy, this.stabbingCount = t.stabbingCount, t.value = i, t.proxy = o, t.stabbingCount = e
        }, p.b2BoundValues = function() {}, p.prototype.b2BoundValues = function() {
            this.lowerValues = new O, this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new O, this.upperValues[0] = 0, this.upperValues[1] = 0
        }, y.b2Collision = function() {}, y.ClipSegmentToLine = function(t, i, o, e) {
            void 0 === e && (e = 0);
            var n, s = 0,
                r = (n = i[0]).v,
                a = (n = i[1]).v,
                l = o.x * r.x + o.y * r.y - e;
            return n = o.x * a.x + o.y * a.y - e, l <= 0 && t[s++].Set(i[0]), n <= 0 && t[s++].Set(i[1]), l * n < 0 && (o = l / (l - n), (n = (n = t[s]).v).x = r.x + o * (a.x - r.x), n.y = r.y + o * (a.y - r.y), (n = t[s]).id = (l > 0 ? i[0] : i[1]).id, ++s), s
        }, y.EdgeSeparation = function(t, i, o, e, n) {
            void 0 === o && (o = 0), parseInt(t.m_vertexCount);
            var s = t.m_vertices;
            t = t.m_normals;
            var r, a, l = parseInt(e.m_vertexCount),
                m = e.m_vertices;
            r = i.R, a = t[o], t = r.col1.x * a.x + r.col2.x * a.y, e = r.col1.y * a.x + r.col2.y * a.y;
            var c = (r = n.R).col1.x * t + r.col1.y * e;
            r = r.col2.x * t + r.col2.y * e;
            for (var h = 0, _ = Number.MAX_VALUE, p = 0; p < l; ++p)(a = (a = m[p]).x * c + a.y * r) < _ && (_ = a, h = p);
            return a = s[o], r = i.R, o = i.position.x + (r.col1.x * a.x + r.col2.x * a.y), i = i.position.y + (r.col1.y * a.x + r.col2.y * a.y), a = m[h], r = n.R, s = n.position.x + (r.col1.x * a.x + r.col2.x * a.y), n = n.position.y + (r.col1.y * a.x + r.col2.y * a.y), (s -= o) * t + (n -= i) * e
        }, y.FindMaxSeparation = function(t, i, o, e, n) {
            var s, r, a = parseInt(i.m_vertexCount),
                l = i.m_normals;
            r = n.R, s = e.m_centroid;
            var m = n.position.x + (r.col1.x * s.x + r.col2.x * s.y),
                c = n.position.y + (r.col1.y * s.x + r.col2.y * s.y);
            r = o.R, s = i.m_centroid, m -= o.position.x + (r.col1.x * s.x + r.col2.x * s.y), c -= o.position.y + (r.col1.y * s.x + r.col2.y * s.y), r = m * o.R.col1.x + c * o.R.col1.y, c = m * o.R.col2.x + c * o.R.col2.y, m = 0;
            for (var h = -Number.MAX_VALUE, _ = 0; _ < a; ++_)(s = (s = l[_]).x * r + s.y * c) > h && (h = s, m = _);
            l = y.EdgeSeparation(i, o, m, e, n), s = parseInt(m - 1 >= 0 ? m - 1 : a - 1), r = y.EdgeSeparation(i, o, s, e, n), c = parseInt(m + 1 < a ? m + 1 : 0), h = y.EdgeSeparation(i, o, c, e, n);
            var p = _ = 0,
                u = 0;
            if (r > l && r > h) u = -1, _ = s, p = r;
            else {
                if (!(h > l)) return t[0] = m, l;
                u = 1, _ = c, p = h
            }
            for (; m = -1 == u ? _ - 1 >= 0 ? _ - 1 : a - 1 : _ + 1 < a ? _ + 1 : 0, (l = y.EdgeSeparation(i, o, m, e, n)) > p;) _ = m, p = l;
            return t[0] = _, p
        }, y.FindIncidentEdge = function(t, i, o, e, n, s) {
            void 0 === e && (e = 0), parseInt(i.m_vertexCount);
            var r, a = i.m_normals,
                l = parseInt(n.m_vertexCount);
            i = n.m_vertices, n = n.m_normals, r = o.R, o = a[e], a = r.col1.x * o.x + r.col2.x * o.y;
            var m = r.col1.y * o.x + r.col2.y * o.y;
            o = (r = s.R).col1.x * a + r.col1.y * m, m = r.col2.x * a + r.col2.y * m, a = o, r = 0;
            for (var c = Number.MAX_VALUE, h = 0; h < l; ++h)(o = a * (o = n[h]).x + m * o.y) < c && (c = o, r = h);
            n = parseInt(r), a = parseInt(n + 1 < l ? n + 1 : 0), l = t[0], o = i[n], r = s.R, l.v.x = s.position.x + (r.col1.x * o.x + r.col2.x * o.y), l.v.y = s.position.y + (r.col1.y * o.x + r.col2.y * o.y), l.id.features.referenceEdge = e, l.id.features.incidentEdge = n, l.id.features.incidentVertex = 0, l = t[1], o = i[a], r = s.R, l.v.x = s.position.x + (r.col1.x * o.x + r.col2.x * o.y), l.v.y = s.position.y + (r.col1.y * o.x + r.col2.y * o.y), l.id.features.referenceEdge = e, l.id.features.incidentEdge = a, l.id.features.incidentVertex = 1
        }, y.MakeClipPointVector = function() {
            var t = new j(2);
            return t[0] = new k, t[1] = new k, t
        }, y.CollidePolygons = function(t, i, o, e, n) {
            var s;
            t.m_pointCount = 0;
            var a = i.m_radius + e.m_radius;
            s = 0, y.s_edgeAO[0] = s;
            var l = y.FindMaxSeparation(y.s_edgeAO, i, o, e, n);
            if (s = y.s_edgeAO[0], !(l > a)) {
                var m = 0;
                y.s_edgeBO[0] = m;
                var c = y.FindMaxSeparation(y.s_edgeBO, e, n, i, o);
                if (m = y.s_edgeBO[0], !(c > a)) {
                    var h, _ = 0,
                        p = 0;
                    c > .98 * l + .001 ? (l = e, e = i, i = n, o = o, _ = m, t.m_type = S.e_faceB, p = 1) : (l = i, e = e, i = o, o = n, _ = s, t.m_type = S.e_faceA, p = 0), s = y.s_incidentEdge, y.FindIncidentEdge(s, l, i, _, e, o), m = parseInt(l.m_vertexCount), l = (n = l.m_vertices)[_], h = _ + 1 < m ? n[parseInt(_ + 1)] : n[0], (_ = y.s_localTangent).Set(h.x - l.x, h.y - l.y), _.Normalize(), (n = y.s_localNormal).x = _.y, n.y = -_.x, (e = y.s_planePoint).Set(.5 * (l.x + h.x), .5 * (l.y + h.y)), c = y.s_tangent, m = i.R, c.x = m.col1.x * _.x + m.col2.x * _.y, c.y = m.col1.y * _.x + m.col2.y * _.y;
                    var u = y.s_tangent2;
                    u.x = -c.x, u.y = -c.y, (_ = y.s_normal).x = c.y, _.y = -c.x;
                    var x = y.s_v11,
                        f = y.s_v12;
                    if (x.x = i.position.x + (m.col1.x * l.x + m.col2.x * l.y), x.y = i.position.y + (m.col1.y * l.x + m.col2.y * l.y), f.x = i.position.x + (m.col1.x * h.x + m.col2.x * h.y), f.y = i.position.y + (m.col1.y * h.x + m.col2.y * h.y), i = _.x * x.x + _.y * x.y, m = c.x * f.x + c.y * f.y + a, h = y.s_clipPoints1, l = y.s_clipPoints2, f = 0, !((f = y.ClipSegmentToLine(h, s, u, -c.x * x.x - c.y * x.y + a)) < 2 || (f = y.ClipSegmentToLine(l, h, c, m)) < 2)) {
                        for (t.m_localPlaneNormal.SetV(n), t.m_localPoint.SetV(e), e = n = 0; e < r.b2_maxManifoldPoints; ++e) s = l[e], _.x * s.v.x + _.y * s.v.y - i <= a && (c = t.m_points[n], m = o.R, u = s.v.x - o.position.x, x = s.v.y - o.position.y, c.m_localPoint.x = u * m.col1.x + x * m.col1.y, c.m_localPoint.y = u * m.col2.x + x * m.col2.y, c.m_id.Set(s.id), c.m_id.features.flip = p, ++n);
                        t.m_pointCount = n
                    }
                }
            }
        }, y.CollideCircles = function(t, i, o, e, n) {
            var s, r;
            t.m_pointCount = 0, s = o.R, r = i.m_p;
            var a = o.position.x + (s.col1.x * r.x + s.col2.x * r.y);
            o = o.position.y + (s.col1.y * r.x + s.col2.y * r.y), s = n.R, r = e.m_p, (a = n.position.x + (s.col1.x * r.x + s.col2.x * r.y) - a) * a + (n = n.position.y + (s.col1.y * r.x + s.col2.y * r.y) - o) * n > (s = i.m_radius + e.m_radius) * s || (t.m_type = S.e_circles, t.m_localPoint.SetV(i.m_p), t.m_localPlaneNormal.SetZero(), t.m_pointCount = 1, t.m_points[0].m_localPoint.SetV(e.m_p), t.m_points[0].m_id.key = 0)
        }, y.CollidePolygonAndCircle = function(t, i, o, e, n) {
            var s, r, a = t.m_pointCount = 0,
                l = 0;
            r = n.R, s = e.m_p;
            var m = n.position.y + (r.col1.y * s.x + r.col2.y * s.y);
            a = n.position.x + (r.col1.x * s.x + r.col2.x * s.y) - o.position.x, l = m - o.position.y, o = a * (r = o.R).col1.x + l * r.col1.y, r = a * r.col2.x + l * r.col2.y;
            var c = 0;
            m = -Number.MAX_VALUE, n = i.m_radius + e.m_radius;
            var h = parseInt(i.m_vertexCount),
                _ = i.m_vertices;
            i = i.m_normals;
            for (var p = 0; p < h; ++p) {
                if (a = o - (s = _[p]).x, l = r - s.y, (a = (s = i[p]).x * a + s.y * l) > n) return;
                a > m && (m = a, c = p)
            }
            if (a = parseInt(c), l = parseInt(a + 1 < h ? a + 1 : 0), s = _[a], _ = _[l], m < Number.MIN_VALUE) t.m_pointCount = 1, t.m_type = S.e_faceA, t.m_localPlaneNormal.SetV(i[c]), t.m_localPoint.x = .5 * (s.x + _.x), t.m_localPoint.y = .5 * (s.y + _.y);
            else if (m = (o - _.x) * (s.x - _.x) + (r - _.y) * (s.y - _.y), (o - s.x) * (_.x - s.x) + (r - s.y) * (_.y - s.y) <= 0) {
                if ((o - s.x) * (o - s.x) + (r - s.y) * (r - s.y) > n * n) return;
                t.m_pointCount = 1, t.m_type = S.e_faceA, t.m_localPlaneNormal.x = o - s.x, t.m_localPlaneNormal.y = r - s.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(s)
            } else if (m <= 0) {
                if ((o - _.x) * (o - _.x) + (r - _.y) * (r - _.y) > n * n) return;
                t.m_pointCount = 1, t.m_type = S.e_faceA, t.m_localPlaneNormal.x = o - _.x, t.m_localPlaneNormal.y = r - _.y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.SetV(_)
            } else {
                if (c = .5 * (s.x + _.x), s = .5 * (s.y + _.y), (m = (o - c) * i[a].x + (r - s) * i[a].y) > n) return;
                t.m_pointCount = 1, t.m_type = S.e_faceA, t.m_localPlaneNormal.x = i[a].x, t.m_localPlaneNormal.y = i[a].y, t.m_localPlaneNormal.Normalize(), t.m_localPoint.Set(c, s)
            }
            t.m_points[0].m_localPoint.SetV(e.m_p), t.m_points[0].m_id.key = 0
        }, y.TestOverlap = function(t, i) {
            var o = i.lowerBound,
                e = t.upperBound,
                n = o.x - e.x,
                s = o.y - e.y;
            o = t.lowerBound, e = i.upperBound;
            var r = o.y - e.y;
            return !(n > 0 || s > 0 || o.x - e.x > 0 || r > 0)
        }, o.postDefs.push(function() {
            o.Collision.b2Collision.s_incidentEdge = y.MakeClipPointVector(), o.Collision.b2Collision.s_clipPoints1 = y.MakeClipPointVector(), o.Collision.b2Collision.s_clipPoints2 = y.MakeClipPointVector(), o.Collision.b2Collision.s_edgeAO = new O(1), o.Collision.b2Collision.s_edgeBO = new O(1), o.Collision.b2Collision.s_localTangent = new c, o.Collision.b2Collision.s_localNormal = new c, o.Collision.b2Collision.s_planePoint = new c, o.Collision.b2Collision.s_normal = new c, o.Collision.b2Collision.s_tangent = new c, o.Collision.b2Collision.s_tangent2 = new c, o.Collision.b2Collision.s_v11 = new c, o.Collision.b2Collision.s_v12 = new c, o.Collision.b2Collision.b2CollidePolyTempVec = new c, o.Collision.b2Collision.b2_nullFeature = 255
        }), u.b2ContactID = function() {
            this.features = new z
        }, u.prototype.b2ContactID = function() {
            this.features._m_id = this
        }, u.prototype.Set = function(t) {
            this.key = t._key
        }, u.prototype.Copy = function() {
            var t = new u;
            return t.key = this.key, t
        }, Object.defineProperty(u.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._key
            }
        }), Object.defineProperty(u.prototype, "key", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._key = t, this.features._referenceEdge = 255 & this._key, this.features._incidentEdge = (65280 & this._key) >> 8 & 255, this.features._incidentVertex = (16711680 & this._key) >> 16 & 255, this.features._flip = (4278190080 & this._key) >> 24 & 255
            }
        }), x.b2ContactPoint = function() {
            this.position = new c, this.velocity = new c, this.normal = new c, this.id = new u
        }, f.b2Distance = function() {}, f.Distance = function(t, i, o) {
            ++f.b2_gjkCalls;
            var e = o.proxyA,
                n = o.proxyB,
                s = o.transformA,
                l = o.transformB,
                m = f.s_simplex;
            m.ReadCache(i, e, s, n, l);
            var h = m.m_vertices,
                _ = f.s_saveA,
                p = f.s_saveB,
                y = 0;
            m.GetClosestPoint().LengthSquared();
            for (var u, x = 0, d = 0; d < 20;) {
                for (y = m.m_count, x = 0; x < y; x++) _[x] = h[x].indexA, p[x] = h[x].indexB;
                switch (m.m_count) {
                    case 1:
                        break;
                    case 2:
                        m.Solve2();
                        break;
                    case 3:
                        m.Solve3();
                        break;
                    default:
                        r.b2Assert(!1)
                }
                if (3 == m.m_count) break;
                if ((u = m.GetClosestPoint()).LengthSquared(), (x = m.GetSearchDirection()).LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
                (u = h[m.m_count]).indexA = e.GetSupport(a.MulTMV(s.R, x.GetNegative())), u.wA = a.MulX(s, e.GetVertex(u.indexA)), u.indexB = n.GetSupport(a.MulTMV(l.R, x)), u.wB = a.MulX(l, n.GetVertex(u.indexB)), u.w = a.SubtractVV(u.wB, u.wA), ++d, ++f.b2_gjkIters;
                var b = !1;
                for (x = 0; x < y; x++)
                    if (u.indexA == _[x] && u.indexB == p[x]) {
                        b = !0;
                        break
                    } if (b) break;
                ++m.m_count
            }
            f.b2_gjkMaxIters = a.Max(f.b2_gjkMaxIters, d), m.GetWitnessPoints(t.pointA, t.pointB), t.distance = a.SubtractVV(t.pointA, t.pointB).Length(), t.iterations = d, m.WriteCache(i), o.useRadii && (i = e.m_radius, n = n.m_radius, t.distance > i + n && t.distance > Number.MIN_VALUE ? (t.distance -= i + n, (o = a.SubtractVV(t.pointB, t.pointA)).Normalize(), t.pointA.x += i * o.x, t.pointA.y += i * o.y, t.pointB.x -= n * o.x, t.pointB.y -= n * o.y) : ((u = new c).x = .5 * (t.pointA.x + t.pointB.x), u.y = .5 * (t.pointA.y + t.pointB.y), t.pointA.x = t.pointB.x = u.x, t.pointA.y = t.pointB.y = u.y, t.distance = 0))
        }, o.postDefs.push(function() {
            o.Collision.b2Distance.s_simplex = new L, o.Collision.b2Distance.s_saveA = new O(3), o.Collision.b2Distance.s_saveB = new O(3)
        }), d.b2DistanceInput = function() {}, b.b2DistanceOutput = function() {
            this.pointA = new c, this.pointB = new c
        }, v.b2DistanceProxy = function() {}, v.prototype.Set = function(t) {
            switch (t.GetType()) {
                case s.e_circleShape:
                    t = t instanceof e ? t : null, this.m_vertices = new j(1, !0), this.m_vertices[0] = t.m_p, this.m_count = 1, this.m_radius = t.m_radius;
                    break;
                case s.e_polygonShape:
                    t = t instanceof n ? t : null, this.m_vertices = t.m_vertices, this.m_count = t.m_vertexCount, this.m_radius = t.m_radius;
                    break;
                default:
                    r.b2Assert(!1)
            }
        }, v.prototype.GetSupport = function(t) {
            for (var i = 0, o = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, e = 1; e < this.m_count; ++e) {
                var n = this.m_vertices[e].x * t.x + this.m_vertices[e].y * t.y;
                n > o && (i = e, o = n)
            }
            return i
        }, v.prototype.GetSupportVertex = function(t) {
            for (var i = 0, o = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, e = 1; e < this.m_count; ++e) {
                var n = this.m_vertices[e].x * t.x + this.m_vertices[e].y * t.y;
                n > o && (i = e, o = n)
            }
            return this.m_vertices[i]
        }, v.prototype.GetVertexCount = function() {
            return this.m_count
        }, v.prototype.GetVertex = function(t) {
            return void 0 === t && (t = 0), r.b2Assert(0 <= t && t < this.m_count), this.m_vertices[t]
        }, C.b2DynamicTree = function() {}, C.prototype.b2DynamicTree = function() {
            this.m_freeList = this.m_root = null, this.m_insertionCount = this.m_path = 0
        }, C.prototype.CreateProxy = function(t, i) {
            var o = this.AllocateNode(),
                e = r.b2_aabbExtension,
                n = r.b2_aabbExtension;
            return o.aabb.lowerBound.x = t.lowerBound.x - e, o.aabb.lowerBound.y = t.lowerBound.y - n, o.aabb.upperBound.x = t.upperBound.x + e, o.aabb.upperBound.y = t.upperBound.y + n, o.userData = i, this.InsertLeaf(o), o
        }, C.prototype.DestroyProxy = function(t) {
            this.RemoveLeaf(t), this.FreeNode(t)
        }, C.prototype.MoveProxy = function(t, i, o) {
            if (r.b2Assert(t.IsLeaf()), t.aabb.Contains(i)) return !1;
            this.RemoveLeaf(t);
            var e = r.b2_aabbExtension + r.b2_aabbMultiplier * (o.x > 0 ? o.x : -o.x);
            return o = r.b2_aabbExtension + r.b2_aabbMultiplier * (o.y > 0 ? o.y : -o.y), t.aabb.lowerBound.x = i.lowerBound.x - e, t.aabb.lowerBound.y = i.lowerBound.y - o, t.aabb.upperBound.x = i.upperBound.x + e, t.aabb.upperBound.y = i.upperBound.y + o, this.InsertLeaf(t), !0
        }, C.prototype.Rebalance = function(t) {
            if (void 0 === t && (t = 0), null != this.m_root)
                for (var i = 0; i < t; i++) {
                    for (var o = this.m_root, e = 0; 0 == o.IsLeaf();) o = this.m_path >> e & 1 ? o.child2 : o.child1, e = e + 1 & 31;
                    ++this.m_path, this.RemoveLeaf(o), this.InsertLeaf(o)
                }
        }, C.prototype.GetFatAABB = function(t) {
            return t.aabb
        }, C.prototype.GetUserData = function(t) {
            return t.userData
        }, C.prototype.Query = function(t, i) {
            if (null != this.m_root) {
                var o = new j,
                    e = 0;
                for (o[e++] = this.m_root; e > 0;) {
                    var n = o[--e];
                    if (n.aabb.TestOverlap(i))
                        if (n.IsLeaf()) {
                            if (!t(n)) break
                        } else o[e++] = n.child1, o[e++] = n.child2
                }
            }
        }, C.prototype.RayCast = function(t, i) {
            if (null != this.m_root) {
                var o = i.p1,
                    e = i.p2,
                    n = a.SubtractVV(o, e);
                n.Normalize(), n = a.CrossFV(1, n);
                var s = a.AbsV(n),
                    r = i.maxFraction,
                    l = new h,
                    m = 0,
                    c = 0;
                m = o.x + r * (e.x - o.x), c = o.y + r * (e.y - o.y), l.lowerBound.x = Math.min(o.x, m), l.lowerBound.y = Math.min(o.y, c), l.upperBound.x = Math.max(o.x, m), l.upperBound.y = Math.max(o.y, c);
                var _ = new j,
                    p = 0;
                for (_[p++] = this.m_root; p > 0;)
                    if (0 != (r = _[--p]).aabb.TestOverlap(l) && (m = r.aabb.GetCenter(), c = r.aabb.GetExtents(), !(Math.abs(n.x * (o.x - m.x) + n.y * (o.y - m.y)) - s.x * c.x - s.y * c.y > 0)))
                        if (r.IsLeaf()) {
                            if ((m = new V).p1 = i.p1, m.p2 = i.p2, m.maxFraction = i.maxFraction, 0 == (r = t(m, r))) break;
                            r > 0 && (m = o.x + r * (e.x - o.x), c = o.y + r * (e.y - o.y), l.lowerBound.x = Math.min(o.x, m), l.lowerBound.y = Math.min(o.y, c), l.upperBound.x = Math.max(o.x, m), l.upperBound.y = Math.max(o.y, c))
                        } else _[p++] = r.child1, _[p++] = r.child2
            }
        }, C.prototype.AllocateNode = function() {
            if (this.m_freeList) {
                var t = this.m_freeList;
                return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t
            }
            return new A
        }, C.prototype.FreeNode = function(t) {
            t.parent = this.m_freeList, this.m_freeList = t
        }, C.prototype.InsertLeaf = function(t) {
            if (++this.m_insertionCount, null == this.m_root) this.m_root = t, this.m_root.parent = null;
            else {
                var i = t.aabb.GetCenter(),
                    o = this.m_root;
                if (0 == o.IsLeaf())
                    do {
                        var e = o.child1;
                        o = o.child2, o = Math.abs((e.aabb.lowerBound.x + e.aabb.upperBound.x) / 2 - i.x) + Math.abs((e.aabb.lowerBound.y + e.aabb.upperBound.y) / 2 - i.y) < Math.abs((o.aabb.lowerBound.x + o.aabb.upperBound.x) / 2 - i.x) + Math.abs((o.aabb.lowerBound.y + o.aabb.upperBound.y) / 2 - i.y) ? e : o
                    } while (0 == o.IsLeaf());
                if (i = o.parent, (e = this.AllocateNode()).parent = i, e.userData = null, e.aabb.Combine(t.aabb, o.aabb), i) {
                    o.parent.child1 == o ? i.child1 = e : i.child2 = e, e.child1 = o, e.child2 = t, o.parent = e, t.parent = e;
                    do {
                        if (i.aabb.Contains(e.aabb)) break;
                        i.aabb.Combine(i.child1.aabb, i.child2.aabb), e = i, i = i.parent
                    } while (i)
                } else e.child1 = o, e.child2 = t, o.parent = e, this.m_root = t.parent = e
            }
        }, C.prototype.RemoveLeaf = function(t) {
            if (t == this.m_root) this.m_root = null;
            else {
                var i = t.parent,
                    o = i.parent;
                if (t = i.child1 == t ? i.child2 : i.child1, o)
                    for (o.child1 == i ? o.child1 = t : o.child2 = t, t.parent = o, this.FreeNode(i); o && (i = o.aabb, o.aabb = h.Combine(o.child1.aabb, o.child2.aabb), !i.Contains(o.aabb));) o = o.parent;
                else this.m_root = t, t.parent = null, this.FreeNode(i)
            }
        }, w.b2DynamicTreeBroadPhase = function() {
            this.m_tree = new C, this.m_moveBuffer = new j, this.m_pairBuffer = new j, this.m_pairCount = 0
        }, w.prototype.CreateProxy = function(t, i) {
            var o = this.m_tree.CreateProxy(t, i);
            return ++this.m_proxyCount, this.BufferMove(o), o
        }, w.prototype.DestroyProxy = function(t) {
            this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t)
        }, w.prototype.MoveProxy = function(t, i, o) {
            this.m_tree.MoveProxy(t, i, o) && this.BufferMove(t)
        }, w.prototype.TestOverlap = function(t, i) {
            var o = this.m_tree.GetFatAABB(t),
                e = this.m_tree.GetFatAABB(i);
            return o.TestOverlap(e)
        }, w.prototype.GetUserData = function(t) {
            return this.m_tree.GetUserData(t)
        }, w.prototype.GetFatAABB = function(t) {
            return this.m_tree.GetFatAABB(t)
        }, w.prototype.GetProxyCount = function() {
            return this.m_proxyCount
        }, w.prototype.UpdatePairs = function(t) {
            var i, o = this,
                e = o.m_pairCount = 0;
            for (e = 0; e < o.m_moveBuffer.length; ++e) {
                i = o.m_moveBuffer[e];
                var n = o.m_tree.GetFatAABB(i);
                o.m_tree.Query(function(t) {
                    if (t == i) return !0;
                    o.m_pairCount == o.m_pairBuffer.length && (o.m_pairBuffer[o.m_pairCount] = new g);
                    var e = o.m_pairBuffer[o.m_pairCount];
                    return e.proxyA = t < i ? t : i, e.proxyB = t >= i ? t : i, ++o.m_pairCount, !0
                }, n)
            }
            for (e = o.m_moveBuffer.length = 0; e < o.m_pairCount;) {
                n = o.m_pairBuffer[e];
                var s = o.m_tree.GetUserData(n.proxyA);
                for (t(s, o.m_tree.GetUserData(n.proxyB)), ++e; e < o.m_pairCount && (s = o.m_pairBuffer[e]).proxyA == n.proxyA && s.proxyB == n.proxyB;) ++e
            }
        }, w.prototype.Query = function(t, i) {
            this.m_tree.Query(t, i)
        }, w.prototype.RayCast = function(t, i) {
            this.m_tree.RayCast(t, i)
        }, w.prototype.Validate = function() {}, w.prototype.Rebalance = function(t) {
            void 0 === t && (t = 0), this.m_tree.Rebalance(t)
        }, w.prototype.BufferMove = function(t) {
            this.m_moveBuffer[this.m_moveBuffer.length] = t
        }, w.prototype.UnBufferMove = function(t) {
            this.m_moveBuffer.splice(parseInt(this.m_moveBuffer.indexOf(t)), 1)
        }, w.prototype.ComparePairs = function() {
            return 0
        }, w.__implements = {}, w.__implements[E] = !0, A.b2DynamicTreeNode = function() {
            this.aabb = new h
        }, A.prototype.IsLeaf = function() {
            return null == this.child1
        }, g.b2DynamicTreePair = function() {}, S.b2Manifold = function() {
            this.m_pointCount = 0
        }, S.prototype.b2Manifold = function() {
            this.m_points = new j(r.b2_maxManifoldPoints);
            for (var t = 0; t < r.b2_maxManifoldPoints; t++) this.m_points[t] = new B;
            this.m_localPlaneNormal = new c, this.m_localPoint = new c
        }, S.prototype.Reset = function() {
            for (var t = 0; t < r.b2_maxManifoldPoints; t++)(this.m_points[t] instanceof B ? this.m_points[t] : null).Reset();
            this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_pointCount = this.m_type = 0
        }, S.prototype.Set = function(t) {
            this.m_pointCount = t.m_pointCount;
            for (var i = 0; i < r.b2_maxManifoldPoints; i++)(this.m_points[i] instanceof B ? this.m_points[i] : null).Set(t.m_points[i]);
            this.m_localPlaneNormal.SetV(t.m_localPlaneNormal), this.m_localPoint.SetV(t.m_localPoint), this.m_type = t.m_type
        }, S.prototype.Copy = function() {
            var t = new S;
            return t.Set(this), t
        }, o.postDefs.push(function() {
            o.Collision.b2Manifold.e_circles = 1, o.Collision.b2Manifold.e_faceA = 2, o.Collision.b2Manifold.e_faceB = 4
        }), B.b2ManifoldPoint = function() {
            this.m_localPoint = new c, this.m_id = new u
        }, B.prototype.b2ManifoldPoint = function() {
            this.Reset()
        }, B.prototype.Reset = function() {
            this.m_localPoint.SetZero(), this.m_tangentImpulse = this.m_normalImpulse = 0, this.m_id.key = 0
        }, B.prototype.Set = function(t) {
            this.m_localPoint.SetV(t.m_localPoint), this.m_normalImpulse = t.m_normalImpulse, this.m_tangentImpulse = t.m_tangentImpulse, this.m_id.Set(t.m_id)
        }, M.b2Point = function() {
            this.p = new c
        }, M.prototype.Support = function() {
            return this.p
        }, M.prototype.GetFirstVertex = function() {
            return this.p
        }, V.b2RayCastInput = function() {
            this.p1 = new c, this.p2 = new c
        }, V.prototype.b2RayCastInput = function(t, i, o) {
            void 0 === t && (t = null), void 0 === i && (i = null), void 0 === o && (o = 1), t && this.p1.SetV(t), i && this.p2.SetV(i), this.maxFraction = o
        }, D.b2RayCastOutput = function() {
            this.normal = new c
        }, I.b2Segment = function() {
            this.p1 = new c, this.p2 = new c
        }, I.prototype.TestSegment = function(t, i, o, e) {
            void 0 === e && (e = 0);
            var n = o.p1,
                s = o.p2.x - n.x,
                r = o.p2.y - n.y;
            o = this.p2.y - this.p1.y;
            var a = -(this.p2.x - this.p1.x),
                l = 100 * Number.MIN_VALUE,
                m = -(s * o + r * a);
            if (m > l) {
                var c = n.x - this.p1.x,
                    h = n.y - this.p1.y;
                if (0 <= (n = c * o + h * a) && n <= e * m && -l * m <= (e = -s * h + r * c) && e <= m * (1 + l)) return n /= m, o /= e = Math.sqrt(o * o + a * a), a /= e, t[0] = n, i.Set(o, a), !0
            }
            return !1
        }, I.prototype.Extend = function(t) {
            this.ExtendForward(t), this.ExtendBackward(t)
        }, I.prototype.ExtendForward = function(t) {
            var i = this.p2.x - this.p1.x,
                o = this.p2.y - this.p1.y;
            t = Math.min(i > 0 ? (t.upperBound.x - this.p1.x) / i : i < 0 ? (t.lowerBound.x - this.p1.x) / i : Number.POSITIVE_INFINITY, o > 0 ? (t.upperBound.y - this.p1.y) / o : o < 0 ? (t.lowerBound.y - this.p1.y) / o : Number.POSITIVE_INFINITY), this.p2.x = this.p1.x + i * t, this.p2.y = this.p1.y + o * t
        }, I.prototype.ExtendBackward = function(t) {
            var i = -this.p2.x + this.p1.x,
                o = -this.p2.y + this.p1.y;
            t = Math.min(i > 0 ? (t.upperBound.x - this.p2.x) / i : i < 0 ? (t.lowerBound.x - this.p2.x) / i : Number.POSITIVE_INFINITY, o > 0 ? (t.upperBound.y - this.p2.y) / o : o < 0 ? (t.lowerBound.y - this.p2.y) / o : Number.POSITIVE_INFINITY), this.p1.x = this.p2.x + i * t, this.p1.y = this.p2.y + o * t
        }, G.b2SeparationFunction = function() {
            this.m_localPoint = new c, this.m_axis = new c
        }, G.prototype.Initialize = function(t, i, o, e, n) {
            this.m_proxyA = i, this.m_proxyB = e;
            var s = parseInt(t.count);
            r.b2Assert(0 < s && s < 3);
            var l, m, h, _, p = _ = h = e = i = 0,
                y = 0;
            p = 0, 1 == s ? (this.m_type = G.e_points, l = this.m_proxyA.GetVertex(t.indexA[0]), m = this.m_proxyB.GetVertex(t.indexB[0]), s = l, t = o.R, i = o.position.x + (t.col1.x * s.x + t.col2.x * s.y), e = o.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = m, t = n.R, h = n.position.x + (t.col1.x * s.x + t.col2.x * s.y), _ = n.position.y + (t.col1.y * s.x + t.col2.y * s.y), this.m_axis.x = h - i, this.m_axis.y = _ - e, this.m_axis.Normalize()) : (t.indexB[0] == t.indexB[1] ? (this.m_type = G.e_faceA, i = this.m_proxyA.GetVertex(t.indexA[0]), e = this.m_proxyA.GetVertex(t.indexA[1]), m = this.m_proxyB.GetVertex(t.indexB[0]), this.m_localPoint.x = .5 * (i.x + e.x), this.m_localPoint.y = .5 * (i.y + e.y), this.m_axis = a.CrossVF(a.SubtractVV(e, i), 1), this.m_axis.Normalize(), s = this.m_axis, p = (t = o.R).col1.x * s.x + t.col2.x * s.y, y = t.col1.y * s.x + t.col2.y * s.y, s = this.m_localPoint, t = o.R, i = o.position.x + (t.col1.x * s.x + t.col2.x * s.y), e = o.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = m, t = n.R, p = ((h = n.position.x + (t.col1.x * s.x + t.col2.x * s.y)) - i) * p + ((_ = n.position.y + (t.col1.y * s.x + t.col2.y * s.y)) - e) * y) : t.indexA[0] == t.indexA[0] ? (this.m_type = G.e_faceB, h = this.m_proxyB.GetVertex(t.indexB[0]), _ = this.m_proxyB.GetVertex(t.indexB[1]), l = this.m_proxyA.GetVertex(t.indexA[0]), this.m_localPoint.x = .5 * (h.x + _.x), this.m_localPoint.y = .5 * (h.y + _.y), this.m_axis = a.CrossVF(a.SubtractVV(_, h), 1), this.m_axis.Normalize(), s = this.m_axis, p = (t = n.R).col1.x * s.x + t.col2.x * s.y, y = t.col1.y * s.x + t.col2.y * s.y, s = this.m_localPoint, t = n.R, h = n.position.x + (t.col1.x * s.x + t.col2.x * s.y), _ = n.position.y + (t.col1.y * s.x + t.col2.y * s.y), s = l, t = o.R, p = ((i = o.position.x + (t.col1.x * s.x + t.col2.x * s.y)) - h) * p + ((e = o.position.y + (t.col1.y * s.x + t.col2.y * s.y)) - _) * y) : (i = this.m_proxyA.GetVertex(t.indexA[0]), e = this.m_proxyA.GetVertex(t.indexA[1]), h = this.m_proxyB.GetVertex(t.indexB[0]), _ = this.m_proxyB.GetVertex(t.indexB[1]), a.MulX(o, l), l = a.MulMV(o.R, a.SubtractVV(e, i)), a.MulX(n, m), p = a.MulMV(n.R, a.SubtractVV(_, h)), n = l.x * l.x + l.y * l.y, m = p.x * p.x + p.y * p.y, t = a.SubtractVV(p, l), o = l.x * t.x + l.y * t.y, t = p.x * t.x + p.y * t.y, l = l.x * p.x + l.y * p.y, p = 0, 0 != (y = n * m - l * l) && (p = a.Clamp((l * t - o * m) / y, 0, 1)), (l * p + t) / m < 0 && (p = a.Clamp((l - o) / n, 0, 1)), (l = new c).x = i.x + p * (e.x - i.x), l.y = i.y + p * (e.y - i.y), (m = new c).x = h.x + p * (_.x - h.x), m.y = h.y + p * (_.y - h.y), 0 == p || 1 == p ? (this.m_type = G.e_faceB, this.m_axis = a.CrossVF(a.SubtractVV(_, h), 1), this.m_axis.Normalize(), this.m_localPoint = m) : (this.m_type = G.e_faceA, this.m_axis = a.CrossVF(a.SubtractVV(e, i), 1), this.m_localPoint = l)), p < 0 && this.m_axis.NegativeSelf())
        }, G.prototype.Evaluate = function(t, i) {
            var o, e, n = 0;
            switch (this.m_type) {
                case G.e_points:
                    return o = a.MulTMV(t.R, this.m_axis), e = a.MulTMV(i.R, this.m_axis.GetNegative()), o = this.m_proxyA.GetSupportVertex(o), e = this.m_proxyB.GetSupportVertex(e), o = a.MulX(t, o), ((e = a.MulX(i, e)).x - o.x) * this.m_axis.x + (e.y - o.y) * this.m_axis.y;
                case G.e_faceA:
                    return n = a.MulMV(t.R, this.m_axis), o = a.MulX(t, this.m_localPoint), e = a.MulTMV(i.R, n.GetNegative()), e = this.m_proxyB.GetSupportVertex(e), ((e = a.MulX(i, e)).x - o.x) * n.x + (e.y - o.y) * n.y;
                case G.e_faceB:
                    return n = a.MulMV(i.R, this.m_axis), e = a.MulX(i, this.m_localPoint), o = a.MulTMV(t.R, n.GetNegative()), o = this.m_proxyA.GetSupportVertex(o), ((o = a.MulX(t, o)).x - e.x) * n.x + (o.y - e.y) * n.y;
                default:
                    return r.b2Assert(!1), 0
            }
        }, o.postDefs.push(function() {
            o.Collision.b2SeparationFunction.e_points = 1, o.Collision.b2SeparationFunction.e_faceA = 2, o.Collision.b2SeparationFunction.e_faceB = 4
        }), L.b2Simplex = function() {
            this.m_v1 = new F, this.m_v2 = new F, this.m_v3 = new F, this.m_vertices = new j(3)
        }, L.prototype.b2Simplex = function() {
            this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3
        }, L.prototype.ReadCache = function(t, i, o, e, n) {
            var s, l;
            r.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count;
            for (var m = this.m_vertices, c = 0; c < this.m_count; c++) {
                var h = m[c];
                h.indexA = t.indexA[c], h.indexB = t.indexB[c], s = i.GetVertex(h.indexA), l = e.GetVertex(h.indexB), h.wA = a.MulX(o, s), h.wB = a.MulX(n, l), h.w = a.SubtractVV(h.wB, h.wA), h.a = 0
            }
            this.m_count > 1 && (t = t.metric, ((s = this.GetMetric()) < .5 * t || 2 * t < s || s < Number.MIN_VALUE) && (this.m_count = 0)), 0 == this.m_count && ((h = m[0]).indexA = 0, h.indexB = 0, s = i.GetVertex(0), l = e.GetVertex(0), h.wA = a.MulX(o, s), h.wB = a.MulX(n, l), h.w = a.SubtractVV(h.wB, h.wA), this.m_count = 1)
        }, L.prototype.WriteCache = function(t) {
            t.metric = this.GetMetric(), t.count = o.parseUInt(this.m_count);
            for (var i = this.m_vertices, e = 0; e < this.m_count; e++) t.indexA[e] = o.parseUInt(i[e].indexA), t.indexB[e] = o.parseUInt(i[e].indexB)
        }, L.prototype.GetSearchDirection = function() {
            switch (this.m_count) {
                case 1:
                    return this.m_v1.w.GetNegative();
                case 2:
                    var t = a.SubtractVV(this.m_v2.w, this.m_v1.w);
                    return a.CrossVV(t, this.m_v1.w.GetNegative()) > 0 ? a.CrossFV(1, t) : a.CrossVF(t, 1);
                default:
                    return r.b2Assert(!1), new c
            }
        }, L.prototype.GetClosestPoint = function() {
            switch (this.m_count) {
                case 0:
                    return r.b2Assert(!1), new c;
                case 1:
                    return this.m_v1.w;
                case 2:
                    return new c(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
                default:
                    return r.b2Assert(!1), new c
            }
        }, L.prototype.GetWitnessPoints = function(t, i) {
            switch (this.m_count) {
                case 0:
                    r.b2Assert(!1);
                    break;
                case 1:
                    t.SetV(this.m_v1.wA), i.SetV(this.m_v1.wB);
                    break;
                case 2:
                    t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, i.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, i.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                    break;
                case 3:
                    i.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, i.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                    break;
                default:
                    r.b2Assert(!1)
            }
        }, L.prototype.GetMetric = function() {
            switch (this.m_count) {
                case 0:
                    return r.b2Assert(!1), 0;
                case 1:
                    return 0;
                case 2:
                    return a.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
                case 3:
                    return a.CrossVV(a.SubtractVV(this.m_v2.w, this.m_v1.w), a.SubtractVV(this.m_v3.w, this.m_v1.w));
                default:
                    return r.b2Assert(!1), 0
            }
        }, L.prototype.Solve2 = function() {
            var t = this.m_v1.w,
                i = this.m_v2.w,
                o = a.SubtractVV(i, t);
            (t = -(t.x * o.x + t.y * o.y)) <= 0 ? this.m_count = this.m_v1.a = 1 : (i = i.x * o.x + i.y * o.y) <= 0 ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : (o = 1 / (i + t), this.m_v1.a = i * o, this.m_v2.a = t * o, this.m_count = 2)
        }, L.prototype.Solve3 = function() {
            var t = this.m_v1.w,
                i = this.m_v2.w,
                o = this.m_v3.w,
                e = a.SubtractVV(i, t),
                n = a.Dot(t, e),
                s = a.Dot(i, e);
            n = -n;
            var r = a.SubtractVV(o, t),
                l = a.Dot(t, r),
                m = a.Dot(o, r);
            l = -l;
            var c = a.SubtractVV(o, i),
                h = a.Dot(i, c);
            c = a.Dot(o, c), h = -h, e = (r = a.CrossVV(e, r)) * a.CrossVV(i, o), o = r * a.CrossVV(o, t), t = r * a.CrossVV(t, i), n <= 0 && l <= 0 ? this.m_count = this.m_v1.a = 1 : s > 0 && n > 0 && t <= 0 ? (m = 1 / (s + n), this.m_v1.a = s * m, this.m_v2.a = n * m, this.m_count = 2) : m > 0 && l > 0 && o <= 0 ? (s = 1 / (m + l), this.m_v1.a = m * s, this.m_v3.a = l * s, this.m_count = 2, this.m_v2.Set(this.m_v3)) : s <= 0 && h <= 0 ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : m <= 0 && c <= 0 ? (this.m_count = this.m_v3.a = 1, this.m_v1.Set(this.m_v3)) : c > 0 && h > 0 && e <= 0 ? (s = 1 / (c + h), this.m_v2.a = c * s, this.m_v3.a = h * s, this.m_count = 2, this.m_v1.Set(this.m_v3)) : (s = 1 / (e + o + t), this.m_v1.a = e * s, this.m_v2.a = o * s, this.m_v3.a = t * s, this.m_count = 3)
        }, J.b2SimplexCache = function() {
            this.indexA = new O(3), this.indexB = new O(3)
        }, F.b2SimplexVertex = function() {}, F.prototype.Set = function(t) {
            this.wA.SetV(t.wA), this.wB.SetV(t.wB), this.w.SetV(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB
        }, P.b2TimeOfImpact = function() {}, P.TimeOfImpact = function(t) {
            ++P.b2_toiCalls;
            var i = t.proxyA,
                o = t.proxyB,
                e = t.sweepA,
                n = t.sweepB;
            r.b2Assert(e.t0 == n.t0), r.b2Assert(1 - e.t0 > Number.MIN_VALUE);
            var s = i.m_radius + o.m_radius;
            t = t.tolerance;
            var l = 0,
                m = 0,
                c = 0;
            for (P.s_cache.count = 0, P.s_distanceInput.useRadii = !1;;) {
                if (e.GetTransform(P.s_xfA, l), n.GetTransform(P.s_xfB, l), P.s_distanceInput.proxyA = i, P.s_distanceInput.proxyB = o, P.s_distanceInput.transformA = P.s_xfA, P.s_distanceInput.transformB = P.s_xfB, f.Distance(P.s_distanceOutput, P.s_cache, P.s_distanceInput), P.s_distanceOutput.distance <= 0) {
                    l = 1;
                    break
                }
                P.s_fcn.Initialize(P.s_cache, i, P.s_xfA, o, P.s_xfB);
                var h = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
                if (h <= 0) {
                    l = 1;
                    break
                }
                if (0 == m && (c = h > s ? a.Max(s - t, .75 * s) : a.Max(h - t, .02 * s)), h - c < .5 * t) {
                    if (0 == m) {
                        l = 1;
                        break
                    }
                    break
                }
                var _ = l,
                    p = l,
                    y = 1;
                h = h, e.GetTransform(P.s_xfA, y), n.GetTransform(P.s_xfB, y);
                var u = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
                if (u >= c) {
                    l = 1;
                    break
                }
                for (var x = 0;;) {
                    var d;
                    d = 1 & x ? p + (c - h) * (y - p) / (u - h) : .5 * (p + y), e.GetTransform(P.s_xfA, d), n.GetTransform(P.s_xfB, d);
                    var b = P.s_fcn.Evaluate(P.s_xfA, P.s_xfB);
                    if (a.Abs(b - c) < .025 * t) {
                        _ = d;
                        break
                    }
                    if (b > c ? (p = d, h = b) : (y = d, u = b), ++x, ++P.b2_toiRootIters, 50 == x) break
                }
                if (P.b2_toiMaxRootIters = a.Max(P.b2_toiMaxRootIters, x), _ < (1 + 100 * Number.MIN_VALUE) * l) break;
                if (l = _, m++, ++P.b2_toiIters, 1e3 == m) break
            }
            return P.b2_toiMaxIters = a.Max(P.b2_toiMaxIters, m), l
        }, o.postDefs.push(function() {
            o.Collision.b2TimeOfImpact.b2_toiCalls = 0, o.Collision.b2TimeOfImpact.b2_toiIters = 0, o.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, o.Collision.b2TimeOfImpact.b2_toiRootIters = 0, o.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, o.Collision.b2TimeOfImpact.s_cache = new J, o.Collision.b2TimeOfImpact.s_distanceInput = new d, o.Collision.b2TimeOfImpact.s_xfA = new m, o.Collision.b2TimeOfImpact.s_xfB = new m, o.Collision.b2TimeOfImpact.s_fcn = new G, o.Collision.b2TimeOfImpact.s_distanceOutput = new b
        }), T.b2TOIInput = function() {
            this.proxyA = new v, this.proxyB = new v, this.sweepA = new l, this.sweepB = new l
        }, R.b2WorldManifold = function() {
            this.m_normal = new c
        }, R.prototype.b2WorldManifold = function() {
            this.m_points = new j(r.b2_maxManifoldPoints);
            for (var t = 0; t < r.b2_maxManifoldPoints; t++) this.m_points[t] = new c
        }, R.prototype.Initialize = function(t, i, o, e, n) {
            if (void 0 === o && (o = 0), void 0 === n && (n = 0), 0 != t.m_pointCount) {
                var s, r, a = 0,
                    l = 0,
                    m = 0,
                    c = 0,
                    h = 0,
                    _ = 0;
                switch (s = 0, t.m_type) {
                    case S.e_circles:
                        r = i.R, s = t.m_localPoint, a = i.position.x + r.col1.x * s.x + r.col2.x * s.y, i = i.position.y + r.col1.y * s.x + r.col2.y * s.y, r = e.R, s = t.m_points[0].m_localPoint, t = e.position.x + r.col1.x * s.x + r.col2.x * s.y, e = e.position.y + r.col1.y * s.x + r.col2.y * s.y, (l = (s = t - a) * s + (r = e - i) * r) > Number.MIN_VALUE * Number.MIN_VALUE ? (l = Math.sqrt(l), this.m_normal.x = s / l, this.m_normal.y = r / l) : (this.m_normal.x = 1, this.m_normal.y = 0), s = i + o * this.m_normal.y, e -= n * this.m_normal.y, this.m_points[0].x = .5 * (a + o * this.m_normal.x + (t - n * this.m_normal.x)), this.m_points[0].y = .5 * (s + e);
                        break;
                    case S.e_faceA:
                        for (r = i.R, s = t.m_localPlaneNormal, l = r.col1.x * s.x + r.col2.x * s.y, m = r.col1.y * s.x + r.col2.y * s.y, r = i.R, s = t.m_localPoint, c = i.position.x + r.col1.x * s.x + r.col2.x * s.y, h = i.position.y + r.col1.y * s.x + r.col2.y * s.y, this.m_normal.x = l, this.m_normal.y = m, a = 0; a < t.m_pointCount; a++) r = e.R, s = t.m_points[a].m_localPoint, _ = e.position.x + r.col1.x * s.x + r.col2.x * s.y, s = e.position.y + r.col1.y * s.x + r.col2.y * s.y, this.m_points[a].x = _ + .5 * (o - (_ - c) * l - (s - h) * m - n) * l, this.m_points[a].y = s + .5 * (o - (_ - c) * l - (s - h) * m - n) * m;
                        break;
                    case S.e_faceB:
                        for (r = e.R, s = t.m_localPlaneNormal, l = r.col1.x * s.x + r.col2.x * s.y, m = r.col1.y * s.x + r.col2.y * s.y, r = e.R, s = t.m_localPoint, c = e.position.x + r.col1.x * s.x + r.col2.x * s.y, h = e.position.y + r.col1.y * s.x + r.col2.y * s.y, this.m_normal.x = -l, this.m_normal.y = -m, a = 0; a < t.m_pointCount; a++) r = i.R, s = t.m_points[a].m_localPoint, _ = i.position.x + r.col1.x * s.x + r.col2.x * s.y, s = i.position.y + r.col1.y * s.x + r.col2.y * s.y, this.m_points[a].x = _ + .5 * (n - (_ - c) * l - (s - h) * m - o) * l, this.m_points[a].y = s + .5 * (n - (_ - c) * l - (s - h) * m - o) * m
                }
            }
        }, k.ClipVertex = function() {
            this.v = new c, this.id = new u
        }, k.prototype.Set = function(t) {
            this.v.SetV(t.v), this.id.Set(t.id)
        }, z.Features = function() {}, Object.defineProperty(z.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._referenceEdge
            }
        }), Object.defineProperty(z.prototype, "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._referenceEdge = t, this._m_id._key = 4294967040 & this._m_id._key | 255 & this._referenceEdge
            }
        }), Object.defineProperty(z.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentEdge
            }
        }), Object.defineProperty(z.prototype, "incidentEdge", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._incidentEdge = t, this._m_id._key = 4294902015 & this._m_id._key | this._incidentEdge << 8 & 65280
            }
        }), Object.defineProperty(z.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._incidentVertex
            }
        }), Object.defineProperty(z.prototype, "incidentVertex", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._incidentVertex = t, this._m_id._key = 4278255615 & this._m_id._key | this._incidentVertex << 16 & 16711680
            }
        }), Object.defineProperty(z.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._flip
            }
        }), Object.defineProperty(z.prototype, "flip", {
            enumerable: !1,
            configurable: !0,
            set: function(t) {
                void 0 === t && (t = 0), this._flip = t, this._m_id._key = 16777215 & this._m_id._key | this._flip << 24 & 4278190080
            }
        }), function() {
            var t = o.Common.b2Settings,
                i = o.Collision.Shapes.b2CircleShape,
                e = o.Collision.Shapes.b2EdgeChainDef,
                n = o.Collision.Shapes.b2EdgeShape,
                s = o.Collision.Shapes.b2MassData,
                r = o.Collision.Shapes.b2PolygonShape,
                a = o.Collision.Shapes.b2Shape,
                l = o.Common.Math.b2Mat22,
                m = o.Common.Math.b2Math,
                c = o.Common.Math.b2Transform,
                h = o.Common.Math.b2Vec2,
                _ = o.Collision.b2Distance,
                p = o.Collision.b2DistanceInput,
                y = o.Collision.b2DistanceOutput,
                u = o.Collision.b2DistanceProxy,
                x = o.Collision.b2SimplexCache;
            o.inherit(i, o.Collision.Shapes.b2Shape), i.prototype.__super = o.Collision.Shapes.b2Shape.prototype, i.b2CircleShape = function() {
                o.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new h
            }, i.prototype.Copy = function() {
                var t = new i;
                return t.Set(this), t
            }, i.prototype.Set = function(t) {
                this.__super.Set.call(this, t), o.is(t, i) && this.m_p.SetV((t instanceof i ? t : null).m_p)
            }, i.prototype.TestPoint = function(t, i) {
                var o = t.R,
                    e = t.position.x + (o.col1.x * this.m_p.x + o.col2.x * this.m_p.y);
                return o = t.position.y + (o.col1.y * this.m_p.x + o.col2.y * this.m_p.y), (e = i.x - e) * e + (o = i.y - o) * o <= this.m_radius * this.m_radius
            }, i.prototype.RayCast = function(t, i, o) {
                var e = o.R,
                    n = i.p1.x - (o.position.x + (e.col1.x * this.m_p.x + e.col2.x * this.m_p.y));
                o = i.p1.y - (o.position.y + (e.col1.y * this.m_p.x + e.col2.y * this.m_p.y)), e = i.p2.x - i.p1.x;
                var s = i.p2.y - i.p1.y,
                    r = n * e + o * s,
                    a = e * e + s * s,
                    l = r * r - a * (n * n + o * o - this.m_radius * this.m_radius);
                return !(l < 0 || a < Number.MIN_VALUE) && (0 <= (r = -(r + Math.sqrt(l))) && r <= i.maxFraction * a && (r /= a, t.fraction = r, t.normal.x = n + r * e, t.normal.y = o + r * s, t.normal.Normalize(), !0))
            }, i.prototype.ComputeAABB = function(t, i) {
                var o = i.R,
                    e = i.position.x + (o.col1.x * this.m_p.x + o.col2.x * this.m_p.y);
                o = i.position.y + (o.col1.y * this.m_p.x + o.col2.y * this.m_p.y), t.lowerBound.Set(e - this.m_radius, o - this.m_radius), t.upperBound.Set(e + this.m_radius, o + this.m_radius)
            }, i.prototype.ComputeMass = function(i, o) {
                void 0 === o && (o = 0), i.mass = o * t.b2_pi * this.m_radius * this.m_radius, i.center.SetV(this.m_p), i.I = i.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
            }, i.prototype.ComputeSubmergedArea = function(t, i, o, e) {
                void 0 === i && (i = 0), o = m.MulX(o, this.m_p);
                var n = -(m.Dot(t, o) - i);
                if (n < -this.m_radius + Number.MIN_VALUE) return 0;
                if (n > this.m_radius) return e.SetV(o), Math.PI * this.m_radius * this.m_radius;
                var s = n * n;
                return n = (i = this.m_radius * this.m_radius) * (Math.asin(n / this.m_radius) + Math.PI / 2) + n * Math.sqrt(i - s), i = -2 / 3 * Math.pow(i - s, 1.5) / n, e.x = o.x + t.x * i, e.y = o.y + t.y * i, n
            }, i.prototype.GetLocalPosition = function() {
                return this.m_p
            }, i.prototype.SetLocalPosition = function(t) {
                this.m_p.SetV(t)
            }, i.prototype.GetRadius = function() {
                return this.m_radius
            }, i.prototype.SetRadius = function(t) {
                void 0 === t && (t = 0), this.m_radius = t
            }, i.prototype.b2CircleShape = function(t) {
                void 0 === t && (t = 0), this.__super.b2Shape.call(this), this.m_type = a.e_circleShape, this.m_radius = t
            }, e.b2EdgeChainDef = function() {}, e.prototype.b2EdgeChainDef = function() {
                this.vertexCount = 0, this.isALoop = !0, this.vertices = []
            }, o.inherit(n, o.Collision.Shapes.b2Shape), n.prototype.__super = o.Collision.Shapes.b2Shape.prototype, n.b2EdgeShape = function() {
                o.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new h, this.m_v1 = new h, this.m_v2 = new h, this.m_coreV1 = new h, this.m_coreV2 = new h, this.m_normal = new h, this.m_direction = new h, this.m_cornerDir1 = new h, this.m_cornerDir2 = new h
            }, n.prototype.TestPoint = function() {
                return !1
            }, n.prototype.RayCast = function(t, i, o) {
                var e, n = i.p2.x - i.p1.x,
                    s = i.p2.y - i.p1.y;
                e = o.R;
                var r = o.position.x + (e.col1.x * this.m_v1.x + e.col2.x * this.m_v1.y),
                    a = o.position.y + (e.col1.y * this.m_v1.x + e.col2.y * this.m_v1.y),
                    l = o.position.y + (e.col1.y * this.m_v2.x + e.col2.y * this.m_v2.y) - a,
                    m = -(n * l + s * (o = -(o.position.x + (e.col1.x * this.m_v2.x + e.col2.x * this.m_v2.y) - r)));
                if (m > (e = 100 * Number.MIN_VALUE)) {
                    r = i.p1.x - r;
                    var c = i.p1.y - a;
                    if (0 <= (a = r * l + c * o) && a <= i.maxFraction * m && -e * m <= (i = -n * c + s * r) && i <= m * (1 + e)) return a /= m, t.fraction = a, i = Math.sqrt(l * l + o * o), t.normal.x = l / i, t.normal.y = o / i, !0
                }
                return !1
            }, n.prototype.ComputeAABB = function(t, i) {
                var o = i.R,
                    e = i.position.x + (o.col1.x * this.m_v1.x + o.col2.x * this.m_v1.y),
                    n = i.position.y + (o.col1.y * this.m_v1.x + o.col2.y * this.m_v1.y),
                    s = i.position.x + (o.col1.x * this.m_v2.x + o.col2.x * this.m_v2.y);
                o = i.position.y + (o.col1.y * this.m_v2.x + o.col2.y * this.m_v2.y), e < s ? (t.lowerBound.x = e, t.upperBound.x = s) : (t.lowerBound.x = s, t.upperBound.x = e), n < o ? (t.lowerBound.y = n, t.upperBound.y = o) : (t.lowerBound.y = o, t.upperBound.y = n)
            }, n.prototype.ComputeMass = function(t) {
                t.mass = 0, t.center.SetV(this.m_v1), t.I = 0
            }, n.prototype.ComputeSubmergedArea = function(t, i, o, e) {
                void 0 === i && (i = 0);
                var n = new h(t.x * i, t.y * i),
                    s = m.MulX(o, this.m_v1);
                o = m.MulX(o, this.m_v2);
                var r = m.Dot(t, s) - i;
                if (t = m.Dot(t, o) - i, r > 0) {
                    if (t > 0) return 0;
                    s.x = -t / (r - t) * s.x + r / (r - t) * o.x, s.y = -t / (r - t) * s.y + r / (r - t) * o.y
                } else t > 0 && (o.x = -t / (r - t) * s.x + r / (r - t) * o.x, o.y = -t / (r - t) * s.y + r / (r - t) * o.y);
                return e.x = (n.x + s.x + o.x) / 3, e.y = (n.y + s.y + o.y) / 3, .5 * ((s.x - n.x) * (o.y - n.y) - (s.y - n.y) * (o.x - n.x))
            }, n.prototype.GetLength = function() {
                return this.m_length
            }, n.prototype.GetVertex1 = function() {
                return this.m_v1
            }, n.prototype.GetVertex2 = function() {
                return this.m_v2
            }, n.prototype.GetCoreVertex1 = function() {
                return this.m_coreV1
            }, n.prototype.GetCoreVertex2 = function() {
                return this.m_coreV2
            }, n.prototype.GetNormalVector = function() {
                return this.m_normal
            }, n.prototype.GetDirectionVector = function() {
                return this.m_direction
            }, n.prototype.GetCorner1Vector = function() {
                return this.m_cornerDir1
            }, n.prototype.GetCorner2Vector = function() {
                return this.m_cornerDir2
            }, n.prototype.Corner1IsConvex = function() {
                return this.m_cornerConvex1
            }, n.prototype.Corner2IsConvex = function() {
                return this.m_cornerConvex2
            }, n.prototype.GetFirstVertex = function(t) {
                var i = t.R;
                return new h(t.position.x + (i.col1.x * this.m_coreV1.x + i.col2.x * this.m_coreV1.y), t.position.y + (i.col1.y * this.m_coreV1.x + i.col2.y * this.m_coreV1.y))
            }, n.prototype.GetNextEdge = function() {
                return this.m_nextEdge
            }, n.prototype.GetPrevEdge = function() {
                return this.m_prevEdge
            }, n.prototype.Support = function(t, i, o) {
                void 0 === i && (i = 0), void 0 === o && (o = 0);
                var e = t.R,
                    n = t.position.x + (e.col1.x * this.m_coreV1.x + e.col2.x * this.m_coreV1.y),
                    s = t.position.y + (e.col1.y * this.m_coreV1.x + e.col2.y * this.m_coreV1.y),
                    r = t.position.x + (e.col1.x * this.m_coreV2.x + e.col2.x * this.m_coreV2.y);
                return n * i + s * o > r * i + (t = t.position.y + (e.col1.y * this.m_coreV2.x + e.col2.y * this.m_coreV2.y)) * o ? (this.s_supportVec.x = n, this.s_supportVec.y = s) : (this.s_supportVec.x = r, this.s_supportVec.y = t), this.s_supportVec
            }, n.prototype.b2EdgeShape = function(i, o) {
                this.__super.b2Shape.call(this), this.m_type = a.e_edgeShape, this.m_nextEdge = this.m_prevEdge = null, this.m_v1 = i, this.m_v2 = o, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = this.m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-t.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -t.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-t.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -t.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = this.m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
            }, n.prototype.SetPrevEdge = function(t, i, o, e) {
                this.m_prevEdge = t, this.m_coreV1 = i, this.m_cornerDir1 = o, this.m_cornerConvex1 = e
            }, n.prototype.SetNextEdge = function(t, i, o, e) {
                this.m_nextEdge = t, this.m_coreV2 = i, this.m_cornerDir2 = o, this.m_cornerConvex2 = e
            }, s.b2MassData = function() {
                this.mass = 0, this.center = new h(0, 0), this.I = 0
            }, o.inherit(r, o.Collision.Shapes.b2Shape), r.prototype.__super = o.Collision.Shapes.b2Shape.prototype, r.b2PolygonShape = function() {
                o.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
            }, r.prototype.Copy = function() {
                var t = new r;
                return t.Set(this), t
            }, r.prototype.Set = function(t) {
                if (this.__super.Set.call(this, t), o.is(t, r)) {
                    t = t instanceof r ? t : null, this.m_centroid.SetV(t.m_centroid), this.m_vertexCount = t.m_vertexCount, this.Reserve(this.m_vertexCount);
                    for (var i = 0; i < this.m_vertexCount; i++) this.m_vertices[i].SetV(t.m_vertices[i]), this.m_normals[i].SetV(t.m_normals[i])
                }
            }, r.prototype.SetAsArray = function(t, i) {
                void 0 === i && (i = 0);
                var o, e = new j,
                    n = 0;
                for (n = 0; n < t.length; ++n) o = t[n], e.push(o);
                this.SetAsVector(e, i)
            }, r.AsArray = function(t, i) {
                void 0 === i && (i = 0);
                var o = new r;
                return o.SetAsArray(t, i), o
            }, r.prototype.SetAsVector = function(i, o) {
                void 0 === o && (o = 0), 0 == o && (o = i.length), t.b2Assert(2 <= o), this.m_vertexCount = o, this.Reserve(o);
                var e = 0;
                for (e = 0; e < this.m_vertexCount; e++) this.m_vertices[e].SetV(i[e]);
                for (e = 0; e < this.m_vertexCount; ++e) {
                    var n = parseInt(e),
                        s = parseInt(e + 1 < this.m_vertexCount ? e + 1 : 0);
                    n = m.SubtractVV(this.m_vertices[s], this.m_vertices[n]), t.b2Assert(n.LengthSquared() > Number.MIN_VALUE), this.m_normals[e].SetV(m.CrossVF(n, 1)), this.m_normals[e].Normalize()
                }
                this.m_centroid = r.ComputeCentroid(this.m_vertices, this.m_vertexCount)
            }, r.AsVector = function(t, i) {
                void 0 === i && (i = 0);
                var o = new r;
                return o.SetAsVector(t, i), o
            }, r.prototype.SetAsBox = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -i), this.m_vertices[1].Set(t, -i), this.m_vertices[2].Set(t, i), this.m_vertices[3].Set(-t, i), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero()
            }, r.AsBox = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0);
                var o = new r;
                return o.SetAsBox(t, i), o
            }, r.prototype.SetAsOrientedBox = function(t, i, o, e) {
                for (void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = null), void 0 === e && (e = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-t, -i), this.m_vertices[1].Set(t, -i), this.m_vertices[2].Set(t, i), this.m_vertices[3].Set(-t, i), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = o, (t = new c).position = o, t.R.Set(e), o = 0; o < this.m_vertexCount; ++o) this.m_vertices[o] = m.MulX(t, this.m_vertices[o]), this.m_normals[o] = m.MulMV(t.R, this.m_normals[o])
            }, r.AsOrientedBox = function(t, i, o, e) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = null), void 0 === e && (e = 0);
                var n = new r;
                return n.SetAsOrientedBox(t, i, o, e), n
            }, r.prototype.SetAsEdge = function(t, i) {
                this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(t), this.m_vertices[1].SetV(i), this.m_centroid.x = .5 * (t.x + i.x), this.m_centroid.y = .5 * (t.y + i.y), this.m_normals[0] = m.CrossVF(m.SubtractVV(i, t), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y
            }, r.AsEdge = function(t, i) {
                var o = new r;
                return o.SetAsEdge(t, i), o
            }, r.prototype.TestPoint = function(t, i) {
                var o;
                o = t.R;
                for (var e = i.x - t.position.x, n = i.y - t.position.y, s = e * o.col1.x + n * o.col1.y, r = e * o.col2.x + n * o.col2.y, a = 0; a < this.m_vertexCount; ++a)
                    if (e = s - (o = this.m_vertices[a]).x, n = r - o.y, (o = this.m_normals[a]).x * e + o.y * n > 0) return !1;
                return !0
            }, r.prototype.RayCast = function(t, i, o) {
                var e, n, s = 0,
                    r = i.maxFraction,
                    a = 0,
                    l = 0;
                a = i.p1.x - o.position.x, l = i.p1.y - o.position.y;
                var m = a * (e = o.R).col1.x + l * e.col1.y,
                    c = a * e.col2.x + l * e.col2.y;
                a = i.p2.x - o.position.x, l = i.p2.y - o.position.y, i = a * (e = o.R).col1.x + l * e.col1.y - m, e = a * e.col2.x + l * e.col2.y - c;
                for (var h = parseInt(-1), _ = 0; _ < this.m_vertexCount; ++_) {
                    if (a = (n = this.m_vertices[_]).x - m, l = n.y - c, a = (n = this.m_normals[_]).x * a + n.y * l, 0 == (l = n.x * i + n.y * e)) {
                        if (a < 0) return !1
                    } else l < 0 && a < s * l ? (s = a / l, h = _) : l > 0 && a < r * l && (r = a / l);
                    if (r < s - Number.MIN_VALUE) return !1
                }
                return h >= 0 && (t.fraction = s, e = o.R, n = this.m_normals[h], t.normal.x = e.col1.x * n.x + e.col2.x * n.y, t.normal.y = e.col1.y * n.x + e.col2.y * n.y, !0)
            }, r.prototype.ComputeAABB = function(t, i) {
                for (var o = i.R, e = this.m_vertices[0], n = i.position.x + (o.col1.x * e.x + o.col2.x * e.y), s = i.position.y + (o.col1.y * e.x + o.col2.y * e.y), r = n, a = s, l = 1; l < this.m_vertexCount; ++l) {
                    e = this.m_vertices[l];
                    var m = i.position.x + (o.col1.x * e.x + o.col2.x * e.y);
                    n = n < m ? n : m, s = s < (e = i.position.y + (o.col1.y * e.x + o.col2.y * e.y)) ? s : e, r = r > m ? r : m, a = a > e ? a : e
                }
                t.lowerBound.x = n - this.m_radius, t.lowerBound.y = s - this.m_radius, t.upperBound.x = r + this.m_radius, t.upperBound.y = a + this.m_radius
            }, r.prototype.ComputeMass = function(t, i) {
                if (void 0 === i && (i = 0), 2 == this.m_vertexCount) t.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), t.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), t.mass = 0, t.I = 0;
                else {
                    for (var o = 0, e = 0, n = 0, s = 0, r = 1 / 3, a = 0; a < this.m_vertexCount; ++a) {
                        var l = this.m_vertices[a],
                            m = a + 1 < this.m_vertexCount ? this.m_vertices[parseInt(a + 1)] : this.m_vertices[0],
                            c = l.x - 0,
                            h = l.y - 0,
                            _ = m.x - 0,
                            p = m.y - 0,
                            y = c * p - h * _,
                            u = .5 * y;
                        n += u, o += u * r * (0 + l.x + m.x), e += u * r * (0 + l.y + m.y), s += y * (r * (.25 * ((l = c) * l + (_ = _) * l + _ * _) + (0 * l + 0 * _)) + 0 + (r * (.25 * ((h = h) * h + (p = p) * h + p * p) + (0 * h + 0 * p)) + 0))
                    }
                    t.mass = i * n, o *= 1 / n, e *= 1 / n, t.center.Set(o, e), t.I = i * s
                }
            }, r.prototype.ComputeSubmergedArea = function(t, i, o, e) {
                void 0 === i && (i = 0);
                var n = m.MulTMV(o.R, t),
                    r = i - m.Dot(t, o.position),
                    a = new O,
                    l = 0,
                    c = parseInt(-1);
                i = parseInt(-1);
                var _ = !1;
                for (t = t = 0; t < this.m_vertexCount; ++t) {
                    a[t] = m.Dot(n, this.m_vertices[t]) - r;
                    var p = a[t] < -Number.MIN_VALUE;
                    t > 0 && (p ? _ || (c = t - 1, l++) : _ && (i = t - 1, l++)), _ = p
                }
                switch (l) {
                    case 0:
                        return _ ? (t = new s, this.ComputeMass(t, 1), e.SetV(m.MulX(o, t.center)), t.mass) : 0;
                    case 1:
                        -1 == c ? c = this.m_vertexCount - 1 : i = this.m_vertexCount - 1
                }
                for (t = parseInt((c + 1) % this.m_vertexCount), n = parseInt((i + 1) % this.m_vertexCount), r = (0 - a[c]) / (a[t] - a[c]), a = (0 - a[i]) / (a[n] - a[i]), c = new h(this.m_vertices[c].x * (1 - r) + this.m_vertices[t].x * r, this.m_vertices[c].y * (1 - r) + this.m_vertices[t].y * r), i = new h(this.m_vertices[i].x * (1 - a) + this.m_vertices[n].x * a, this.m_vertices[i].y * (1 - a) + this.m_vertices[n].y * a), a = 0, r = new h, l = this.m_vertices[t], t = t; t != n;) _ = (t = (t + 1) % this.m_vertexCount) == n ? i : this.m_vertices[t], a += p = .5 * ((l.x - c.x) * (_.y - c.y) - (l.y - c.y) * (_.x - c.x)), r.x += p * (c.x + l.x + _.x) / 3, r.y += p * (c.y + l.y + _.y) / 3, l = _;
                return r.Multiply(1 / a), e.SetV(m.MulX(o, r)), a
            }, r.prototype.GetVertexCount = function() {
                return this.m_vertexCount
            }, r.prototype.GetVertices = function() {
                return this.m_vertices
            }, r.prototype.GetNormals = function() {
                return this.m_normals
            }, r.prototype.GetSupport = function(t) {
                for (var i = 0, o = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, e = 1; e < this.m_vertexCount; ++e) {
                    var n = this.m_vertices[e].x * t.x + this.m_vertices[e].y * t.y;
                    n > o && (i = e, o = n)
                }
                return i
            }, r.prototype.GetSupportVertex = function(t) {
                for (var i = 0, o = this.m_vertices[0].x * t.x + this.m_vertices[0].y * t.y, e = 1; e < this.m_vertexCount; ++e) {
                    var n = this.m_vertices[e].x * t.x + this.m_vertices[e].y * t.y;
                    n > o && (i = e, o = n)
                }
                return this.m_vertices[i]
            }, r.prototype.Validate = function() {
                return !1
            }, r.prototype.b2PolygonShape = function() {
                this.__super.b2Shape.call(this), this.m_type = a.e_polygonShape, this.m_centroid = new h, this.m_vertices = new j, this.m_normals = new j
            }, r.prototype.Reserve = function(t) {
                void 0 === t && (t = 0);
                for (var i = parseInt(this.m_vertices.length); i < t; i++) this.m_vertices[i] = new h, this.m_normals[i] = new h
            }, r.ComputeCentroid = function(t, i) {
                void 0 === i && (i = 0);
                for (var o = new h, e = 0, n = 0; n < i; ++n) {
                    var s = t[n],
                        r = n + 1 < i ? t[parseInt(n + 1)] : t[0],
                        a = .5 * ((s.x - 0) * (r.y - 0) - (s.y - 0) * (r.x - 0));
                    e += a, o.x += a * (1 / 3) * (0 + s.x + r.x), o.y += a * (1 / 3) * (0 + s.y + r.y)
                }
                return o.x *= 1 / e, o.y *= 1 / e, o
            }, r.ComputeOBB = function(t, i, o) {
                void 0 === o && (o = 0);
                var e = 0,
                    n = new j(o + 1);
                for (e = 0; e < o; ++e) n[e] = i[e];
                for (n[o] = n[0], i = Number.MAX_VALUE, e = 1; e <= o; ++e) {
                    for (var s = n[parseInt(e - 1)], r = n[e].x - s.x, a = n[e].y - s.y, l = Math.sqrt(r * r + a * a), m = -(a /= l), c = r /= l, h = l = Number.MAX_VALUE, _ = -Number.MAX_VALUE, p = -Number.MAX_VALUE, y = 0; y < o; ++y) {
                        var u = n[y].x - s.x,
                            x = n[y].y - s.y,
                            f = r * u + a * x;
                        f < l && (l = f), (u = m * u + c * x) < h && (h = u), f > _ && (_ = f), u > p && (p = u)
                    }(y = (_ - l) * (p - h)) < .95 * i && (i = y, t.R.col1.x = r, t.R.col1.y = a, t.R.col2.x = m, t.R.col2.y = c, r = .5 * (l + _), a = .5 * (h + p), m = t.R, t.center.x = s.x + (m.col1.x * r + m.col2.x * a), t.center.y = s.y + (m.col1.y * r + m.col2.y * a), t.extents.x = .5 * (_ - l), t.extents.y = .5 * (p - h))
                }
            }, o.postDefs.push(function() {
                o.Collision.Shapes.b2PolygonShape.s_mat = new l
            }), a.b2Shape = function() {}, a.prototype.Copy = function() {
                return null
            }, a.prototype.Set = function(t) {
                this.m_radius = t.m_radius
            }, a.prototype.GetType = function() {
                return this.m_type
            }, a.prototype.TestPoint = function() {
                return !1
            }, a.prototype.RayCast = function() {
                return !1
            }, a.prototype.ComputeAABB = function() {}, a.prototype.ComputeMass = function() {}, a.prototype.ComputeSubmergedArea = function() {
                return 0
            }, a.TestOverlap = function(t, i, o, e) {
                var n = new p;
                return n.proxyA = new u, n.proxyA.Set(t), n.proxyB = new u, n.proxyB.Set(o), n.transformA = i, n.transformB = e, n.useRadii = !0, (t = new x).count = 0, i = new y, _.Distance(i, t, n), i.distance < 10 * Number.MIN_VALUE
            }, a.prototype.b2Shape = function() {
                this.m_type = a.e_unknownShape, this.m_radius = t.b2_linearSlop
            }, o.postDefs.push(function() {
                o.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), o.Collision.Shapes.b2Shape.e_circleShape = 0, o.Collision.Shapes.b2Shape.e_polygonShape = 1, o.Collision.Shapes.b2Shape.e_edgeShape = 2, o.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, o.Collision.Shapes.b2Shape.e_hitCollide = 1, o.Collision.Shapes.b2Shape.e_missCollide = 0, o.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1)
            })
        }(), function() {
            var t = o.Common.b2Color,
                i = o.Common.b2Settings,
                e = o.Common.Math.b2Math;
            t.b2Color = function() {
                this._b = this._g = this._r = 0
            }, t.prototype.b2Color = function(t, i, n) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this._r = o.parseUInt(255 * e.Clamp(t, 0, 1)), this._g = o.parseUInt(255 * e.Clamp(i, 0, 1)), this._b = o.parseUInt(255 * e.Clamp(n, 0, 1))
            }, t.prototype.Set = function(t, i, n) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this._r = o.parseUInt(255 * e.Clamp(t, 0, 1)), this._g = o.parseUInt(255 * e.Clamp(i, 0, 1)), this._b = o.parseUInt(255 * e.Clamp(n, 0, 1))
            }, Object.defineProperty(t.prototype, "r", {
                enumerable: !1,
                configurable: !0,
                set: function(t) {
                    void 0 === t && (t = 0), this._r = o.parseUInt(255 * e.Clamp(t, 0, 1))
                }
            }), Object.defineProperty(t.prototype, "g", {
                enumerable: !1,
                configurable: !0,
                set: function(t) {
                    void 0 === t && (t = 0), this._g = o.parseUInt(255 * e.Clamp(t, 0, 1))
                }
            }), Object.defineProperty(t.prototype, "b", {
                enumerable: !1,
                configurable: !0,
                set: function(t) {
                    void 0 === t && (t = 0), this._b = o.parseUInt(255 * e.Clamp(t, 0, 1))
                }
            }), Object.defineProperty(t.prototype, "color", {
                enumerable: !1,
                configurable: !0,
                get: function() {
                    return this._r << 16 | this._g << 8 | this._b
                }
            }), i.b2Settings = function() {}, i.b2MixFriction = function(t, i) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), Math.sqrt(t * i)
            }, i.b2MixRestitution = function(t, i) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), t > i ? t : i
            }, i.b2Assert = function(t) {
                if (!t) throw "Assertion Failed"
            }, o.postDefs.push(function() {
                o.Common.b2Settings.VERSION = "2.1alpha", o.Common.b2Settings.USHRT_MAX = 65535, o.Common.b2Settings.b2_pi = Math.PI, o.Common.b2Settings.b2_maxManifoldPoints = 2, o.Common.b2Settings.b2_aabbExtension = .1, o.Common.b2Settings.b2_aabbMultiplier = 2, o.Common.b2Settings.b2_polygonRadius = 2 * i.b2_linearSlop, o.Common.b2Settings.b2_linearSlop = .005, o.Common.b2Settings.b2_angularSlop = 2 / 180 * i.b2_pi, o.Common.b2Settings.b2_toiSlop = 8 * i.b2_linearSlop, o.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, o.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, o.Common.b2Settings.b2_velocityThreshold = 1, o.Common.b2Settings.b2_maxLinearCorrection = .2, o.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * i.b2_pi, o.Common.b2Settings.b2_maxTranslation = 2, o.Common.b2Settings.b2_maxTranslationSquared = i.b2_maxTranslation * i.b2_maxTranslation, o.Common.b2Settings.b2_maxRotation = .5 * i.b2_pi, o.Common.b2Settings.b2_maxRotationSquared = i.b2_maxRotation * i.b2_maxRotation, o.Common.b2Settings.b2_contactBaumgarte = .2, o.Common.b2Settings.b2_timeToSleep = .5, o.Common.b2Settings.b2_linearSleepTolerance = .01, o.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * i.b2_pi
            })
        }(), function() {
            var t = o.Common.Math.b2Mat22,
                i = o.Common.Math.b2Mat33,
                e = o.Common.Math.b2Math,
                n = o.Common.Math.b2Sweep,
                s = o.Common.Math.b2Transform,
                r = o.Common.Math.b2Vec2,
                a = o.Common.Math.b2Vec3;
            t.b2Mat22 = function() {
                this.col1 = new r, this.col2 = new r
            }, t.prototype.b2Mat22 = function() {
                this.SetIdentity()
            }, t.FromAngle = function(i) {
                void 0 === i && (i = 0);
                var o = new t;
                return o.Set(i), o
            }, t.FromVV = function(i, o) {
                var e = new t;
                return e.SetVV(i, o), e
            }, t.prototype.Set = function(t) {
                void 0 === t && (t = 0);
                var i = Math.cos(t);
                t = Math.sin(t), this.col1.x = i, this.col2.x = -t, this.col1.y = t, this.col2.y = i
            }, t.prototype.SetVV = function(t, i) {
                this.col1.SetV(t), this.col2.SetV(i)
            }, t.prototype.Copy = function() {
                var i = new t;
                return i.SetM(this), i
            }, t.prototype.SetM = function(t) {
                this.col1.SetV(t.col1), this.col2.SetV(t.col2)
            }, t.prototype.AddM = function(t) {
                this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col2.x += t.col2.x, this.col2.y += t.col2.y
            }, t.prototype.SetIdentity = function() {
                this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1
            }, t.prototype.SetZero = function() {
                this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0
            }, t.prototype.GetAngle = function() {
                return Math.atan2(this.col1.y, this.col1.x)
            }, t.prototype.GetInverse = function(t) {
                var i = this.col1.x,
                    o = this.col2.x,
                    e = this.col1.y,
                    n = this.col2.y,
                    s = i * n - o * e;
                return 0 != s && (s = 1 / s), t.col1.x = s * n, t.col2.x = -s * o, t.col1.y = -s * e, t.col2.y = s * i, t
            }, t.prototype.Solve = function(t, i, o) {
                void 0 === i && (i = 0), void 0 === o && (o = 0);
                var e = this.col1.x,
                    n = this.col2.x,
                    s = this.col1.y,
                    r = this.col2.y,
                    a = e * r - n * s;
                return 0 != a && (a = 1 / a), t.x = a * (r * i - n * o), t.y = a * (e * o - s * i), t
            }, t.prototype.Abs = function() {
                this.col1.Abs(), this.col2.Abs()
            }, i.b2Mat33 = function() {
                this.col1 = new a, this.col2 = new a, this.col3 = new a
            }, i.prototype.b2Mat33 = function(t, i, o) {
                void 0 === t && (t = null), void 0 === i && (i = null), void 0 === o && (o = null), t || i || o ? (this.col1.SetV(t), this.col2.SetV(i), this.col3.SetV(o)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
            }, i.prototype.SetVVV = function(t, i, o) {
                this.col1.SetV(t), this.col2.SetV(i), this.col3.SetV(o)
            }, i.prototype.Copy = function() {
                return new i(this.col1, this.col2, this.col3)
            }, i.prototype.SetM = function(t) {
                this.col1.SetV(t.col1), this.col2.SetV(t.col2), this.col3.SetV(t.col3)
            }, i.prototype.AddM = function(t) {
                this.col1.x += t.col1.x, this.col1.y += t.col1.y, this.col1.z += t.col1.z, this.col2.x += t.col2.x, this.col2.y += t.col2.y, this.col2.z += t.col2.z, this.col3.x += t.col3.x, this.col3.y += t.col3.y, this.col3.z += t.col3.z
            }, i.prototype.SetIdentity = function() {
                this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1
            }, i.prototype.SetZero = function() {
                this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0
            }, i.prototype.Solve22 = function(t, i, o) {
                void 0 === i && (i = 0), void 0 === o && (o = 0);
                var e = this.col1.x,
                    n = this.col2.x,
                    s = this.col1.y,
                    r = this.col2.y,
                    a = e * r - n * s;
                return 0 != a && (a = 1 / a), t.x = a * (r * i - n * o), t.y = a * (e * o - s * i), t
            }, i.prototype.Solve33 = function(t, i, o, e) {
                void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === e && (e = 0);
                var n = this.col1.x,
                    s = this.col1.y,
                    r = this.col1.z,
                    a = this.col2.x,
                    l = this.col2.y,
                    m = this.col2.z,
                    c = this.col3.x,
                    h = this.col3.y,
                    _ = this.col3.z,
                    p = n * (l * _ - m * h) + s * (m * c - a * _) + r * (a * h - l * c);
                return 0 != p && (p = 1 / p), t.x = p * (i * (l * _ - m * h) + o * (m * c - a * _) + e * (a * h - l * c)), t.y = p * (n * (o * _ - e * h) + s * (e * c - i * _) + r * (i * h - o * c)), t.z = p * (n * (l * e - m * o) + s * (m * i - a * e) + r * (a * o - l * i)), t
            }, e.b2Math = function() {}, e.IsValid = function(t) {
                return void 0 === t && (t = 0), isFinite(t)
            }, e.Dot = function(t, i) {
                return t.x * i.x + t.y * i.y
            }, e.CrossVV = function(t, i) {
                return t.x * i.y - t.y * i.x
            }, e.CrossVF = function(t, i) {
                return void 0 === i && (i = 0), new r(i * t.y, -i * t.x)
            }, e.CrossFV = function(t, i) {
                return void 0 === t && (t = 0), new r(-t * i.y, t * i.x)
            }, e.MulMV = function(t, i) {
                return new r(t.col1.x * i.x + t.col2.x * i.y, t.col1.y * i.x + t.col2.y * i.y)
            }, e.MulTMV = function(t, i) {
                return new r(e.Dot(i, t.col1), e.Dot(i, t.col2))
            }, e.MulX = function(t, i) {
                var o = e.MulMV(t.R, i);
                return o.x += t.position.x, o.y += t.position.y, o
            }, e.MulXT = function(t, i) {
                var o = e.SubtractVV(i, t.position),
                    n = o.x * t.R.col1.x + o.y * t.R.col1.y;
                return o.y = o.x * t.R.col2.x + o.y * t.R.col2.y, o.x = n, o
            }, e.AddVV = function(t, i) {
                return new r(t.x + i.x, t.y + i.y)
            }, e.SubtractVV = function(t, i) {
                return new r(t.x - i.x, t.y - i.y)
            }, e.Distance = function(t, i) {
                var o = t.x - i.x,
                    e = t.y - i.y;
                return Math.sqrt(o * o + e * e)
            }, e.DistanceSquared = function(t, i) {
                var o = t.x - i.x,
                    e = t.y - i.y;
                return o * o + e * e
            }, e.MulFV = function(t, i) {
                return void 0 === t && (t = 0), new r(t * i.x, t * i.y)
            }, e.AddMM = function(i, o) {
                return t.FromVV(e.AddVV(i.col1, o.col1), e.AddVV(i.col2, o.col2))
            }, e.MulMM = function(i, o) {
                return t.FromVV(e.MulMV(i, o.col1), e.MulMV(i, o.col2))
            }, e.MulTMM = function(i, o) {
                var n = new r(e.Dot(i.col1, o.col1), e.Dot(i.col2, o.col1)),
                    s = new r(e.Dot(i.col1, o.col2), e.Dot(i.col2, o.col2));
                return t.FromVV(n, s)
            }, e.Abs = function(t) {
                return void 0 === t && (t = 0), t > 0 ? t : -t
            }, e.AbsV = function(t) {
                return new r(e.Abs(t.x), e.Abs(t.y))
            }, e.AbsM = function(i) {
                return t.FromVV(e.AbsV(i.col1), e.AbsV(i.col2))
            }, e.Min = function(t, i) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), t < i ? t : i
            }, e.MinV = function(t, i) {
                return new r(e.Min(t.x, i.x), e.Min(t.y, i.y))
            }, e.Max = function(t, i) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), t > i ? t : i
            }, e.MaxV = function(t, i) {
                return new r(e.Max(t.x, i.x), e.Max(t.y, i.y))
            }, e.Clamp = function(t, i, o) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), t < i ? i : t > o ? o : t
            }, e.ClampV = function(t, i, o) {
                return e.MaxV(i, e.MinV(t, o))
            }, e.Swap = function(t, i) {
                var o = t[0];
                t[0] = i[0], i[0] = o
            }, e.Random = function() {
                return 2 * Math.random() - 1
            }, e.RandomRange = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0);
                var o = Math.random();
                return (i - t) * o + t
            }, e.NextPowerOfTwo = function(t) {
                return void 0 === t && (t = 0), t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1
            }, e.IsPowerOfTwo = function(t) {
                return void 0 === t && (t = 0), t > 0 && 0 == (t & t - 1)
            }, o.postDefs.push(function() {
                o.Common.Math.b2Math.b2Vec2_zero = new r(0, 0), o.Common.Math.b2Math.b2Mat22_identity = t.FromVV(new r(1, 0), new r(0, 1)), o.Common.Math.b2Math.b2Transform_identity = new s(e.b2Vec2_zero, e.b2Mat22_identity)
            }), n.b2Sweep = function() {
                this.localCenter = new r, this.c0 = new r, this.c = new r
            }, n.prototype.Set = function(t) {
                this.localCenter.SetV(t.localCenter), this.c0.SetV(t.c0), this.c.SetV(t.c), this.a0 = t.a0, this.a = t.a, this.t0 = t.t0
            }, n.prototype.Copy = function() {
                var t = new n;
                return t.localCenter.SetV(this.localCenter), t.c0.SetV(this.c0), t.c.SetV(this.c), t.a0 = this.a0, t.a = this.a, t.t0 = this.t0, t
            }, n.prototype.GetTransform = function(t, i) {
                void 0 === i && (i = 0), t.position.x = (1 - i) * this.c0.x + i * this.c.x, t.position.y = (1 - i) * this.c0.y + i * this.c.y, t.R.Set((1 - i) * this.a0 + i * this.a);
                var o = t.R;
                t.position.x -= o.col1.x * this.localCenter.x + o.col2.x * this.localCenter.y, t.position.y -= o.col1.y * this.localCenter.x + o.col2.y * this.localCenter.y
            }, n.prototype.Advance = function(t) {
                if (void 0 === t && (t = 0), this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
                    var i = (t - this.t0) / (1 - this.t0);
                    this.c0.x = (1 - i) * this.c0.x + i * this.c.x, this.c0.y = (1 - i) * this.c0.y + i * this.c.y, this.a0 = (1 - i) * this.a0 + i * this.a, this.t0 = t
                }
            }, s.b2Transform = function() {
                this.position = new r, this.R = new t
            }, s.prototype.b2Transform = function(t, i) {
                void 0 === t && (t = null), void 0 === i && (i = null), t && (this.position.SetV(t), this.R.SetM(i))
            }, s.prototype.Initialize = function(t, i) {
                this.position.SetV(t), this.R.SetM(i)
            }, s.prototype.SetIdentity = function() {
                this.position.SetZero(), this.R.SetIdentity()
            }, s.prototype.Set = function(t) {
                this.position.SetV(t.position), this.R.SetM(t.R)
            }, s.prototype.GetAngle = function() {
                return Math.atan2(this.R.col1.y, this.R.col1.x)
            }, r.b2Vec2 = function() {}, r.prototype.b2Vec2 = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.x = t, this.y = i
            }, r.prototype.SetZero = function() {
                this.y = this.x = 0
            }, r.prototype.Set = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.x = t, this.y = i
            }, r.prototype.SetV = function(t) {
                this.x = t.x, this.y = t.y
            }, r.prototype.GetNegative = function() {
                return new r(-this.x, -this.y)
            }, r.prototype.NegativeSelf = function() {
                this.x = -this.x, this.y = -this.y
            }, r.Make = function(t, i) {
                return void 0 === t && (t = 0), void 0 === i && (i = 0), new r(t, i)
            }, r.prototype.Copy = function() {
                return new r(this.x, this.y)
            }, r.prototype.Add = function(t) {
                this.x += t.x, this.y += t.y
            }, r.prototype.Subtract = function(t) {
                this.x -= t.x, this.y -= t.y
            }, r.prototype.Multiply = function(t) {
                void 0 === t && (t = 0), this.x *= t, this.y *= t
            }, r.prototype.MulM = function(t) {
                var i = this.x;
                this.x = t.col1.x * i + t.col2.x * this.y, this.y = t.col1.y * i + t.col2.y * this.y
            }, r.prototype.MulTM = function(t) {
                var i = e.Dot(this, t.col1);
                this.y = e.Dot(this, t.col2), this.x = i
            }, r.prototype.CrossVF = function(t) {
                void 0 === t && (t = 0);
                var i = this.x;
                this.x = t * this.y, this.y = -t * i
            }, r.prototype.CrossFV = function(t) {
                void 0 === t && (t = 0);
                var i = this.x;
                this.x = -t * this.y, this.y = t * i
            }, r.prototype.MinV = function(t) {
                this.x = this.x < t.x ? this.x : t.x, this.y = this.y < t.y ? this.y : t.y
            }, r.prototype.MaxV = function(t) {
                this.x = this.x > t.x ? this.x : t.x, this.y = this.y > t.y ? this.y : t.y
            }, r.prototype.Abs = function() {
                this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y)
            }, r.prototype.Length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, r.prototype.LengthSquared = function() {
                return this.x * this.x + this.y * this.y
            }, r.prototype.Normalize = function() {
                var t = Math.sqrt(this.x * this.x + this.y * this.y);
                if (t < Number.MIN_VALUE) return 0;
                var i = 1 / t;
                return this.x *= i, this.y *= i, t
            }, r.prototype.IsValid = function() {
                return e.IsValid(this.x) && e.IsValid(this.y)
            }, a.b2Vec3 = function() {}, a.prototype.b2Vec3 = function(t, i, o) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.x = t, this.y = i, this.z = o
            }, a.prototype.SetZero = function() {
                this.x = this.y = this.z = 0
            }, a.prototype.Set = function(t, i, o) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.x = t, this.y = i, this.z = o
            }, a.prototype.SetV = function(t) {
                this.x = t.x, this.y = t.y, this.z = t.z
            }, a.prototype.GetNegative = function() {
                return new a(-this.x, -this.y, -this.z)
            }, a.prototype.NegativeSelf = function() {
                this.x = -this.x, this.y = -this.y, this.z = -this.z
            }, a.prototype.Copy = function() {
                return new a(this.x, this.y, this.z)
            }, a.prototype.Add = function(t) {
                this.x += t.x, this.y += t.y, this.z += t.z
            }, a.prototype.Subtract = function(t) {
                this.x -= t.x, this.y -= t.y, this.z -= t.z
            }, a.prototype.Multiply = function(t) {
                void 0 === t && (t = 0), this.x *= t, this.y *= t, this.z *= t
            }
        }(), function() {
            var t = o.Common.Math.b2Math,
                i = o.Common.Math.b2Sweep,
                e = o.Common.Math.b2Transform,
                n = o.Common.Math.b2Vec2,
                s = o.Common.b2Color,
                r = o.Common.b2Settings,
                a = o.Collision.b2AABB,
                l = o.Collision.b2ContactPoint,
                m = o.Collision.b2DynamicTreeBroadPhase,
                c = o.Collision.b2RayCastInput,
                h = o.Collision.b2RayCastOutput,
                _ = o.Collision.Shapes.b2CircleShape,
                p = o.Collision.Shapes.b2EdgeShape,
                y = o.Collision.Shapes.b2MassData,
                u = o.Collision.Shapes.b2PolygonShape,
                x = o.Collision.Shapes.b2Shape,
                f = o.Dynamics.b2Body,
                d = o.Dynamics.b2BodyDef,
                b = o.Dynamics.b2ContactFilter,
                v = o.Dynamics.b2ContactImpulse,
                C = o.Dynamics.b2ContactListener,
                w = o.Dynamics.b2ContactManager,
                A = o.Dynamics.b2DebugDraw,
                g = o.Dynamics.b2DestructionListener,
                S = o.Dynamics.b2FilterData,
                B = o.Dynamics.b2Fixture,
                M = o.Dynamics.b2FixtureDef,
                V = o.Dynamics.b2Island,
                D = o.Dynamics.b2TimeStep,
                I = o.Dynamics.b2World,
                G = o.Dynamics.Contacts.b2Contact,
                L = o.Dynamics.Contacts.b2ContactFactory,
                J = o.Dynamics.Contacts.b2ContactSolver,
                F = o.Dynamics.Joints.b2Joint,
                P = o.Dynamics.Joints.b2PulleyJoint;
            f.b2Body = function() {
                this.m_xf = new e, this.m_sweep = new i, this.m_linearVelocity = new n, this.m_force = new n
            }, f.prototype.connectEdges = function(i, o, e) {
                void 0 === e && (e = 0);
                var n = Math.atan2(o.GetDirectionVector().y, o.GetDirectionVector().x);
                e = t.MulFV(Math.tan(.5 * (n - e)), o.GetDirectionVector()), e = t.SubtractVV(e, o.GetNormalVector()), e = t.MulFV(r.b2_toiSlop, e), e = t.AddVV(e, o.GetVertex1());
                var s = t.AddVV(i.GetDirectionVector(), o.GetDirectionVector());
                s.Normalize();
                var a = t.Dot(i.GetDirectionVector(), o.GetNormalVector()) > 0;
                return i.SetNextEdge(o, e, s, a), o.SetPrevEdge(i, e, s, a), n
            }, f.prototype.CreateFixture = function(t) {
                if (1 == this.m_world.IsLocked()) return null;
                var i = new B;
                return i.Create(this, this.m_xf, t), this.m_flags & f.e_activeFlag && i.CreateProxy(this.m_world.m_contactManager.m_broadPhase, this.m_xf), i.m_next = this.m_fixtureList, this.m_fixtureList = i, ++this.m_fixtureCount, i.m_body = this, i.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= I.e_newFixture, i
            }, f.prototype.CreateFixture2 = function(t, i) {
                void 0 === i && (i = 0);
                var o = new M;
                return o.shape = t, o.density = i, this.CreateFixture(o)
            }, f.prototype.DestroyFixture = function(t) {
                if (1 != this.m_world.IsLocked()) {
                    for (var i = this.m_fixtureList, o = null; null != i;) {
                        if (i == t) {
                            o ? o.m_next = t.m_next : this.m_fixtureList = t.m_next;
                            break
                        }
                        o = i, i = i.m_next
                    }
                    for (i = this.m_contactList; i;) {
                        o = i.contact, i = i.next;
                        var e = o.GetFixtureA(),
                            n = o.GetFixtureB();
                        t != e && t != n || this.m_world.m_contactManager.Destroy(o)
                    }
                    this.m_flags & f.e_activeFlag && t.DestroyProxy(this.m_world.m_contactManager.m_broadPhase), t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData()
                }
            }, f.prototype.SetPositionAndAngle = function(t, i) {
                var o;
                if (void 0 === i && (i = 0), 1 != this.m_world.IsLocked()) {
                    this.m_xf.R.Set(i), this.m_xf.position.SetV(t), o = this.m_xf.R;
                    var e = this.m_sweep.localCenter;
                    for (this.m_sweep.c.x = o.col1.x * e.x + o.col2.x * e.y, this.m_sweep.c.y = o.col1.y * e.x + o.col2.y * e.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = this.m_sweep.a = i, e = this.m_world.m_contactManager.m_broadPhase, o = this.m_fixtureList; o; o = o.m_next) o.Synchronize(e, this.m_xf, this.m_xf);
                    this.m_world.m_contactManager.FindNewContacts()
                }
            }, f.prototype.SetTransform = function(t) {
                this.SetPositionAndAngle(t.position, t.GetAngle())
            }, f.prototype.GetTransform = function() {
                return this.m_xf
            }, f.prototype.GetPosition = function() {
                return this.m_xf.position
            }, f.prototype.SetPosition = function(t) {
                this.SetPositionAndAngle(t, this.GetAngle())
            }, f.prototype.GetAngle = function() {
                return this.m_sweep.a
            }, f.prototype.SetAngle = function(t) {
                void 0 === t && (t = 0), this.SetPositionAndAngle(this.GetPosition(), t)
            }, f.prototype.GetWorldCenter = function() {
                return this.m_sweep.c
            }, f.prototype.GetLocalCenter = function() {
                return this.m_sweep.localCenter
            }, f.prototype.SetLinearVelocity = function(t) {
                this.m_type != f.b2_staticBody && this.m_linearVelocity.SetV(t)
            }, f.prototype.GetLinearVelocity = function() {
                return this.m_linearVelocity
            }, f.prototype.SetAngularVelocity = function(t) {
                void 0 === t && (t = 0), this.m_type != f.b2_staticBody && (this.m_angularVelocity = t)
            }, f.prototype.GetAngularVelocity = function() {
                return this.m_angularVelocity
            }, f.prototype.GetDefinition = function() {
                var t = new d;
                return t.type = this.GetType(), t.allowSleep = (this.m_flags & f.e_allowSleepFlag) == f.e_allowSleepFlag, t.angle = this.GetAngle(), t.angularDamping = this.m_angularDamping, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & f.e_fixedRotationFlag) == f.e_fixedRotationFlag, t.bullet = (this.m_flags & f.e_bulletFlag) == f.e_bulletFlag, t.awake = (this.m_flags & f.e_awakeFlag) == f.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.SetV(this.GetLinearVelocity()), t.position = this.GetPosition(), t.userData = this.GetUserData(), t
            }, f.prototype.ApplyForce = function(t, i) {
                this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (i.x - this.m_sweep.c.x) * t.y - (i.y - this.m_sweep.c.y) * t.x)
            }, f.prototype.ApplyTorque = function(t) {
                void 0 === t && (t = 0), this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_torque += t)
            }, f.prototype.ApplyImpulse = function(t, i) {
                this.m_type == f.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((i.x - this.m_sweep.c.x) * t.y - (i.y - this.m_sweep.c.y) * t.x))
            }, f.prototype.Split = function(i) {
                for (var o, e = this.GetLinearVelocity().Copy(), n = this.GetAngularVelocity(), s = this.GetWorldCenter(), r = this.m_world.CreateBody(this.GetDefinition()), a = this.m_fixtureList; a;)
                    if (i(a)) {
                        var l = a.m_next;
                        o ? o.m_next = l : this.m_fixtureList = l, this.m_fixtureCount--, a.m_next = r.m_fixtureList, r.m_fixtureList = a, r.m_fixtureCount++, a.m_body = r, a = l
                    } else o = a, a = a.m_next;
                return this.ResetMassData(), r.ResetMassData(), o = this.GetWorldCenter(), i = r.GetWorldCenter(), o = t.AddVV(e, t.CrossFV(n, t.SubtractVV(o, s))), e = t.AddVV(e, t.CrossFV(n, t.SubtractVV(i, s))), this.SetLinearVelocity(o), r.SetLinearVelocity(e), this.SetAngularVelocity(n), r.SetAngularVelocity(n), this.SynchronizeFixtures(), r.SynchronizeFixtures(), r
            }, f.prototype.Merge = function(t) {
                var i;
                for (i = t.m_fixtureList; i;) {
                    var o = i.m_next;
                    t.m_fixtureCount--, i.m_next = this.m_fixtureList, this.m_fixtureList = i, this.m_fixtureCount++, i.m_body = n, i = o
                }
                e.m_fixtureCount = 0;
                var e = this,
                    n = t;
                e.GetWorldCenter(), n.GetWorldCenter(), e.GetLinearVelocity().Copy(), n.GetLinearVelocity().Copy(), e.GetAngularVelocity(), n.GetAngularVelocity(), e.ResetMassData(), this.SynchronizeFixtures()
            }, f.prototype.GetMass = function() {
                return this.m_mass
            }, f.prototype.GetInertia = function() {
                return this.m_I
            }, f.prototype.GetMassData = function(t) {
                t.mass = this.m_mass, t.I = this.m_I, t.center.SetV(this.m_sweep.localCenter)
            }, f.prototype.SetMassData = function(i) {
                if (r.b2Assert(0 == this.m_world.IsLocked()), 1 != this.m_world.IsLocked() && this.m_type == f.b2_dynamicBody) {
                    this.m_invI = this.m_I = this.m_invMass = 0, this.m_mass = i.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, i.I > 0 && 0 == (this.m_flags & f.e_fixedRotationFlag) && (this.m_I = i.I - this.m_mass * (i.center.x * i.center.x + i.center.y * i.center.y), this.m_invI = 1 / this.m_I);
                    var o = this.m_sweep.c.Copy();
                    this.m_sweep.localCenter.SetV(i.center), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - o.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - o.x)
                }
            }, f.prototype.ResetMassData = function() {
                if (this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0, this.m_sweep.localCenter.SetZero(), this.m_type != f.b2_staticBody && this.m_type != f.b2_kinematicBody) {
                    for (var i = n.Make(0, 0), o = this.m_fixtureList; o; o = o.m_next)
                        if (0 != o.m_density) {
                            var e = o.GetMassData();
                            this.m_mass += e.mass, i.x += e.center.x * e.mass, i.y += e.center.y * e.mass, this.m_I += e.I
                        } this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, i.x *= this.m_invMass, i.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1, this.m_I > 0 && 0 == (this.m_flags & f.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (i.x * i.x + i.y * i.y), this.m_I *= this.m_inertiaScale, r.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0, o = this.m_sweep.c.Copy(), this.m_sweep.localCenter.SetV(i), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - o.y), this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - o.x)
                }
            }, f.prototype.GetWorldPoint = function(t) {
                var i = this.m_xf.R;
                return (t = new n(i.col1.x * t.x + i.col2.x * t.y, i.col1.y * t.x + i.col2.y * t.y)).x += this.m_xf.position.x, t.y += this.m_xf.position.y, t
            }, f.prototype.GetWorldVector = function(i) {
                return t.MulMV(this.m_xf.R, i)
            }, f.prototype.GetLocalPoint = function(i) {
                return t.MulXT(this.m_xf, i)
            }, f.prototype.GetLocalVector = function(i) {
                return t.MulTMV(this.m_xf.R, i)
            }, f.prototype.GetLinearVelocityFromWorldPoint = function(t) {
                return new n(this.m_linearVelocity.x - this.m_angularVelocity * (t.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (t.x - this.m_sweep.c.x))
            }, f.prototype.GetLinearVelocityFromLocalPoint = function(t) {
                var i = this.m_xf.R;
                return (t = new n(i.col1.x * t.x + i.col2.x * t.y, i.col1.y * t.x + i.col2.y * t.y)).x += this.m_xf.position.x, t.y += this.m_xf.position.y, new n(this.m_linearVelocity.x - this.m_angularVelocity * (t.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (t.x - this.m_sweep.c.x))
            }, f.prototype.GetLinearDamping = function() {
                return this.m_linearDamping
            }, f.prototype.SetLinearDamping = function(t) {
                void 0 === t && (t = 0), this.m_linearDamping = t
            }, f.prototype.GetAngularDamping = function() {
                return this.m_angularDamping
            }, f.prototype.SetAngularDamping = function(t) {
                void 0 === t && (t = 0), this.m_angularDamping = t
            }, f.prototype.SetType = function(t) {
                if (void 0 === t && (t = 0), this.m_type != t)
                    for (this.m_type = t, this.ResetMassData(), this.m_type == f.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0, t = this.m_contactList; t; t = t.next) t.contact.FlagForFiltering()
            }, f.prototype.GetType = function() {
                return this.m_type
            }, f.prototype.SetBullet = function(t) {
                t ? this.m_flags |= f.e_bulletFlag : this.m_flags &= ~f.e_bulletFlag
            }, f.prototype.IsBullet = function() {
                return (this.m_flags & f.e_bulletFlag) == f.e_bulletFlag
            }, f.prototype.SetSleepingAllowed = function(t) {
                t ? this.m_flags |= f.e_allowSleepFlag : (this.m_flags &= ~f.e_allowSleepFlag, this.SetAwake(!0))
            }, f.prototype.SetAwake = function(t) {
                t ? (this.m_flags |= f.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~f.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
            }, f.prototype.IsAwake = function() {
                return (this.m_flags & f.e_awakeFlag) == f.e_awakeFlag
            }, f.prototype.SetFixedRotation = function(t) {
                t ? this.m_flags |= f.e_fixedRotationFlag : this.m_flags &= ~f.e_fixedRotationFlag, this.ResetMassData()
            }, f.prototype.IsFixedRotation = function() {
                return (this.m_flags & f.e_fixedRotationFlag) == f.e_fixedRotationFlag
            }, f.prototype.SetActive = function(t) {
                var i;
                if (t != this.IsActive())
                    if (t)
                        for (this.m_flags |= f.e_activeFlag, t = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxy(t, this.m_xf);
                    else {
                        for (this.m_flags &= ~f.e_activeFlag, t = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxy(t);
                        for (t = this.m_contactList; t;) i = t, t = t.next, this.m_world.m_contactManager.Destroy(i.contact);
                        this.m_contactList = null
                    }
            }, f.prototype.IsActive = function() {
                return (this.m_flags & f.e_activeFlag) == f.e_activeFlag
            }, f.prototype.IsSleepingAllowed = function() {
                return (this.m_flags & f.e_allowSleepFlag) == f.e_allowSleepFlag
            }, f.prototype.GetFixtureList = function() {
                return this.m_fixtureList
            }, f.prototype.GetJointList = function() {
                return this.m_jointList
            }, f.prototype.GetControllerList = function() {
                return this.m_controllerList
            }, f.prototype.GetContactList = function() {
                return this.m_contactList
            }, f.prototype.GetNext = function() {
                return this.m_next
            }, f.prototype.GetUserData = function() {
                return this.m_userData
            }, f.prototype.SetUserData = function(t) {
                this.m_userData = t
            }, f.prototype.GetWorld = function() {
                return this.m_world
            }, f.prototype.b2Body = function(t, i) {
                this.m_flags = 0, t.bullet && (this.m_flags |= f.e_bulletFlag), t.fixedRotation && (this.m_flags |= f.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= f.e_allowSleepFlag), t.awake && (this.m_flags |= f.e_awakeFlag), t.active && (this.m_flags |= f.e_activeFlag), this.m_world = i, this.m_xf.position.SetV(t.position), this.m_xf.R.Set(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = this.m_sweep.a = t.angle;
                var o = this.m_xf.R,
                    e = this.m_sweep.localCenter;
                this.m_sweep.c.x = o.col1.x * e.x + o.col2.x * e.y, this.m_sweep.c.y = o.col1.y * e.x + o.col2.y * e.y, this.m_sweep.c.x += this.m_xf.position.x, this.m_sweep.c.y += this.m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_contactList = this.m_controllerList = this.m_jointList = null, this.m_controllerCount = 0, this.m_next = this.m_prev = null, this.m_linearVelocity.SetV(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_force.Set(0, 0), this.m_sleepTime = this.m_torque = 0, this.m_type = t.type, this.m_type == f.b2_dynamicBody ? this.m_invMass = this.m_mass = 1 : this.m_invMass = this.m_mass = 0, this.m_invI = this.m_I = 0, this.m_inertiaScale = t.inertiaScale, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0
            }, f.prototype.SynchronizeFixtures = function() {
                var t = f.s_xf1;
                t.R.Set(this.m_sweep.a0);
                var i = t.R,
                    o = this.m_sweep.localCenter;
                for (t.position.x = this.m_sweep.c0.x - (i.col1.x * o.x + i.col2.x * o.y), t.position.y = this.m_sweep.c0.y - (i.col1.y * o.x + i.col2.y * o.y), o = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(o, t, this.m_xf)
            }, f.prototype.SynchronizeTransform = function() {
                this.m_xf.R.Set(this.m_sweep.a);
                var t = this.m_xf.R,
                    i = this.m_sweep.localCenter;
                this.m_xf.position.x = this.m_sweep.c.x - (t.col1.x * i.x + t.col2.x * i.y), this.m_xf.position.y = this.m_sweep.c.y - (t.col1.y * i.x + t.col2.y * i.y)
            }, f.prototype.ShouldCollide = function(t) {
                if (this.m_type != f.b2_dynamicBody && t.m_type != f.b2_dynamicBody) return !1;
                for (var i = this.m_jointList; i; i = i.next)
                    if (i.other == t && 0 == i.joint.m_collideConnected) return !1;
                return !0
            }, f.prototype.Advance = function(t) {
                void 0 === t && (t = 0), this.m_sweep.Advance(t), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.SynchronizeTransform()
            }, o.postDefs.push(function() {
                o.Dynamics.b2Body.s_xf1 = new e, o.Dynamics.b2Body.e_islandFlag = 1, o.Dynamics.b2Body.e_awakeFlag = 2, o.Dynamics.b2Body.e_allowSleepFlag = 4, o.Dynamics.b2Body.e_bulletFlag = 8, o.Dynamics.b2Body.e_fixedRotationFlag = 16, o.Dynamics.b2Body.e_activeFlag = 32, o.Dynamics.b2Body.b2_staticBody = 0, o.Dynamics.b2Body.b2_kinematicBody = 1, o.Dynamics.b2Body.b2_dynamicBody = 2
            }), d.b2BodyDef = function() {
                this.position = new n, this.linearVelocity = new n
            }, d.prototype.b2BodyDef = function() {
                this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularDamping = this.linearDamping = this.angularVelocity = 0, this.awake = this.allowSleep = !0, this.bullet = this.fixedRotation = !1, this.type = f.b2_staticBody, this.active = !0, this.inertiaScale = 1
            }, b.b2ContactFilter = function() {}, b.prototype.ShouldCollide = function(t, i) {
                var o = t.GetFilterData(),
                    e = i.GetFilterData();
                return o.groupIndex == e.groupIndex && 0 != o.groupIndex ? o.groupIndex > 0 : 0 != (o.maskBits & e.categoryBits) && 0 != (o.categoryBits & e.maskBits)
            }, b.prototype.RayCollide = function(t, i) {
                return !t || this.ShouldCollide(t instanceof B ? t : null, i)
            }, o.postDefs.push(function() {
                o.Dynamics.b2ContactFilter.b2_defaultFilter = new b
            }), v.b2ContactImpulse = function() {
                this.normalImpulses = new O(r.b2_maxManifoldPoints), this.tangentImpulses = new O(r.b2_maxManifoldPoints)
            }, C.b2ContactListener = function() {}, C.prototype.BeginContact = function() {}, C.prototype.EndContact = function() {}, C.prototype.PreSolve = function() {}, C.prototype.PostSolve = function() {}, o.postDefs.push(function() {
                o.Dynamics.b2ContactListener.b2_defaultListener = new C
            }), w.b2ContactManager = function() {}, w.prototype.b2ContactManager = function() {
                this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = b.b2_defaultFilter, this.m_contactListener = C.b2_defaultListener, this.m_contactFactory = new L(this.m_allocator), this.m_broadPhase = new m
            }, w.prototype.AddPair = function(t, i) {
                var o = t instanceof B ? t : null,
                    e = i instanceof B ? i : null,
                    n = o.GetBody(),
                    s = e.GetBody();
                if (n != s) {
                    for (var r = s.GetContactList(); r;) {
                        if (r.other == n) {
                            var a = r.contact.GetFixtureA(),
                                l = r.contact.GetFixtureB();
                            if (a == o && l == e) return;
                            if (a == e && l == o) return
                        }
                        r = r.next
                    }
                    0 != s.ShouldCollide(n) && 0 != this.m_contactFilter.ShouldCollide(o, e) && (o = (r = this.m_contactFactory.Create(o, e)).GetFixtureA(), e = r.GetFixtureB(), n = o.m_body, s = e.m_body, r.m_prev = null, r.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = r), this.m_world.m_contactList = r, r.m_nodeA.contact = r, r.m_nodeA.other = s, r.m_nodeA.prev = null, r.m_nodeA.next = n.m_contactList, null != n.m_contactList && (n.m_contactList.prev = r.m_nodeA), n.m_contactList = r.m_nodeA, r.m_nodeB.contact = r, r.m_nodeB.other = n, r.m_nodeB.prev = null, r.m_nodeB.next = s.m_contactList, null != s.m_contactList && (s.m_contactList.prev = r.m_nodeB), s.m_contactList = r.m_nodeB, ++this.m_world.m_contactCount)
                }
            }, w.prototype.FindNewContacts = function() {
                this.m_broadPhase.UpdatePairs(o.generateCallback(this, this.AddPair))
            }, w.prototype.Destroy = function(t) {
                var i = t.GetFixtureA(),
                    o = t.GetFixtureB();
                i = i.GetBody(), o = o.GetBody(), t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_world.m_contactList && (this.m_world.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA == i.m_contactList && (i.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB == o.m_contactList && (o.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount
            }, w.prototype.Collide = function() {
                for (var t = this.m_world.m_contactList; t;) {
                    var i = t.GetFixtureA(),
                        o = t.GetFixtureB(),
                        e = i.GetBody(),
                        n = o.GetBody();
                    if (0 == e.IsAwake() && 0 == n.IsAwake()) t = t.GetNext();
                    else {
                        if (t.m_flags & G.e_filterFlag) {
                            if (0 == n.ShouldCollide(e)) {
                                t = (i = t).GetNext(), this.Destroy(i);
                                continue
                            }
                            if (0 == this.m_contactFilter.ShouldCollide(i, o)) {
                                t = (i = t).GetNext(), this.Destroy(i);
                                continue
                            }
                            t.m_flags &= ~G.e_filterFlag
                        }
                        0 == this.m_broadPhase.TestOverlap(i.m_proxy, o.m_proxy) ? (t = (i = t).GetNext(), this.Destroy(i)) : (t.Update(this.m_contactListener), t = t.GetNext())
                    }
                }
            }, o.postDefs.push(function() {
                o.Dynamics.b2ContactManager.s_evalCP = new l
            }), A.b2DebugDraw = function() {}, A.prototype.b2DebugDraw = function() {}, A.prototype.SetFlags = function() {}, A.prototype.GetFlags = function() {}, A.prototype.AppendFlags = function() {}, A.prototype.ClearFlags = function() {}, A.prototype.SetSprite = function() {}, A.prototype.GetSprite = function() {}, A.prototype.SetDrawScale = function() {}, A.prototype.GetDrawScale = function() {}, A.prototype.SetLineThickness = function() {}, A.prototype.GetLineThickness = function() {}, A.prototype.SetAlpha = function() {}, A.prototype.GetAlpha = function() {}, A.prototype.SetFillAlpha = function() {}, A.prototype.GetFillAlpha = function() {}, A.prototype.SetXFormScale = function() {}, A.prototype.GetXFormScale = function() {}, A.prototype.DrawPolygon = function() {}, A.prototype.DrawSolidPolygon = function() {}, A.prototype.DrawCircle = function() {}, A.prototype.DrawSolidCircle = function() {}, A.prototype.DrawSegment = function() {}, A.prototype.DrawTransform = function() {}, o.postDefs.push(function() {
                o.Dynamics.b2DebugDraw.e_shapeBit = 1, o.Dynamics.b2DebugDraw.e_jointBit = 2, o.Dynamics.b2DebugDraw.e_aabbBit = 4, o.Dynamics.b2DebugDraw.e_pairBit = 8, o.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, o.Dynamics.b2DebugDraw.e_controllerBit = 32
            }), g.b2DestructionListener = function() {}, g.prototype.SayGoodbyeJoint = function() {}, g.prototype.SayGoodbyeFixture = function() {}, S.b2FilterData = function() {
                this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0
            }, S.prototype.Copy = function() {
                var t = new S;
                return t.categoryBits = this.categoryBits, t.maskBits = this.maskBits, t.groupIndex = this.groupIndex, t
            }, B.b2Fixture = function() {
                this.m_filter = new S
            }, B.prototype.GetType = function() {
                return this.m_shape.GetType()
            }, B.prototype.GetShape = function() {
                return this.m_shape
            }, B.prototype.SetSensor = function(t) {
                if (this.m_isSensor != t && (this.m_isSensor = t, null != this.m_body))
                    for (t = this.m_body.GetContactList(); t;) {
                        var i = t.contact,
                            o = i.GetFixtureA(),
                            e = i.GetFixtureB();
                        o != this && e != this || i.SetSensor(o.IsSensor() || e.IsSensor()), t = t.next
                    }
            }, B.prototype.IsSensor = function() {
                return this.m_isSensor
            }, B.prototype.SetFilterData = function(t) {
                if (this.m_filter = t.Copy(), !this.m_body)
                    for (t = this.m_body.GetContactList(); t;) {
                        var i = t.contact,
                            o = i.GetFixtureA(),
                            e = i.GetFixtureB();
                        o != this && e != this || i.FlagForFiltering(), t = t.next
                    }
            }, B.prototype.GetFilterData = function() {
                return this.m_filter.Copy()
            }, B.prototype.GetBody = function() {
                return this.m_body
            }, B.prototype.GetNext = function() {
                return this.m_next
            }, B.prototype.GetUserData = function() {
                return this.m_userData
            }, B.prototype.SetUserData = function(t) {
                this.m_userData = t
            }, B.prototype.TestPoint = function(t) {
                return this.m_shape.TestPoint(this.m_body.GetTransform(), t)
            }, B.prototype.RayCast = function(t, i) {
                return this.m_shape.RayCast(t, i, this.m_body.GetTransform())
            }, B.prototype.GetMassData = function(t) {
                return void 0 === t && (t = null), null == t && (t = new y), this.m_shape.ComputeMass(t, this.m_density), t
            }, B.prototype.SetDensity = function(t) {
                void 0 === t && (t = 0), this.m_density = t
            }, B.prototype.GetDensity = function() {
                return this.m_density
            }, B.prototype.GetFriction = function() {
                return this.m_friction
            }, B.prototype.SetFriction = function(t) {
                void 0 === t && (t = 0), this.m_friction = t
            }, B.prototype.GetRestitution = function() {
                return this.m_restitution
            }, B.prototype.SetRestitution = function(t) {
                void 0 === t && (t = 0), this.m_restitution = t
            }, B.prototype.GetAABB = function() {
                return this.m_aabb
            }, B.prototype.b2Fixture = function() {
                this.m_aabb = new a, this.m_shape = this.m_next = this.m_body = this.m_userData = null, this.m_restitution = this.m_friction = this.m_density = 0
            }, B.prototype.Create = function(t, i, o) {
                this.m_userData = o.userData, this.m_friction = o.friction, this.m_restitution = o.restitution, this.m_body = t, this.m_next = null, this.m_filter = o.filter.Copy(), this.m_isSensor = o.isSensor, this.m_shape = o.shape.Copy(), this.m_density = o.density
            }, B.prototype.Destroy = function() {
                this.m_shape = null
            }, B.prototype.CreateProxy = function(t, i) {
                this.m_shape.ComputeAABB(this.m_aabb, i), this.m_proxy = t.CreateProxy(this.m_aabb, this)
            }, B.prototype.DestroyProxy = function(t) {
                null != this.m_proxy && (t.DestroyProxy(this.m_proxy), this.m_proxy = null)
            }, B.prototype.Synchronize = function(i, o, e) {
                if (this.m_proxy) {
                    var n = new a,
                        s = new a;
                    this.m_shape.ComputeAABB(n, o), this.m_shape.ComputeAABB(s, e), this.m_aabb.Combine(n, s), o = t.SubtractVV(e.position, o.position), i.MoveProxy(this.m_proxy, this.m_aabb, o)
                }
            }, M.b2FixtureDef = function() {
                this.filter = new S
            }, M.prototype.b2FixtureDef = function() {
                this.userData = this.shape = null, this.friction = .2, this.density = this.restitution = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = !1
            }, V.b2Island = function() {}, V.prototype.b2Island = function() {
                this.m_bodies = new j, this.m_contacts = new j, this.m_joints = new j
            }, V.prototype.Initialize = function(t, i, o, e, n, s) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = 0);
                var r = 0;
                for (this.m_bodyCapacity = t, this.m_contactCapacity = i, this.m_jointCapacity = o, this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0, this.m_allocator = e, this.m_listener = n, this.m_contactSolver = s, r = this.m_bodies.length; r < t; r++) this.m_bodies[r] = null;
                for (r = this.m_contacts.length; r < i; r++) this.m_contacts[r] = null;
                for (r = this.m_joints.length; r < o; r++) this.m_joints[r] = null
            }, V.prototype.Clear = function() {
                this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
            }, V.prototype.Solve = function(i, o, e) {
                var n, s = 0,
                    a = 0;
                for (s = 0; s < this.m_bodyCount; ++s)(a = this.m_bodies[s]).GetType() == f.b2_dynamicBody && (a.m_linearVelocity.x += i.dt * (o.x + a.m_invMass * a.m_force.x), a.m_linearVelocity.y += i.dt * (o.y + a.m_invMass * a.m_force.y), a.m_angularVelocity += i.dt * a.m_invI * a.m_torque, a.m_linearVelocity.Multiply(t.Clamp(1 - i.dt * a.m_linearDamping, 0, 1)), a.m_angularVelocity *= t.Clamp(1 - i.dt * a.m_angularDamping, 0, 1));
                for (this.m_contactSolver.Initialize(i, this.m_contacts, this.m_contactCount, this.m_allocator), (o = this.m_contactSolver).InitVelocityConstraints(i), s = 0; s < this.m_jointCount; ++s)(n = this.m_joints[s]).InitVelocityConstraints(i);
                for (s = 0; s < i.velocityIterations; ++s) {
                    for (a = 0; a < this.m_jointCount; ++a)(n = this.m_joints[a]).SolveVelocityConstraints(i);
                    o.SolveVelocityConstraints()
                }
                for (s = 0; s < this.m_jointCount; ++s)(n = this.m_joints[s]).FinalizeVelocityConstraints();
                for (o.FinalizeVelocityConstraints(), s = 0; s < this.m_bodyCount; ++s)
                    if ((a = this.m_bodies[s]).GetType() != f.b2_staticBody) {
                        var l = i.dt * a.m_linearVelocity.x,
                            m = i.dt * a.m_linearVelocity.y;
                        l * l + m * m > r.b2_maxTranslationSquared && (a.m_linearVelocity.Normalize(), a.m_linearVelocity.x *= r.b2_maxTranslation * i.inv_dt, a.m_linearVelocity.y *= r.b2_maxTranslation * i.inv_dt), (l = i.dt * a.m_angularVelocity) * l > r.b2_maxRotationSquared && (a.m_angularVelocity = a.m_angularVelocity < 0 ? -r.b2_maxRotation * i.inv_dt : r.b2_maxRotation * i.inv_dt), a.m_sweep.c0.SetV(a.m_sweep.c), a.m_sweep.a0 = a.m_sweep.a, a.m_sweep.c.x += i.dt * a.m_linearVelocity.x, a.m_sweep.c.y += i.dt * a.m_linearVelocity.y, a.m_sweep.a += i.dt * a.m_angularVelocity, a.SynchronizeTransform()
                    } for (s = 0; s < i.positionIterations; ++s) {
                    for (l = o.SolvePositionConstraints(r.b2_contactBaumgarte), m = !0, a = 0; a < this.m_jointCount; ++a) n = (n = this.m_joints[a]).SolvePositionConstraints(r.b2_contactBaumgarte), m = m && n;
                    if (l && m) break
                }
                if (this.Report(o.m_constraints), e) {
                    for (e = Number.MAX_VALUE, o = r.b2_linearSleepTolerance * r.b2_linearSleepTolerance, l = r.b2_angularSleepTolerance * r.b2_angularSleepTolerance, s = 0; s < this.m_bodyCount; ++s)(a = this.m_bodies[s]).GetType() != f.b2_staticBody && (0 == (a.m_flags & f.e_allowSleepFlag) && (e = a.m_sleepTime = 0), 0 == (a.m_flags & f.e_allowSleepFlag) || a.m_angularVelocity * a.m_angularVelocity > l || t.Dot(a.m_linearVelocity, a.m_linearVelocity) > o ? e = a.m_sleepTime = 0 : (a.m_sleepTime += i.dt, e = t.Min(e, a.m_sleepTime)));
                    if (e >= r.b2_timeToSleep)
                        for (s = 0; s < this.m_bodyCount; ++s)(a = this.m_bodies[s]).SetAwake(!1)
                }
            }, V.prototype.SolveTOI = function(t) {
                var i = 0,
                    o = 0;
                this.m_contactSolver.Initialize(t, this.m_contacts, this.m_contactCount, this.m_allocator);
                var e = this.m_contactSolver;
                for (i = 0; i < this.m_jointCount; ++i) this.m_joints[i].InitVelocityConstraints(t);
                for (i = 0; i < t.velocityIterations; ++i)
                    for (e.SolveVelocityConstraints(), o = 0; o < this.m_jointCount; ++o) this.m_joints[o].SolveVelocityConstraints(t);
                for (i = 0; i < this.m_bodyCount; ++i)
                    if ((o = this.m_bodies[i]).GetType() != f.b2_staticBody) {
                        var n = t.dt * o.m_linearVelocity.x,
                            s = t.dt * o.m_linearVelocity.y;
                        n * n + s * s > r.b2_maxTranslationSquared && (o.m_linearVelocity.Normalize(), o.m_linearVelocity.x *= r.b2_maxTranslation * t.inv_dt, o.m_linearVelocity.y *= r.b2_maxTranslation * t.inv_dt), (n = t.dt * o.m_angularVelocity) * n > r.b2_maxRotationSquared && (o.m_angularVelocity = o.m_angularVelocity < 0 ? -r.b2_maxRotation * t.inv_dt : r.b2_maxRotation * t.inv_dt), o.m_sweep.c0.SetV(o.m_sweep.c), o.m_sweep.a0 = o.m_sweep.a, o.m_sweep.c.x += t.dt * o.m_linearVelocity.x, o.m_sweep.c.y += t.dt * o.m_linearVelocity.y, o.m_sweep.a += t.dt * o.m_angularVelocity, o.SynchronizeTransform()
                    } for (i = 0; i < t.positionIterations; ++i) {
                    for (n = e.SolvePositionConstraints(.75), s = !0, o = 0; o < this.m_jointCount; ++o) {
                        var a = this.m_joints[o].SolvePositionConstraints(r.b2_contactBaumgarte);
                        s = s && a
                    }
                    if (n && s) break
                }
                this.Report(e.m_constraints)
            }, V.prototype.Report = function(t) {
                if (null != this.m_listener)
                    for (var i = 0; i < this.m_contactCount; ++i) {
                        for (var o = this.m_contacts[i], e = t[i], n = 0; n < e.pointCount; ++n) V.s_impulse.normalImpulses[n] = e.points[n].normalImpulse, V.s_impulse.tangentImpulses[n] = e.points[n].tangentImpulse;
                        this.m_listener.PostSolve(o, V.s_impulse)
                    }
            }, V.prototype.AddBody = function(t) {
                t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t
            }, V.prototype.AddContact = function(t) {
                this.m_contacts[this.m_contactCount++] = t
            }, V.prototype.AddJoint = function(t) {
                this.m_joints[this.m_jointCount++] = t
            }, o.postDefs.push(function() {
                o.Dynamics.b2Island.s_impulse = new v
            }), D.b2TimeStep = function() {}, D.prototype.Set = function(t) {
                this.dt = t.dt, this.inv_dt = t.inv_dt, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting
            }, I.b2World = function() {
                this.s_stack = new j, this.m_contactManager = new w, this.m_contactSolver = new J, this.m_island = new V
            }, I.prototype.b2World = function(t, i) {
                this.m_controllerList = this.m_jointList = this.m_contactList = this.m_bodyList = this.m_debugDraw = this.m_destructionListener = null, this.m_controllerCount = this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0, I.m_warmStarting = !0, I.m_continuousPhysics = !0, this.m_allowSleep = i, this.m_gravity = t, this.m_inv_dt0 = 0, this.m_contactManager.m_world = this, this.m_groundBody = this.CreateBody(new d)
            }, I.prototype.SetDestructionListener = function(t) {
                this.m_destructionListener = t
            }, I.prototype.SetContactFilter = function(t) {
                this.m_contactManager.m_contactFilter = t
            }, I.prototype.SetContactListener = function(t) {
                this.m_contactManager.m_contactListener = t
            }, I.prototype.SetDebugDraw = function(t) {
                this.m_debugDraw = t
            }, I.prototype.SetBroadPhase = function(t) {
                var i = this.m_contactManager.m_broadPhase;
                this.m_contactManager.m_broadPhase = t;
                for (var o = this.m_bodyList; o; o = o.m_next)
                    for (var e = o.m_fixtureList; e; e = e.m_next) e.m_proxy = t.CreateProxy(i.GetFatAABB(e.m_proxy), e)
            }, I.prototype.Validate = function() {
                this.m_contactManager.m_broadPhase.Validate()
            }, I.prototype.GetProxyCount = function() {
                return this.m_contactManager.m_broadPhase.GetProxyCount()
            }, I.prototype.CreateBody = function(t) {
                return 1 == this.IsLocked() ? null : ((t = new f(t, this)).m_prev = null, (t.m_next = this.m_bodyList) && (this.m_bodyList.m_prev = t), this.m_bodyList = t, ++this.m_bodyCount, t)
            }, I.prototype.DestroyBody = function(t) {
                if (1 != this.IsLocked()) {
                    for (var i = t.m_jointList; i;) {
                        var o = i;
                        i = i.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(o.joint), this.DestroyJoint(o.joint)
                    }
                    for (i = t.m_controllerList; i;) o = i, i = i.nextController, o.controller.RemoveBody(t);
                    for (i = t.m_contactList; i;) o = i, i = i.next, this.m_contactManager.Destroy(o.contact);
                    for (t.m_contactList = null, i = t.m_fixtureList; i;) o = i, i = i.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(o), o.DestroyProxy(this.m_contactManager.m_broadPhase), o.Destroy();
                    t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount
                }
            }, I.prototype.CreateJoint = function(t) {
                var i = F.Create(t, null);
                i.m_prev = null, (i.m_next = this.m_jointList) && (this.m_jointList.m_prev = i), this.m_jointList = i, ++this.m_jointCount, i.m_edgeA.joint = i, i.m_edgeA.other = i.m_bodyB, i.m_edgeA.prev = null, (i.m_edgeA.next = i.m_bodyA.m_jointList) && (i.m_bodyA.m_jointList.prev = i.m_edgeA), i.m_bodyA.m_jointList = i.m_edgeA, i.m_edgeB.joint = i, i.m_edgeB.other = i.m_bodyA, i.m_edgeB.prev = null, (i.m_edgeB.next = i.m_bodyB.m_jointList) && (i.m_bodyB.m_jointList.prev = i.m_edgeB), i.m_bodyB.m_jointList = i.m_edgeB;
                var o = t.bodyA,
                    e = t.bodyB;
                if (0 == t.collideConnected)
                    for (t = e.GetContactList(); t;) t.other == o && t.contact.FlagForFiltering(), t = t.next;
                return i
            }, I.prototype.DestroyJoint = function(t) {
                var i = t.m_collideConnected;
                t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t == this.m_jointList && (this.m_jointList = t.m_next);
                var o = t.m_bodyA,
                    e = t.m_bodyB;
                if (o.SetAwake(!0), e.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA == o.m_jointList && (o.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB == e.m_jointList && (e.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, F.Destroy(t, null), --this.m_jointCount, 0 == i)
                    for (t = e.GetContactList(); t;) t.other == o && t.contact.FlagForFiltering(), t = t.next
            }, I.prototype.AddController = function(t) {
                return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList = t, t.m_world = this, this.m_controllerCount++, t
            }, I.prototype.RemoveController = function(t) {
                t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList == t && (this.m_controllerList = t.m_next), this.m_controllerCount--
            }, I.prototype.CreateController = function(t) {
                if (t.m_world != this) throw Error("Controller can only be a member of one world");
                return t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t.m_world = this, t
            }, I.prototype.DestroyController = function(t) {
                t.Clear(), t.m_next && (t.m_next.m_prev = t.m_prev), t.m_prev && (t.m_prev.m_next = t.m_next), t == this.m_controllerList && (this.m_controllerList = t.m_next), --this.m_controllerCount
            }, I.prototype.SetWarmStarting = function(t) {
                I.m_warmStarting = t
            }, I.prototype.SetContinuousPhysics = function(t) {
                I.m_continuousPhysics = t
            }, I.prototype.GetBodyCount = function() {
                return this.m_bodyCount
            }, I.prototype.GetJointCount = function() {
                return this.m_jointCount
            }, I.prototype.GetContactCount = function() {
                return this.m_contactCount
            }, I.prototype.SetGravity = function(t) {
                this.m_gravity = t
            }, I.prototype.GetGravity = function() {
                return this.m_gravity
            }, I.prototype.GetGroundBody = function() {
                return this.m_groundBody
            }, I.prototype.Step = function(t, i, o) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.m_flags & I.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~I.e_newFixture), this.m_flags |= I.e_locked;
                var e = I.s_timestep2;
                e.dt = t, e.velocityIterations = i, e.positionIterations = o, e.inv_dt = t > 0 ? 1 / t : 0, e.dtRatio = this.m_inv_dt0 * t, e.warmStarting = I.m_warmStarting, this.m_contactManager.Collide(), e.dt > 0 && this.Solve(e), I.m_continuousPhysics && e.dt > 0 && this.SolveTOI(e), e.dt > 0 && (this.m_inv_dt0 = e.inv_dt), this.m_flags &= ~I.e_locked
            }, I.prototype.ClearForces = function() {
                for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0
            }, I.prototype.DrawDebugData = function() {
                if (null != this.m_debugDraw) {
                    this.m_debugDraw.m_sprite.graphics.clear();
                    var t, i, o, e, r = this.m_debugDraw.GetFlags();
                    new n, new n, new n, new a, new a, e = [new n, new n, new n, new n];
                    var l = new s(0, 0, 0);
                    if (r & A.e_shapeBit)
                        for (t = this.m_bodyList; t; t = t.m_next)
                            for (e = t.m_xf, i = t.GetFixtureList(); i; i = i.m_next) o = i.GetShape(), 0 == t.IsActive() ? l.Set(.5, .5, .3) : t.GetType() == f.b2_staticBody ? l.Set(.5, .9, .5) : t.GetType() == f.b2_kinematicBody ? l.Set(.5, .5, .9) : 0 == t.IsAwake() ? l.Set(.6, .6, .6) : l.Set(.9, .7, .7), this.DrawShape(o, e, l);
                    if (r & A.e_jointBit)
                        for (t = this.m_jointList; t; t = t.m_next) this.DrawJoint(t);
                    if (r & A.e_controllerBit)
                        for (t = this.m_controllerList; t; t = t.m_next) t.Draw(this.m_debugDraw);
                    if (r & A.e_pairBit)
                        for (l.Set(.3, .9, .9), t = this.m_contactManager.m_contactList; t; t = t.GetNext()) o = t.GetFixtureA(), i = t.GetFixtureB(), o = o.GetAABB().GetCenter(), i = i.GetAABB().GetCenter(), this.m_debugDraw.DrawSegment(o, i, l);
                    if (r & A.e_aabbBit)
                        for (o = this.m_contactManager.m_broadPhase, e = [new n, new n, new n, new n], t = this.m_bodyList; t; t = t.GetNext())
                            if (0 != t.IsActive())
                                for (i = t.GetFixtureList(); i; i = i.GetNext()) {
                                    var m = o.GetFatAABB(i.m_proxy);
                                    e[0].Set(m.lowerBound.x, m.lowerBound.y), e[1].Set(m.upperBound.x, m.lowerBound.y), e[2].Set(m.upperBound.x, m.upperBound.y), e[3].Set(m.lowerBound.x, m.upperBound.y), this.m_debugDraw.DrawPolygon(e, 4, l)
                                }
                    if (r & A.e_centerOfMassBit)
                        for (t = this.m_bodyList; t; t = t.m_next)(e = I.s_xf).R = t.m_xf.R, e.position = t.GetWorldCenter(), this.m_debugDraw.DrawTransform(e)
                }
            }, I.prototype.QueryAABB = function(t, i) {
                var o = this.m_contactManager.m_broadPhase;
                o.Query(function(i) {
                    return t(o.GetUserData(i))
                }, i)
            }, I.prototype.QueryShape = function(t, i, o) {
                void 0 === o && (o = null), null == o && (o = new e).SetIdentity();
                var n = this.m_contactManager.m_broadPhase,
                    s = new a;
                i.ComputeAABB(s, o), n.Query(function(e) {
                    return e = n.GetUserData(e) instanceof B ? n.GetUserData(e) : null, !x.TestOverlap(i, o, e.GetShape(), e.GetBody().GetTransform()) || t(e)
                }, s)
            }, I.prototype.QueryPoint = function(t, i) {
                var o = this.m_contactManager.m_broadPhase,
                    e = new a;
                e.lowerBound.Set(i.x - r.b2_linearSlop, i.y - r.b2_linearSlop), e.upperBound.Set(i.x + r.b2_linearSlop, i.y + r.b2_linearSlop), o.Query(function(e) {
                    return !(e = o.GetUserData(e) instanceof B ? o.GetUserData(e) : null).TestPoint(i) || t(e)
                }, e)
            }, I.prototype.RayCast = function(t, i, o) {
                var e = this.m_contactManager.m_broadPhase,
                    s = new h,
                    r = new c(i, o);
                e.RayCast(function(r, a) {
                    var l = e.GetUserData(a);
                    if ((l = l instanceof B ? l : null).RayCast(s, r)) {
                        var m = s.fraction,
                            c = new n((1 - m) * i.x + m * o.x, (1 - m) * i.y + m * o.y);
                        return t(l, c, s.normal, m)
                    }
                    return r.maxFraction
                }, r)
            }, I.prototype.RayCastOne = function(t, i) {
                var o;
                return this.RayCast(function(t, i, e, n) {
                    return void 0 === n && (n = 0), o = t, n
                }, t, i), o
            }, I.prototype.RayCastAll = function(t, i) {
                var o = new j;
                return this.RayCast(function(t) {
                    return o[o.length] = t, 1
                }, t, i), o
            }, I.prototype.GetBodyList = function() {
                return this.m_bodyList
            }, I.prototype.GetJointList = function() {
                return this.m_jointList
            }, I.prototype.GetContactList = function() {
                return this.m_contactList
            }, I.prototype.IsLocked = function() {
                return (this.m_flags & I.e_locked) > 0
            }, I.prototype.Solve = function(t) {
                for (var i, o = this.m_controllerList; o; o = o.m_next) o.Step(t);
                for ((o = this.m_island).Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~f.e_islandFlag;
                for (var e = this.m_contactList; e; e = e.m_next) e.m_flags &= ~G.e_islandFlag;
                for (e = this.m_jointList; e; e = e.m_next) e.m_islandFlag = !1;
                parseInt(this.m_bodyCount), e = this.s_stack;
                for (var n = this.m_bodyList; n; n = n.m_next)
                    if (!(n.m_flags & f.e_islandFlag) && 0 != n.IsAwake() && 0 != n.IsActive() && n.GetType() != f.b2_staticBody) {
                        o.Clear();
                        var s = 0;
                        for (e[s++] = n, n.m_flags |= f.e_islandFlag; s > 0;)
                            if (i = e[--s], o.AddBody(i), 0 == i.IsAwake() && i.SetAwake(!0), i.GetType() != f.b2_staticBody) {
                                for (var r, a = i.m_contactList; a; a = a.next) a.contact.m_flags & G.e_islandFlag || 1 != a.contact.IsSensor() && 0 != a.contact.IsEnabled() && 0 != a.contact.IsTouching() && (o.AddContact(a.contact), a.contact.m_flags |= G.e_islandFlag, (r = a.other).m_flags & f.e_islandFlag || (e[s++] = r, r.m_flags |= f.e_islandFlag));
                                for (i = i.m_jointList; i; i = i.next) 1 != i.joint.m_islandFlag && 0 != (r = i.other).IsActive() && (o.AddJoint(i.joint), i.joint.m_islandFlag = !0, r.m_flags & f.e_islandFlag || (e[s++] = r, r.m_flags |= f.e_islandFlag))
                            } for (o.Solve(t, this.m_gravity, this.m_allowSleep), s = 0; s < o.m_bodyCount; ++s)(i = o.m_bodies[s]).GetType() == f.b2_staticBody && (i.m_flags &= ~f.e_islandFlag)
                    } for (s = 0; s < e.length && e[s]; ++s) e[s] = null;
                for (i = this.m_bodyList; i; i = i.m_next) 0 == i.IsAwake() || 0 == i.IsActive() || i.GetType() != f.b2_staticBody && i.SynchronizeFixtures();
                this.m_contactManager.FindNewContacts()
            }, I.prototype.SolveTOI = function(t) {
                var i, o, e, n = this.m_island;
                n.Initialize(this.m_bodyCount, r.b2_maxTOIContactsPerIsland, r.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
                var s = I.s_queue;
                for (i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~f.e_islandFlag, i.m_sweep.t0 = 0;
                for (e = this.m_contactList; e; e = e.m_next) e.m_flags &= ~(G.e_toiFlag | G.e_islandFlag);
                for (e = this.m_jointList; e; e = e.m_next) e.m_islandFlag = !1;
                for (;;) {
                    var a = null,
                        l = 1;
                    for (e = this.m_contactList; e; e = e.m_next)
                        if (1 != e.IsSensor() && 0 != e.IsEnabled() && 0 != e.IsContinuous()) {
                            if (i = 1, e.m_flags & G.e_toiFlag) i = e.m_toi;
                            else {
                                if (i = e.m_fixtureA, o = e.m_fixtureB, i = i.m_body, o = o.m_body, !(i.GetType() == f.b2_dynamicBody && 0 != i.IsAwake() || o.GetType() == f.b2_dynamicBody && 0 != o.IsAwake())) continue;
                                var m = i.m_sweep.t0;
                                i.m_sweep.t0 < o.m_sweep.t0 ? (m = o.m_sweep.t0, i.m_sweep.Advance(m)) : o.m_sweep.t0 < i.m_sweep.t0 && (m = i.m_sweep.t0, o.m_sweep.Advance(m)), i = e.ComputeTOI(i.m_sweep, o.m_sweep), r.b2Assert(0 <= i && i <= 1), i > 0 && i < 1 && (i = (1 - i) * m + i) > 1 && (i = 1), e.m_toi = i, e.m_flags |= G.e_toiFlag
                            }
                            Number.MIN_VALUE < i && i < l && (a = e, l = i)
                        } if (null == a || 1 - 100 * Number.MIN_VALUE < l) break;
                    if (i = a.m_fixtureA, o = a.m_fixtureB, i = i.m_body, o = o.m_body, I.s_backupA.Set(i.m_sweep), I.s_backupB.Set(o.m_sweep), i.Advance(l), o.Advance(l), a.Update(this.m_contactManager.m_contactListener), a.m_flags &= ~G.e_toiFlag, 1 == a.IsSensor() || 0 == a.IsEnabled()) i.m_sweep.Set(I.s_backupA), o.m_sweep.Set(I.s_backupB), i.SynchronizeTransform(), o.SynchronizeTransform();
                    else if (0 != a.IsTouching()) {
                        for ((i = i).GetType() != f.b2_dynamicBody && (i = o), n.Clear(), a = e = 0, s[e + a++] = i, i.m_flags |= f.e_islandFlag; a > 0;)
                            if (i = s[e++], --a, n.AddBody(i), 0 == i.IsAwake() && i.SetAwake(!0), i.GetType() == f.b2_dynamicBody) {
                                for (o = i.m_contactList; o && n.m_contactCount != n.m_contactCapacity; o = o.next) o.contact.m_flags & G.e_islandFlag || 1 != o.contact.IsSensor() && 0 != o.contact.IsEnabled() && 0 != o.contact.IsTouching() && (n.AddContact(o.contact), o.contact.m_flags |= G.e_islandFlag, (m = o.other).m_flags & f.e_islandFlag || (m.GetType() != f.b2_staticBody && (m.Advance(l), m.SetAwake(!0)), s[e + a] = m, ++a, m.m_flags |= f.e_islandFlag));
                                for (i = i.m_jointList; i; i = i.next) n.m_jointCount != n.m_jointCapacity && 1 != i.joint.m_islandFlag && 0 != (m = i.other).IsActive() && (n.AddJoint(i.joint), i.joint.m_islandFlag = !0, m.m_flags & f.e_islandFlag || (m.GetType() != f.b2_staticBody && (m.Advance(l), m.SetAwake(!0)), s[e + a] = m, ++a, m.m_flags |= f.e_islandFlag))
                            } for ((e = I.s_timestep).warmStarting = !1, e.dt = (1 - l) * t.dt, e.inv_dt = 1 / e.dt, e.dtRatio = 0, e.velocityIterations = t.velocityIterations, e.positionIterations = t.positionIterations, n.SolveTOI(e), l = l = 0; l < n.m_bodyCount; ++l)
                            if ((i = n.m_bodies[l]).m_flags &= ~f.e_islandFlag, 0 != i.IsAwake() && i.GetType() == f.b2_dynamicBody)
                                for (i.SynchronizeFixtures(), o = i.m_contactList; o; o = o.next) o.contact.m_flags &= ~G.e_toiFlag;
                        for (l = 0; l < n.m_contactCount; ++l)(e = n.m_contacts[l]).m_flags &= ~(G.e_toiFlag | G.e_islandFlag);
                        for (l = 0; l < n.m_jointCount; ++l)(e = n.m_joints[l]).m_islandFlag = !1;
                        this.m_contactManager.FindNewContacts()
                    }
                }
            }, I.prototype.DrawJoint = function(t) {
                var i = t.GetBodyA(),
                    o = t.GetBodyB(),
                    e = i.m_xf.position,
                    n = o.m_xf.position,
                    s = t.GetAnchorA(),
                    r = t.GetAnchorB(),
                    a = I.s_jointColor;
                switch (t.m_type) {
                    case F.e_distanceJoint:
                        this.m_debugDraw.DrawSegment(s, r, a);
                        break;
                    case F.e_pulleyJoint:
                        t = (i = t instanceof P ? t : null).GetGroundAnchorA(), i = i.GetGroundAnchorB(), this.m_debugDraw.DrawSegment(t, s, a), this.m_debugDraw.DrawSegment(i, r, a), this.m_debugDraw.DrawSegment(t, i, a);
                        break;
                    case F.e_mouseJoint:
                        this.m_debugDraw.DrawSegment(s, r, a);
                        break;
                    default:
                        i != this.m_groundBody && this.m_debugDraw.DrawSegment(e, s, a), this.m_debugDraw.DrawSegment(s, r, a), o != this.m_groundBody && this.m_debugDraw.DrawSegment(n, r, a)
                }
            }, I.prototype.DrawShape = function(i, o, e) {
                switch (i.m_type) {
                    case x.e_circleShape:
                        var n = i instanceof _ ? i : null;
                        this.m_debugDraw.DrawSolidCircle(t.MulX(o, n.m_p), n.m_radius, o.R.col1, e);
                        break;
                    case x.e_polygonShape:
                        n = 0, n = i instanceof u ? i : null, i = parseInt(n.GetVertexCount());
                        var s = n.GetVertices(),
                            r = new j(i);
                        for (n = 0; n < i; ++n) r[n] = t.MulX(o, s[n]);
                        this.m_debugDraw.DrawSolidPolygon(r, i, e);
                        break;
                    case x.e_edgeShape:
                        n = i instanceof p ? i : null, this.m_debugDraw.DrawSegment(t.MulX(o, n.GetVertex1()), t.MulX(o, n.GetVertex2()), e)
                }
            }, o.postDefs.push(function() {
                o.Dynamics.b2World.s_timestep2 = new D, o.Dynamics.b2World.s_xf = new e, o.Dynamics.b2World.s_backupA = new i, o.Dynamics.b2World.s_backupB = new i, o.Dynamics.b2World.s_timestep = new D, o.Dynamics.b2World.s_queue = new j, o.Dynamics.b2World.s_jointColor = new s(.5, .8, .8), o.Dynamics.b2World.e_newFixture = 1, o.Dynamics.b2World.e_locked = 2
            })
        }(), function() {
            var t = o.Collision.Shapes.b2CircleShape,
                i = o.Collision.Shapes.b2EdgeShape,
                e = o.Collision.Shapes.b2PolygonShape,
                n = o.Collision.Shapes.b2Shape,
                s = o.Dynamics.Contacts.b2CircleContact,
                r = o.Dynamics.Contacts.b2Contact,
                a = o.Dynamics.Contacts.b2ContactConstraint,
                l = o.Dynamics.Contacts.b2ContactConstraintPoint,
                m = o.Dynamics.Contacts.b2ContactEdge,
                c = o.Dynamics.Contacts.b2ContactFactory,
                h = o.Dynamics.Contacts.b2ContactRegister,
                _ = o.Dynamics.Contacts.b2ContactResult,
                p = o.Dynamics.Contacts.b2ContactSolver,
                y = o.Dynamics.Contacts.b2EdgeAndCircleContact,
                u = o.Dynamics.Contacts.b2NullContact,
                x = o.Dynamics.Contacts.b2PolyAndCircleContact,
                f = o.Dynamics.Contacts.b2PolyAndEdgeContact,
                d = o.Dynamics.Contacts.b2PolygonContact,
                b = o.Dynamics.Contacts.b2PositionSolverManifold,
                v = o.Dynamics.b2Body,
                C = o.Dynamics.b2TimeStep,
                w = o.Common.b2Settings,
                A = o.Common.Math.b2Mat22,
                g = o.Common.Math.b2Math,
                S = o.Common.Math.b2Vec2,
                B = o.Collision.b2Collision,
                M = o.Collision.b2ContactID,
                V = o.Collision.b2Manifold,
                D = o.Collision.b2TimeOfImpact,
                I = o.Collision.b2TOIInput,
                G = o.Collision.b2WorldManifold;
            o.inherit(s, o.Dynamics.Contacts.b2Contact), s.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, s.b2CircleContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, s.Create = function() {
                return new s
            }, s.Destroy = function() {}, s.prototype.Reset = function(t, i) {
                this.__super.Reset.call(this, t, i)
            }, s.prototype.Evaluate = function() {
                var i = this.m_fixtureA.GetBody(),
                    o = this.m_fixtureB.GetBody();
                B.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof t ? this.m_fixtureA.GetShape() : null, i.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, o.m_xf)
            }, r.b2Contact = function() {
                this.m_nodeA = new m, this.m_nodeB = new m, this.m_manifold = new V, this.m_oldManifold = new V
            }, r.prototype.GetManifold = function() {
                return this.m_manifold
            }, r.prototype.GetWorldManifold = function(t) {
                var i = this.m_fixtureA.GetBody(),
                    o = this.m_fixtureB.GetBody(),
                    e = this.m_fixtureA.GetShape(),
                    n = this.m_fixtureB.GetShape();
                t.Initialize(this.m_manifold, i.GetTransform(), e.m_radius, o.GetTransform(), n.m_radius)
            }, r.prototype.IsTouching = function() {
                return (this.m_flags & r.e_touchingFlag) == r.e_touchingFlag
            }, r.prototype.IsContinuous = function() {
                return (this.m_flags & r.e_continuousFlag) == r.e_continuousFlag
            }, r.prototype.SetSensor = function(t) {
                t ? this.m_flags |= r.e_sensorFlag : this.m_flags &= ~r.e_sensorFlag
            }, r.prototype.IsSensor = function() {
                return (this.m_flags & r.e_sensorFlag) == r.e_sensorFlag
            }, r.prototype.SetEnabled = function(t) {
                t ? this.m_flags |= r.e_enabledFlag : this.m_flags &= ~r.e_enabledFlag
            }, r.prototype.IsEnabled = function() {
                return (this.m_flags & r.e_enabledFlag) == r.e_enabledFlag
            }, r.prototype.GetNext = function() {
                return this.m_next
            }, r.prototype.GetFixtureA = function() {
                return this.m_fixtureA
            }, r.prototype.GetFixtureB = function() {
                return this.m_fixtureB
            }, r.prototype.FlagForFiltering = function() {
                this.m_flags |= r.e_filterFlag
            }, r.prototype.b2Contact = function() {}, r.prototype.Reset = function(t, i) {
                if (void 0 === t && (t = null), void 0 === i && (i = null), this.m_flags = r.e_enabledFlag, t && i) {
                    (t.IsSensor() || i.IsSensor()) && (this.m_flags |= r.e_sensorFlag);
                    var o = t.GetBody(),
                        e = i.GetBody();
                    (o.GetType() != v.b2_dynamicBody || o.IsBullet() || e.GetType() != v.b2_dynamicBody || e.IsBullet()) && (this.m_flags |= r.e_continuousFlag), this.m_fixtureA = t, this.m_fixtureB = i, this.m_manifold.m_pointCount = 0, this.m_next = this.m_prev = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null
                } else this.m_fixtureB = this.m_fixtureA = null
            }, r.prototype.Update = function(t) {
                var i = this.m_oldManifold;
                this.m_oldManifold = this.m_manifold, this.m_manifold = i, this.m_flags |= r.e_enabledFlag;
                var o = !1;
                i = (this.m_flags & r.e_touchingFlag) == r.e_touchingFlag;
                var e = this.m_fixtureA.m_body,
                    s = this.m_fixtureB.m_body,
                    a = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
                if (this.m_flags & r.e_sensorFlag) a && (o = this.m_fixtureA.GetShape(), a = this.m_fixtureB.GetShape(), e = e.GetTransform(), s = s.GetTransform(), o = n.TestOverlap(o, e, a, s)), this.m_manifold.m_pointCount = 0;
                else {
                    if (e.GetType() != v.b2_dynamicBody || e.IsBullet() || s.GetType() != v.b2_dynamicBody || s.IsBullet() ? this.m_flags |= r.e_continuousFlag : this.m_flags &= ~r.e_continuousFlag, a)
                        for (this.Evaluate(), o = this.m_manifold.m_pointCount > 0, a = 0; a < this.m_manifold.m_pointCount; ++a) {
                            var l = this.m_manifold.m_points[a];
                            l.m_normalImpulse = 0, l.m_tangentImpulse = 0;
                            for (var m = l.m_id, c = 0; c < this.m_oldManifold.m_pointCount; ++c) {
                                var h = this.m_oldManifold.m_points[c];
                                if (h.m_id.key == m.key) {
                                    l.m_normalImpulse = h.m_normalImpulse, l.m_tangentImpulse = h.m_tangentImpulse;
                                    break
                                }
                            }
                        } else this.m_manifold.m_pointCount = 0;
                    o != i && (e.SetAwake(!0), s.SetAwake(!0))
                }
                o ? this.m_flags |= r.e_touchingFlag : this.m_flags &= ~r.e_touchingFlag, 0 == i && 1 == o && t.BeginContact(this), 1 == i && 0 == o && t.EndContact(this), 0 == (this.m_flags & r.e_sensorFlag) && t.PreSolve(this, this.m_oldManifold)
            }, r.prototype.Evaluate = function() {}, r.prototype.ComputeTOI = function(t, i) {
                return r.s_input.proxyA.Set(this.m_fixtureA.GetShape()), r.s_input.proxyB.Set(this.m_fixtureB.GetShape()), r.s_input.sweepA = t, r.s_input.sweepB = i, r.s_input.tolerance = w.b2_linearSlop, D.TimeOfImpact(r.s_input)
            }, o.postDefs.push(function() {
                o.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, o.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, o.Dynamics.Contacts.b2Contact.e_islandFlag = 4, o.Dynamics.Contacts.b2Contact.e_toiFlag = 8, o.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, o.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, o.Dynamics.Contacts.b2Contact.e_filterFlag = 64, o.Dynamics.Contacts.b2Contact.s_input = new I
            }), a.b2ContactConstraint = function() {
                this.localPlaneNormal = new S, this.localPoint = new S, this.normal = new S, this.normalMass = new A, this.K = new A
            }, a.prototype.b2ContactConstraint = function() {
                this.points = new j(w.b2_maxManifoldPoints);
                for (var t = 0; t < w.b2_maxManifoldPoints; t++) this.points[t] = new l
            }, l.b2ContactConstraintPoint = function() {
                this.localPoint = new S, this.rA = new S, this.rB = new S
            }, m.b2ContactEdge = function() {}, c.b2ContactFactory = function() {}, c.prototype.b2ContactFactory = function(t) {
                this.m_allocator = t, this.InitializeRegisters()
            }, c.prototype.AddType = function(t, i, o, e) {
                void 0 === o && (o = 0), void 0 === e && (e = 0), this.m_registers[o][e].createFcn = t, this.m_registers[o][e].destroyFcn = i, this.m_registers[o][e].primary = !0, o != e && (this.m_registers[e][o].createFcn = t, this.m_registers[e][o].destroyFcn = i, this.m_registers[e][o].primary = !1)
            }, c.prototype.InitializeRegisters = function() {
                this.m_registers = new j(n.e_shapeTypeCount);
                for (var t = 0; t < n.e_shapeTypeCount; t++) {
                    this.m_registers[t] = new j(n.e_shapeTypeCount);
                    for (var i = 0; i < n.e_shapeTypeCount; i++) this.m_registers[t][i] = new h
                }
                this.AddType(s.Create, s.Destroy, n.e_circleShape, n.e_circleShape), this.AddType(x.Create, x.Destroy, n.e_polygonShape, n.e_circleShape), this.AddType(d.Create, d.Destroy, n.e_polygonShape, n.e_polygonShape), this.AddType(y.Create, y.Destroy, n.e_edgeShape, n.e_circleShape), this.AddType(f.Create, f.Destroy, n.e_polygonShape, n.e_edgeShape)
            }, c.prototype.Create = function(t, i) {
                var o = parseInt(t.GetType()),
                    e = parseInt(i.GetType());
                return (o = this.m_registers[o][e]).pool ? (e = o.pool, o.pool = e.m_next, o.poolCount--, e.Reset(t, i), e) : null != (e = o.createFcn) ? (o.primary ? (e = e(this.m_allocator)).Reset(t, i) : (e = e(this.m_allocator)).Reset(i, t), e) : null
            }, c.prototype.Destroy = function(t) {
                t.m_manifold.m_pointCount > 0 && (t.m_fixtureA.m_body.SetAwake(!0), t.m_fixtureB.m_body.SetAwake(!0));
                var i = parseInt(t.m_fixtureA.GetType()),
                    o = parseInt(t.m_fixtureB.GetType());
                (i = this.m_registers[i][o]).poolCount++, t.m_next = i.pool, i.pool = t, (i = i.destroyFcn)(t, this.m_allocator)
            }, h.b2ContactRegister = function() {}, _.b2ContactResult = function() {
                this.position = new S, this.normal = new S, this.id = new M
            }, p.b2ContactSolver = function() {
                this.m_step = new C, this.m_constraints = new j
            }, p.prototype.b2ContactSolver = function() {}, p.prototype.Initialize = function(t, i, o, e) {
                var n;
                for (void 0 === o && (o = 0), this.m_step.Set(t), this.m_allocator = e, t = 0, this.m_constraintCount = o; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new a;
                for (t = 0; t < o; ++t) {
                    e = (n = i[t]).m_fixtureA;
                    var s = n.m_fixtureB,
                        r = e.m_shape.m_radius,
                        l = s.m_shape.m_radius,
                        m = e.m_body,
                        c = s.m_body,
                        h = n.GetManifold(),
                        _ = w.b2MixFriction(e.GetFriction(), s.GetFriction()),
                        y = w.b2MixRestitution(e.GetRestitution(), s.GetRestitution()),
                        u = m.m_linearVelocity.x,
                        x = m.m_linearVelocity.y,
                        f = c.m_linearVelocity.x,
                        d = c.m_linearVelocity.y,
                        b = m.m_angularVelocity,
                        v = c.m_angularVelocity;
                    for (w.b2Assert(h.m_pointCount > 0), p.s_worldManifold.Initialize(h, m.m_xf, r, c.m_xf, l), s = p.s_worldManifold.m_normal.x, n = p.s_worldManifold.m_normal.y, (e = this.m_constraints[t]).bodyA = m, e.bodyB = c, e.manifold = h, e.normal.x = s, e.normal.y = n, e.pointCount = h.m_pointCount, e.friction = _, e.restitution = y, e.localPlaneNormal.x = h.m_localPlaneNormal.x, e.localPlaneNormal.y = h.m_localPlaneNormal.y, e.localPoint.x = h.m_localPoint.x, e.localPoint.y = h.m_localPoint.y, e.radius = r + l, e.type = h.m_type, r = 0; r < e.pointCount; ++r) {
                        _ = h.m_points[r], (l = e.points[r]).normalImpulse = _.m_normalImpulse, l.tangentImpulse = _.m_tangentImpulse, l.localPoint.SetV(_.m_localPoint), _ = l.rA.x = p.s_worldManifold.m_points[r].x - m.m_sweep.c.x, y = l.rA.y = p.s_worldManifold.m_points[r].y - m.m_sweep.c.y;
                        var C = l.rB.x = p.s_worldManifold.m_points[r].x - c.m_sweep.c.x,
                            A = l.rB.y = p.s_worldManifold.m_points[r].y - c.m_sweep.c.y,
                            g = _ * n - y * s,
                            S = C * n - A * s;
                        g *= g, S *= S, l.normalMass = 1 / (m.m_invMass + c.m_invMass + m.m_invI * g + c.m_invI * S);
                        var B = m.m_mass * m.m_invMass + c.m_mass * c.m_invMass;
                        B += m.m_mass * m.m_invI * g + c.m_mass * c.m_invI * S, l.equalizedMass = 1 / B, g = _ * (B = -s) - y * (S = n), S = C * B - A * S, g *= g, S *= S, l.tangentMass = 1 / (m.m_invMass + c.m_invMass + m.m_invI * g + c.m_invI * S), l.velocityBias = 0, (_ = e.normal.x * (f + -v * A - u - -b * y) + e.normal.y * (d + v * C - x - b * _)) < -w.b2_velocityThreshold && (l.velocityBias += -e.restitution * _)
                    }
                    2 == e.pointCount && (d = e.points[0], f = e.points[1], h = m.m_invMass, m = m.m_invI, u = c.m_invMass, c = c.m_invI, x = d.rA.x * n - d.rA.y * s, d = d.rB.x * n - d.rB.y * s, b = f.rA.x * n - f.rA.y * s, f = f.rB.x * n - f.rB.y * s, (s = h + u + m * x * x + c * d * d) * s < 100 * (s * (n = h + u + m * b * b + c * f * f) - (c = h + u + m * x * b + c * d * f) * c) ? (e.K.col1.Set(s, c), e.K.col2.Set(c, n), e.K.GetInverse(e.normalMass)) : e.pointCount = 1)
                }
            }, p.prototype.InitVelocityConstraints = function(t) {
                for (var i = 0; i < this.m_constraintCount; ++i) {
                    var o = this.m_constraints[i],
                        e = o.bodyA,
                        n = o.bodyB,
                        s = e.m_invMass,
                        r = e.m_invI,
                        a = n.m_invMass,
                        l = n.m_invI,
                        m = o.normal.x,
                        c = o.normal.y,
                        h = c,
                        _ = -m,
                        p = 0,
                        y = 0;
                    if (t.warmStarting)
                        for (y = o.pointCount, p = 0; p < y; ++p) {
                            var u = o.points[p];
                            u.normalImpulse *= t.dtRatio, u.tangentImpulse *= t.dtRatio;
                            var x = u.normalImpulse * m + u.tangentImpulse * h,
                                f = u.normalImpulse * c + u.tangentImpulse * _;
                            e.m_angularVelocity -= r * (u.rA.x * f - u.rA.y * x), e.m_linearVelocity.x -= s * x, e.m_linearVelocity.y -= s * f, n.m_angularVelocity += l * (u.rB.x * f - u.rB.y * x), n.m_linearVelocity.x += a * x, n.m_linearVelocity.y += a * f
                        } else
                            for (y = o.pointCount, p = 0; p < y; ++p)(e = o.points[p]).normalImpulse = 0, e.tangentImpulse = 0
                }
            }, p.prototype.SolveVelocityConstraints = function() {
                for (var t, i, o = 0, e = 0, n = 0, s = 0, r = n = n = e = e = 0, a = e = e = 0, l = e = s = 0, m = 0, c = 0; c < this.m_constraintCount; ++c) {
                    var h = (s = this.m_constraints[c]).bodyA,
                        _ = s.bodyB,
                        p = h.m_angularVelocity,
                        y = _.m_angularVelocity,
                        u = h.m_linearVelocity,
                        x = _.m_linearVelocity,
                        f = h.m_invMass,
                        d = h.m_invI,
                        b = _.m_invMass,
                        v = _.m_invI;
                    l = s.normal.x;
                    var C = m = s.normal.y;
                    for (i = -l, a = s.friction, o = 0; o < s.pointCount; o++) t = s.points[o], e = (e = x.x - y * t.rB.y - u.x + p * t.rA.y) * C + (n = x.y + y * t.rB.x - u.y - p * t.rA.x) * i, e = t.tangentMass * -e, n = a * t.normalImpulse, r = (e = (n = g.Clamp(t.tangentImpulse + e, -n, n)) - t.tangentImpulse) * C, e *= i, u.x -= f * r, u.y -= f * e, p -= d * (t.rA.x * e - t.rA.y * r), x.x += b * r, x.y += b * e, y += v * (t.rB.x * e - t.rB.y * r), t.tangentImpulse = n;
                    if (parseInt(s.pointCount), 1 == s.pointCount) t = s.points[0], s = (e = x.x + -y * t.rB.y - u.x - -p * t.rA.y) * l + (n = x.y + y * t.rB.x - u.y - p * t.rA.x) * m, e = -t.normalMass * (s - t.velocityBias), r = (e = (n = (n = t.normalImpulse + e) > 0 ? n : 0) - t.normalImpulse) * l, e *= m, u.x -= f * r, u.y -= f * e, p -= d * (t.rA.x * e - t.rA.y * r), x.x += b * r, x.y += b * e, y += v * (t.rB.x * e - t.rB.y * r), t.normalImpulse = n;
                    else {
                        t = s.points[0], o = s.points[1], e = t.normalImpulse, a = o.normalImpulse;
                        var w = (x.x - y * t.rB.y - u.x + p * t.rA.y) * l + (x.y + y * t.rB.x - u.y - p * t.rA.x) * m,
                            A = (x.x - y * o.rB.y - u.x + p * o.rA.y) * l + (x.y + y * o.rB.x - u.y - p * o.rA.x) * m;
                        for (n = w - t.velocityBias, r = A - o.velocityBias, n -= (i = s.K).col1.x * e + i.col2.x * a, r -= i.col1.y * e + i.col2.y * a;;) {
                            if (C = -((i = s.normalMass).col1.x * n + i.col2.x * r), i = -(i.col1.y * n + i.col2.y * r), C >= 0 && i >= 0) {
                                s = (e = C - e) * l, e *= m, l *= a = i - a, m *= a, u.x -= f * (s + l), u.y -= f * (e + m), p -= d * (t.rA.x * e - t.rA.y * s + o.rA.x * m - o.rA.y * l), x.x += b * (s + l), x.y += b * (e + m), y += v * (t.rB.x * e - t.rB.y * s + o.rB.x * m - o.rB.y * l), t.normalImpulse = C, o.normalImpulse = i;
                                break
                            }
                            if (C = -t.normalMass * n, i = 0, A = s.K.col1.y * C + r, C >= 0 && A >= 0) {
                                s = (e = C - e) * l, e *= m, l *= a = i - a, m *= a, u.x -= f * (s + l), u.y -= f * (e + m), p -= d * (t.rA.x * e - t.rA.y * s + o.rA.x * m - o.rA.y * l), x.x += b * (s + l), x.y += b * (e + m), y += v * (t.rB.x * e - t.rB.y * s + o.rB.x * m - o.rB.y * l), t.normalImpulse = C, o.normalImpulse = i;
                                break
                            }
                            if (C = 0, i = -o.normalMass * r, w = s.K.col2.x * i + n, i >= 0 && w >= 0) {
                                s = (e = C - e) * l, e *= m, l *= a = i - a, m *= a, u.x -= f * (s + l), u.y -= f * (e + m), p -= d * (t.rA.x * e - t.rA.y * s + o.rA.x * m - o.rA.y * l), x.x += b * (s + l), x.y += b * (e + m), y += v * (t.rB.x * e - t.rB.y * s + o.rB.x * m - o.rB.y * l), t.normalImpulse = C, o.normalImpulse = i;
                                break
                            }
                            if (i = C = 0, A = r, (w = n) >= 0 && A >= 0) {
                                s = (e = C - e) * l, e *= m, l *= a = i - a, m *= a, u.x -= f * (s + l), u.y -= f * (e + m), p -= d * (t.rA.x * e - t.rA.y * s + o.rA.x * m - o.rA.y * l), x.x += b * (s + l), x.y += b * (e + m), y += v * (t.rB.x * e - t.rB.y * s + o.rB.x * m - o.rB.y * l), t.normalImpulse = C, o.normalImpulse = i;
                                break
                            }
                            break
                        }
                    }
                    h.m_angularVelocity = p, _.m_angularVelocity = y
                }
            }, p.prototype.FinalizeVelocityConstraints = function() {
                for (var t = 0; t < this.m_constraintCount; ++t)
                    for (var i = this.m_constraints[t], o = i.manifold, e = 0; e < i.pointCount; ++e) {
                        var n = o.m_points[e],
                            s = i.points[e];
                        n.m_normalImpulse = s.normalImpulse, n.m_tangentImpulse = s.tangentImpulse
                    }
            }, p.prototype.SolvePositionConstraints = function(t) {
                void 0 === t && (t = 0);
                for (var i = 0, o = 0; o < this.m_constraintCount; o++) {
                    var e = this.m_constraints[o],
                        n = e.bodyA,
                        s = e.bodyB,
                        r = n.m_mass * n.m_invMass,
                        a = n.m_mass * n.m_invI,
                        l = s.m_mass * s.m_invMass,
                        m = s.m_mass * s.m_invI;
                    p.s_psm.Initialize(e);
                    for (var c = p.s_psm.m_normal, h = 0; h < e.pointCount; h++) {
                        var _ = e.points[h],
                            y = p.s_psm.m_points[h],
                            u = p.s_psm.m_separations[h],
                            x = y.x - n.m_sweep.c.x,
                            f = y.y - n.m_sweep.c.y,
                            d = y.x - s.m_sweep.c.x;
                        y = y.y - s.m_sweep.c.y, i = i < u ? i : u, u = g.Clamp(t * (u + w.b2_linearSlop), -w.b2_maxLinearCorrection, 0), _ = (u = -_.equalizedMass * u) * c.x, u *= c.y, n.m_sweep.c.x -= r * _, n.m_sweep.c.y -= r * u, n.m_sweep.a -= a * (x * u - f * _), n.SynchronizeTransform(), s.m_sweep.c.x += l * _, s.m_sweep.c.y += l * u, s.m_sweep.a += m * (d * u - y * _), s.SynchronizeTransform()
                    }
                }
                return i > -1.5 * w.b2_linearSlop
            }, o.postDefs.push(function() {
                o.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new G, o.Dynamics.Contacts.b2ContactSolver.s_psm = new b
            }), o.inherit(y, o.Dynamics.Contacts.b2Contact), y.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, y.b2EdgeAndCircleContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, y.Create = function() {
                return new y
            }, y.Destroy = function() {}, y.prototype.Reset = function(t, i) {
                this.__super.Reset.call(this, t, i)
            }, y.prototype.Evaluate = function() {
                var o = this.m_fixtureA.GetBody(),
                    e = this.m_fixtureB.GetBody();
                this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof i ? this.m_fixtureA.GetShape() : null, o.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, e.m_xf)
            }, y.prototype.b2CollideEdgeAndCircle = function() {}, o.inherit(u, o.Dynamics.Contacts.b2Contact), u.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, u.b2NullContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, u.prototype.b2NullContact = function() {
                this.__super.b2Contact.call(this)
            }, u.prototype.Evaluate = function() {}, o.inherit(x, o.Dynamics.Contacts.b2Contact), x.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, x.b2PolyAndCircleContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, x.Create = function() {
                return new x
            }, x.Destroy = function() {}, x.prototype.Reset = function(t, i) {
                this.__super.Reset.call(this, t, i), w.b2Assert(t.GetType() == n.e_polygonShape), w.b2Assert(i.GetType() == n.e_circleShape)
            }, x.prototype.Evaluate = function() {
                var i = this.m_fixtureA.m_body,
                    o = this.m_fixtureB.m_body;
                B.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, i.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, o.m_xf)
            }, o.inherit(f, o.Dynamics.Contacts.b2Contact), f.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, f.b2PolyAndEdgeContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, f.Create = function() {
                return new f
            }, f.Destroy = function() {}, f.prototype.Reset = function(t, i) {
                this.__super.Reset.call(this, t, i), w.b2Assert(t.GetType() == n.e_polygonShape), w.b2Assert(i.GetType() == n.e_edgeShape)
            }, f.prototype.Evaluate = function() {
                var t = this.m_fixtureA.GetBody(),
                    o = this.m_fixtureB.GetBody();
                this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof i ? this.m_fixtureB.GetShape() : null, o.m_xf)
            }, f.prototype.b2CollidePolyAndEdge = function() {}, o.inherit(d, o.Dynamics.Contacts.b2Contact), d.prototype.__super = o.Dynamics.Contacts.b2Contact.prototype, d.b2PolygonContact = function() {
                o.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
            }, d.Create = function() {
                return new d
            }, d.Destroy = function() {}, d.prototype.Reset = function(t, i) {
                this.__super.Reset.call(this, t, i)
            }, d.prototype.Evaluate = function() {
                var t = this.m_fixtureA.GetBody(),
                    i = this.m_fixtureB.GetBody();
                B.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, t.m_xf, this.m_fixtureB.GetShape() instanceof e ? this.m_fixtureB.GetShape() : null, i.m_xf)
            }, b.b2PositionSolverManifold = function() {}, b.prototype.b2PositionSolverManifold = function() {
                this.m_normal = new S, this.m_separations = new O(w.b2_maxManifoldPoints), this.m_points = new j(w.b2_maxManifoldPoints);
                for (var t = 0; t < w.b2_maxManifoldPoints; t++) this.m_points[t] = new S
            }, b.prototype.Initialize = function(t) {
                w.b2Assert(t.pointCount > 0);
                var i, o = 0,
                    e = 0,
                    n = 0,
                    s = 0,
                    r = 0;
                switch (t.type) {
                    case V.e_circles:
                        i = t.bodyA.m_xf.R, n = t.localPoint, o = t.bodyA.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), e = t.bodyA.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y), i = t.bodyB.m_xf.R, n = t.points[0].localPoint, s = t.bodyB.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), i = t.bodyB.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y);
                        var a = (n = s - o) * n + (r = i - e) * r;
                        a > Number.MIN_VALUE * Number.MIN_VALUE ? (a = Math.sqrt(a), this.m_normal.x = n / a, this.m_normal.y = r / a) : (this.m_normal.x = 1, this.m_normal.y = 0), this.m_points[0].x = .5 * (o + s), this.m_points[0].y = .5 * (e + i), this.m_separations[0] = n * this.m_normal.x + r * this.m_normal.y - t.radius;
                        break;
                    case V.e_faceA:
                        for (i = t.bodyA.m_xf.R, n = t.localPlaneNormal, this.m_normal.x = i.col1.x * n.x + i.col2.x * n.y, this.m_normal.y = i.col1.y * n.x + i.col2.y * n.y, i = t.bodyA.m_xf.R, n = t.localPoint, s = t.bodyA.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), r = t.bodyA.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y), i = t.bodyB.m_xf.R, o = 0; o < t.pointCount; ++o) n = t.points[o].localPoint, e = t.bodyB.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), n = t.bodyB.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y), this.m_separations[o] = (e - s) * this.m_normal.x + (n - r) * this.m_normal.y - t.radius, this.m_points[o].x = e, this.m_points[o].y = n;
                        break;
                    case V.e_faceB:
                        for (i = t.bodyB.m_xf.R, n = t.localPlaneNormal, this.m_normal.x = i.col1.x * n.x + i.col2.x * n.y, this.m_normal.y = i.col1.y * n.x + i.col2.y * n.y, i = t.bodyB.m_xf.R, n = t.localPoint, s = t.bodyB.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), r = t.bodyB.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y), i = t.bodyA.m_xf.R, o = 0; o < t.pointCount; ++o) n = t.points[o].localPoint, e = t.bodyA.m_xf.position.x + (i.col1.x * n.x + i.col2.x * n.y), n = t.bodyA.m_xf.position.y + (i.col1.y * n.x + i.col2.y * n.y), this.m_separations[o] = (e - s) * this.m_normal.x + (n - r) * this.m_normal.y - t.radius, this.m_points[o].Set(e, n);
                        this.m_normal.x *= -1, this.m_normal.y *= -1
                }
            }, o.postDefs.push(function() {
                o.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new S, o.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new S
            })
        }(), function() {
            var t = o.Common.Math.b2Mat22,
                i = o.Common.Math.b2Math,
                e = o.Common.Math.b2Vec2,
                n = o.Common.b2Color,
                s = o.Dynamics.Controllers.b2BuoyancyController,
                r = o.Dynamics.Controllers.b2ConstantAccelController,
                a = o.Dynamics.Controllers.b2ConstantForceController,
                l = o.Dynamics.Controllers.b2Controller,
                m = o.Dynamics.Controllers.b2ControllerEdge,
                c = o.Dynamics.Controllers.b2GravityController,
                h = o.Dynamics.Controllers.b2TensorDampingController;
            o.inherit(s, o.Dynamics.Controllers.b2Controller), s.prototype.__super = o.Dynamics.Controllers.b2Controller.prototype, s.b2BuoyancyController = function() {
                o.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new e(0, -1), this.density = this.offset = 0, this.velocity = new e(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = !1, this.useWorldGravity = !0, this.gravity = null
            }, s.prototype.Step = function() {
                if (this.m_bodyList) {
                    this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
                    for (var t = this.m_bodyList; t; t = t.nextBody) {
                        var i = t.body;
                        if (0 != i.IsAwake()) {
                            for (var o = new e, n = new e, s = 0, r = 0, a = i.GetFixtureList(); a; a = a.GetNext()) {
                                var l = new e,
                                    m = a.GetShape().ComputeSubmergedArea(this.normal, this.offset, i.GetTransform(), l);
                                s += m, o.x += m * l.x, o.y += m * l.y;
                                1, r += 1 * m, n.x += m * l.x * 1, n.y += m * l.y * 1
                            }
                            o.x /= s, o.y /= s, n.x /= r, n.y /= r, s < Number.MIN_VALUE || ((r = this.gravity.GetNegative()).Multiply(this.density * s), i.ApplyForce(r, n), (n = i.GetLinearVelocityFromWorldPoint(o)).Subtract(this.velocity), n.Multiply(-this.linearDrag * s), i.ApplyForce(n, o), i.ApplyTorque(-i.GetInertia() / i.GetMass() * s * i.GetAngularVelocity() * this.angularDrag))
                        }
                    }
                }
            }, s.prototype.Draw = function(t) {
                var i = new e,
                    o = new e;
                i.x = this.normal.x * this.offset + 1e3 * this.normal.y, i.y = this.normal.y * this.offset - 1e3 * this.normal.x, o.x = this.normal.x * this.offset - 1e3 * this.normal.y, o.y = this.normal.y * this.offset + 1e3 * this.normal.x;
                var s = new n(0, 0, 1);
                t.DrawSegment(i, o, s)
            }, o.inherit(r, o.Dynamics.Controllers.b2Controller), r.prototype.__super = o.Dynamics.Controllers.b2Controller.prototype, r.b2ConstantAccelController = function() {
                o.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new e(0, 0)
            }, r.prototype.Step = function(t) {
                t = new e(this.A.x * t.dt, this.A.y * t.dt);
                for (var i = this.m_bodyList; i; i = i.nextBody) {
                    var o = i.body;
                    o.IsAwake() && o.SetLinearVelocity(new e(o.GetLinearVelocity().x + t.x, o.GetLinearVelocity().y + t.y))
                }
            }, o.inherit(a, o.Dynamics.Controllers.b2Controller), a.prototype.__super = o.Dynamics.Controllers.b2Controller.prototype, a.b2ConstantForceController = function() {
                o.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new e(0, 0)
            }, a.prototype.Step = function() {
                for (var t = this.m_bodyList; t; t = t.nextBody) {
                    var i = t.body;
                    i.IsAwake() && i.ApplyForce(this.F, i.GetWorldCenter())
                }
            }, l.b2Controller = function() {}, l.prototype.Step = function() {}, l.prototype.Draw = function() {}, l.prototype.AddBody = function(t) {
                var i = new m;
                i.controller = this, i.body = t, i.nextBody = this.m_bodyList, i.prevBody = null, this.m_bodyList = i, i.nextBody && (i.nextBody.prevBody = i), this.m_bodyCount++, i.nextController = t.m_controllerList, i.prevController = null, t.m_controllerList = i, i.nextController && (i.nextController.prevController = i), t.m_controllerCount++
            }, l.prototype.RemoveBody = function(t) {
                for (var i = t.m_controllerList; i && i.controller != this;) i = i.nextController;
                i.prevBody && (i.prevBody.nextBody = i.nextBody), i.nextBody && (i.nextBody.prevBody = i.prevBody), i.nextController && (i.nextController.prevController = i.prevController), i.prevController && (i.prevController.nextController = i.nextController), this.m_bodyList == i && (this.m_bodyList = i.nextBody), t.m_controllerList == i && (t.m_controllerList = i.nextController), t.m_controllerCount--, this.m_bodyCount--
            }, l.prototype.Clear = function() {
                for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body)
            }, l.prototype.GetNext = function() {
                return this.m_next
            }, l.prototype.GetWorld = function() {
                return this.m_world
            }, l.prototype.GetBodyList = function() {
                return this.m_bodyList
            }, m.b2ControllerEdge = function() {}, o.inherit(c, o.Dynamics.Controllers.b2Controller), c.prototype.__super = o.Dynamics.Controllers.b2Controller.prototype, c.b2GravityController = function() {
                o.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = !0
            }, c.prototype.Step = function() {
                var t = null,
                    i = null,
                    o = null,
                    n = 0,
                    s = null,
                    r = null,
                    a = null,
                    l = 0,
                    m = 0,
                    c = 0;
                if (l = null, this.invSqr)
                    for (t = this.m_bodyList; t; t = t.nextBody)
                        for (o = (i = t.body).GetWorldCenter(), n = i.GetMass(), s = this.m_bodyList; s != t; s = s.nextBody)(c = (l = (a = (r = s.body).GetWorldCenter()).x - o.x) * l + (m = a.y - o.y) * m) < Number.MIN_VALUE || ((l = new e(l, m)).Multiply(this.G / c / Math.sqrt(c) * n * r.GetMass()), i.IsAwake() && i.ApplyForce(l, o), l.Multiply(-1), r.IsAwake() && r.ApplyForce(l, a));
                else
                    for (t = this.m_bodyList; t; t = t.nextBody)
                        for (o = (i = t.body).GetWorldCenter(), n = i.GetMass(), s = this.m_bodyList; s != t; s = s.nextBody)(c = (l = (a = (r = s.body).GetWorldCenter()).x - o.x) * l + (m = a.y - o.y) * m) < Number.MIN_VALUE || ((l = new e(l, m)).Multiply(this.G / c * n * r.GetMass()), i.IsAwake() && i.ApplyForce(l, o), l.Multiply(-1), r.IsAwake() && r.ApplyForce(l, a))
            }, o.inherit(h, o.Dynamics.Controllers.b2Controller), h.prototype.__super = o.Dynamics.Controllers.b2Controller.prototype, h.b2TensorDampingController = function() {
                o.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new t, this.maxTimestep = 0
            }, h.prototype.SetAxisAligned = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.T.col1.x = -t, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -i, this.maxTimestep = t > 0 || i > 0 ? 1 / Math.max(t, i) : 0
            }, h.prototype.Step = function(t) {
                if (!((t = t.dt) <= Number.MIN_VALUE)) {
                    t > this.maxTimestep && this.maxTimestep > 0 && (t = this.maxTimestep);
                    for (var o = this.m_bodyList; o; o = o.nextBody) {
                        var n = o.body;
                        if (n.IsAwake()) {
                            var s = n.GetWorldVector(i.MulMV(this.T, n.GetLocalVector(n.GetLinearVelocity())));
                            n.SetLinearVelocity(new e(n.GetLinearVelocity().x + s.x * t, n.GetLinearVelocity().y + s.y * t))
                        }
                    }
                }
            }
        }(), function() {
            var t = o.Common.b2Settings,
                i = o.Common.Math.b2Mat22,
                e = o.Common.Math.b2Mat33,
                n = o.Common.Math.b2Math,
                s = o.Common.Math.b2Vec2,
                r = o.Common.Math.b2Vec3,
                a = o.Dynamics.Joints.b2DistanceJoint,
                l = o.Dynamics.Joints.b2DistanceJointDef,
                m = o.Dynamics.Joints.b2FrictionJoint,
                c = o.Dynamics.Joints.b2FrictionJointDef,
                h = o.Dynamics.Joints.b2GearJoint,
                _ = o.Dynamics.Joints.b2GearJointDef,
                p = o.Dynamics.Joints.b2Jacobian,
                y = o.Dynamics.Joints.b2Joint,
                u = o.Dynamics.Joints.b2JointDef,
                x = o.Dynamics.Joints.b2JointEdge,
                f = o.Dynamics.Joints.b2LineJoint,
                d = o.Dynamics.Joints.b2LineJointDef,
                b = o.Dynamics.Joints.b2MouseJoint,
                v = o.Dynamics.Joints.b2MouseJointDef,
                C = o.Dynamics.Joints.b2PrismaticJoint,
                w = o.Dynamics.Joints.b2PrismaticJointDef,
                A = o.Dynamics.Joints.b2PulleyJoint,
                g = o.Dynamics.Joints.b2PulleyJointDef,
                S = o.Dynamics.Joints.b2RevoluteJoint,
                B = o.Dynamics.Joints.b2RevoluteJointDef,
                M = o.Dynamics.Joints.b2WeldJoint,
                V = o.Dynamics.Joints.b2WeldJointDef;
            o.inherit(a, o.Dynamics.Joints.b2Joint), a.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, a.b2DistanceJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_u = new s
            }, a.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, a.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, a.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y)
            }, a.prototype.GetReactionTorque = function() {
                return 0
            }, a.prototype.GetLength = function() {
                return this.m_length
            }, a.prototype.SetLength = function(t) {
                void 0 === t && (t = 0), this.m_length = t
            }, a.prototype.GetFrequency = function() {
                return this.m_frequencyHz
            }, a.prototype.SetFrequency = function(t) {
                void 0 === t && (t = 0), this.m_frequencyHz = t
            }, a.prototype.GetDampingRatio = function() {
                return this.m_dampingRatio
            }, a.prototype.SetDampingRatio = function(t) {
                void 0 === t && (t = 0), this.m_dampingRatio = t
            }, a.prototype.b2DistanceJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_length = t.length, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_bias = this.m_gamma = this.m_impulse = 0
            }, a.prototype.InitVelocityConstraints = function(i) {
                var o, e = 0,
                    n = this.m_bodyA,
                    s = this.m_bodyB;
                o = n.m_xf.R;
                var r = this.m_localAnchor1.x - n.m_sweep.localCenter.x,
                    a = this.m_localAnchor1.y - n.m_sweep.localCenter.y;
                e = o.col1.x * r + o.col2.x * a, a = o.col1.y * r + o.col2.y * a, r = e, o = s.m_xf.R;
                var l = this.m_localAnchor2.x - s.m_sweep.localCenter.x,
                    m = this.m_localAnchor2.y - s.m_sweep.localCenter.y;
                e = o.col1.x * l + o.col2.x * m, m = o.col1.y * l + o.col2.y * m, l = e, this.m_u.x = s.m_sweep.c.x + l - n.m_sweep.c.x - r, this.m_u.y = s.m_sweep.c.y + m - n.m_sweep.c.y - a, (e = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y)) > t.b2_linearSlop ? this.m_u.Multiply(1 / e) : this.m_u.SetZero(), o = r * this.m_u.y - a * this.m_u.x;
                var c = l * this.m_u.y - m * this.m_u.x;
                if (o = n.m_invMass + n.m_invI * o * o + s.m_invMass + s.m_invI * c * c, this.m_mass = 0 != o ? 1 / o : 0, this.m_frequencyHz > 0) {
                    e -= this.m_length, c = 2 * Math.PI * this.m_frequencyHz;
                    var h = this.m_mass * c * c;
                    this.m_gamma = i.dt * (2 * this.m_mass * this.m_dampingRatio * c + i.dt * h), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = e * i.dt * h * this.m_gamma, this.m_mass = o + this.m_gamma, this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
                }
                i.warmStarting ? (this.m_impulse *= i.dtRatio, i = this.m_impulse * this.m_u.x, o = this.m_impulse * this.m_u.y, n.m_linearVelocity.x -= n.m_invMass * i, n.m_linearVelocity.y -= n.m_invMass * o, n.m_angularVelocity -= n.m_invI * (r * o - a * i), s.m_linearVelocity.x += s.m_invMass * i, s.m_linearVelocity.y += s.m_invMass * o, s.m_angularVelocity += s.m_invI * (l * o - m * i)) : this.m_impulse = 0
            }, a.prototype.SolveVelocityConstraints = function() {
                var t, i = this.m_bodyA,
                    o = this.m_bodyB;
                t = i.m_xf.R;
                var e = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                    n = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                    s = t.col1.x * e + t.col2.x * n;
                n = t.col1.y * e + t.col2.y * n, e = s, t = o.m_xf.R;
                var r = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                    a = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
                s = t.col1.x * r + t.col2.x * a, a = t.col1.y * r + t.col2.y * a, r = s, s = -this.m_mass * (this.m_u.x * (o.m_linearVelocity.x + -o.m_angularVelocity * a - (i.m_linearVelocity.x + -i.m_angularVelocity * n)) + this.m_u.y * (o.m_linearVelocity.y + o.m_angularVelocity * r - (i.m_linearVelocity.y + i.m_angularVelocity * e)) + this.m_bias + this.m_gamma * this.m_impulse), this.m_impulse += s, t = s * this.m_u.x, s *= this.m_u.y, i.m_linearVelocity.x -= i.m_invMass * t, i.m_linearVelocity.y -= i.m_invMass * s, i.m_angularVelocity -= i.m_invI * (e * s - n * t), o.m_linearVelocity.x += o.m_invMass * t, o.m_linearVelocity.y += o.m_invMass * s, o.m_angularVelocity += o.m_invI * (r * s - a * t)
            }, a.prototype.SolvePositionConstraints = function() {
                var i;
                if (this.m_frequencyHz > 0) return !0;
                var o = this.m_bodyA,
                    e = this.m_bodyB;
                i = o.m_xf.R;
                var s = this.m_localAnchor1.x - o.m_sweep.localCenter.x,
                    r = this.m_localAnchor1.y - o.m_sweep.localCenter.y,
                    a = i.col1.x * s + i.col2.x * r;
                r = i.col1.y * s + i.col2.y * r, s = a, i = e.m_xf.R;
                var l = this.m_localAnchor2.x - e.m_sweep.localCenter.x,
                    m = this.m_localAnchor2.y - e.m_sweep.localCenter.y;
                a = i.col1.x * l + i.col2.x * m, m = i.col1.y * l + i.col2.y * m, l = a, a = e.m_sweep.c.x + l - o.m_sweep.c.x - s;
                var c = e.m_sweep.c.y + m - o.m_sweep.c.y - r;
                a /= i = Math.sqrt(a * a + c * c), c /= i, i -= this.m_length, i = n.Clamp(i, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection);
                var h = -this.m_mass * i;
                return this.m_u.Set(a, c), a = h * this.m_u.x, c = h * this.m_u.y, o.m_sweep.c.x -= o.m_invMass * a, o.m_sweep.c.y -= o.m_invMass * c, o.m_sweep.a -= o.m_invI * (s * c - r * a), e.m_sweep.c.x += e.m_invMass * a, e.m_sweep.c.y += e.m_invMass * c, e.m_sweep.a += e.m_invI * (l * c - m * a), o.SynchronizeTransform(), e.SynchronizeTransform(), n.Abs(i) < t.b2_linearSlop
            }, o.inherit(l, o.Dynamics.Joints.b2JointDef), l.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, l.b2DistanceJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s
            }, l.prototype.b2DistanceJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_distanceJoint, this.length = 1, this.dampingRatio = this.frequencyHz = 0
            }, l.prototype.Initialize = function(t, i, o, e) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(o)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(e)), t = e.x - o.x, o = e.y - o.y, this.length = Math.sqrt(t * t + o * o), this.dampingRatio = this.frequencyHz = 0
            }, o.inherit(m, o.Dynamics.Joints.b2Joint), m.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, m.b2FrictionJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new s, this.m_localAnchorB = new s, this.m_linearMass = new i, this.m_linearImpulse = new s
            }, m.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
            }, m.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
            }, m.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y)
            }, m.prototype.GetReactionTorque = function(t) {
                return void 0 === t && (t = 0), t * this.m_angularImpulse
            }, m.prototype.SetMaxForce = function(t) {
                void 0 === t && (t = 0), this.m_maxForce = t
            }, m.prototype.GetMaxForce = function() {
                return this.m_maxForce
            }, m.prototype.SetMaxTorque = function(t) {
                void 0 === t && (t = 0), this.m_maxTorque = t
            }, m.prototype.GetMaxTorque = function() {
                return this.m_maxTorque
            }, m.prototype.b2FrictionJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque
            }, m.prototype.InitVelocityConstraints = function(t) {
                var o, e = 0,
                    n = this.m_bodyA,
                    s = this.m_bodyB;
                o = n.m_xf.R;
                var r = this.m_localAnchorA.x - n.m_sweep.localCenter.x,
                    a = this.m_localAnchorA.y - n.m_sweep.localCenter.y;
                e = o.col1.x * r + o.col2.x * a, a = o.col1.y * r + o.col2.y * a, r = e, o = s.m_xf.R;
                var l = this.m_localAnchorB.x - s.m_sweep.localCenter.x,
                    m = this.m_localAnchorB.y - s.m_sweep.localCenter.y;
                e = o.col1.x * l + o.col2.x * m, m = o.col1.y * l + o.col2.y * m, l = e, o = n.m_invMass, e = s.m_invMass;
                var c = n.m_invI,
                    h = s.m_invI,
                    _ = new i;
                _.col1.x = o + e, _.col2.x = 0, _.col1.y = 0, _.col2.y = o + e, _.col1.x += c * a * a, _.col2.x += -c * r * a, _.col1.y += -c * r * a, _.col2.y += c * r * r, _.col1.x += h * m * m, _.col2.x += -h * l * m, _.col1.y += -h * l * m, _.col2.y += h * l * l, _.GetInverse(this.m_linearMass), this.m_angularMass = c + h, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.warmStarting ? (this.m_linearImpulse.x *= t.dtRatio, this.m_linearImpulse.y *= t.dtRatio, this.m_angularImpulse *= t.dtRatio, t = this.m_linearImpulse, n.m_linearVelocity.x -= o * t.x, n.m_linearVelocity.y -= o * t.y, n.m_angularVelocity -= c * (r * t.y - a * t.x + this.m_angularImpulse), s.m_linearVelocity.x += e * t.x, s.m_linearVelocity.y += e * t.y, s.m_angularVelocity += h * (l * t.y - m * t.x + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0)
            }, m.prototype.SolveVelocityConstraints = function(t) {
                var i, o = 0,
                    e = this.m_bodyA,
                    r = this.m_bodyB,
                    a = e.m_linearVelocity,
                    l = e.m_angularVelocity,
                    m = r.m_linearVelocity,
                    c = r.m_angularVelocity,
                    h = e.m_invMass,
                    _ = r.m_invMass,
                    p = e.m_invI,
                    y = r.m_invI;
                i = e.m_xf.R;
                var u = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
                    x = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
                o = i.col1.x * u + i.col2.x * x, x = i.col1.y * u + i.col2.y * x, u = o, i = r.m_xf.R;
                var f = this.m_localAnchorB.x - r.m_sweep.localCenter.x,
                    d = this.m_localAnchorB.y - r.m_sweep.localCenter.y;
                o = i.col1.x * f + i.col2.x * d, d = i.col1.y * f + i.col2.y * d, f = o, i = 0, o = -this.m_angularMass * (c - l);
                var b = this.m_angularImpulse;
                i = t.dt * this.m_maxTorque, this.m_angularImpulse = n.Clamp(this.m_angularImpulse + o, -i, i), l -= p * (o = this.m_angularImpulse - b), c += y * o, i = n.MulMV(this.m_linearMass, new s(-(m.x - c * d - a.x + l * x), -(m.y + c * f - a.y - l * u))), o = this.m_linearImpulse.Copy(), this.m_linearImpulse.Add(i), i = t.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > i * i && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(i)), i = n.SubtractVV(this.m_linearImpulse, o), a.x -= h * i.x, a.y -= h * i.y, l -= p * (u * i.y - x * i.x), m.x += _ * i.x, m.y += _ * i.y, c += y * (f * i.y - d * i.x), e.m_angularVelocity = l, r.m_angularVelocity = c
            }, m.prototype.SolvePositionConstraints = function() {
                return !0
            }, o.inherit(c, o.Dynamics.Joints.b2JointDef), c.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, c.b2FrictionJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s
            }, c.prototype.b2FrictionJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_frictionJoint, this.maxTorque = this.maxForce = 0
            }, c.prototype.Initialize = function(t, i, o) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(o)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(o))
            }, o.inherit(h, o.Dynamics.Joints.b2Joint), h.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, h.b2GearJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new s, this.m_groundAnchor2 = new s, this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_J = new p
            }, h.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, h.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, h.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse * this.m_J.linearB.x, t * this.m_impulse * this.m_J.linearB.y)
            }, h.prototype.GetReactionTorque = function(t) {
                void 0 === t && (t = 0);
                var i = this.m_bodyB.m_xf.R,
                    o = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x,
                    e = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y,
                    n = i.col1.x * o + i.col2.x * e;
                return e = i.col1.y * o + i.col2.y * e, o = n, t * (this.m_impulse * this.m_J.angularB - o * this.m_impulse * this.m_J.linearB.y + e * this.m_impulse * this.m_J.linearB.x)
            }, h.prototype.GetRatio = function() {
                return this.m_ratio
            }, h.prototype.SetRatio = function(t) {
                void 0 === t && (t = 0), this.m_ratio = t
            }, h.prototype.b2GearJoint = function(t) {
                this.__super.b2Joint.call(this, t);
                var i = parseInt(t.joint1.m_type),
                    o = parseInt(t.joint2.m_type);
                this.m_prismatic2 = this.m_revolute2 = this.m_prismatic1 = this.m_revolute1 = null;
                var e = 0,
                    n = 0;
                this.m_ground1 = t.joint1.GetBodyA(), this.m_bodyA = t.joint1.GetBodyB(), i == y.e_revoluteJoint ? (this.m_revolute1 = t.joint1 instanceof S ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), e = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = t.joint1 instanceof C ? t.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), e = this.m_prismatic1.GetJointTranslation()), this.m_ground2 = t.joint2.GetBodyA(), this.m_bodyB = t.joint2.GetBodyB(), o == y.e_revoluteJoint ? (this.m_revolute2 = t.joint2 instanceof S ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), n = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = t.joint2 instanceof C ? t.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), n = this.m_prismatic2.GetJointTranslation()), this.m_ratio = t.ratio, this.m_constant = e + this.m_ratio * n, this.m_impulse = 0
            }, h.prototype.InitVelocityConstraints = function(t) {
                var i = this.m_ground1,
                    o = this.m_ground2,
                    e = this.m_bodyA,
                    n = this.m_bodyB,
                    s = 0,
                    r = 0,
                    a = 0,
                    l = 0,
                    m = a = 0,
                    c = 0;
                this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, c += e.m_invI) : (i = i.m_xf.R, r = this.m_prismatic1.m_localXAxis1, s = i.col1.x * r.x + i.col2.x * r.y, r = i.col1.y * r.x + i.col2.y * r.y, i = e.m_xf.R, a = this.m_localAnchor1.x - e.m_sweep.localCenter.x, l = this.m_localAnchor1.y - e.m_sweep.localCenter.y, m = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = (a = m) * r - l * s, this.m_J.linearA.Set(-s, -r), this.m_J.angularA = -a, c += e.m_invMass + e.m_invI * a * a), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, c += this.m_ratio * this.m_ratio * n.m_invI) : (i = o.m_xf.R, r = this.m_prismatic2.m_localXAxis1, s = i.col1.x * r.x + i.col2.x * r.y, r = i.col1.y * r.x + i.col2.y * r.y, i = n.m_xf.R, a = this.m_localAnchor2.x - n.m_sweep.localCenter.x, l = this.m_localAnchor2.y - n.m_sweep.localCenter.y, m = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = (a = m) * r - l * s, this.m_J.linearB.Set(-this.m_ratio * s, -this.m_ratio * r), this.m_J.angularB = -this.m_ratio * a, c += this.m_ratio * this.m_ratio * (n.m_invMass + n.m_invI * a * a)), this.m_mass = c > 0 ? 1 / c : 0, t.warmStarting ? (e.m_linearVelocity.x += e.m_invMass * this.m_impulse * this.m_J.linearA.x, e.m_linearVelocity.y += e.m_invMass * this.m_impulse * this.m_J.linearA.y, e.m_angularVelocity += e.m_invI * this.m_impulse * this.m_J.angularA, n.m_linearVelocity.x += n.m_invMass * this.m_impulse * this.m_J.linearB.x, n.m_linearVelocity.y += n.m_invMass * this.m_impulse * this.m_J.linearB.y, n.m_angularVelocity += n.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
            }, h.prototype.SolveVelocityConstraints = function() {
                var t = this.m_bodyA,
                    i = this.m_bodyB,
                    o = -this.m_mass * this.m_J.Compute(t.m_linearVelocity, t.m_angularVelocity, i.m_linearVelocity, i.m_angularVelocity);
                this.m_impulse += o, t.m_linearVelocity.x += t.m_invMass * o * this.m_J.linearA.x, t.m_linearVelocity.y += t.m_invMass * o * this.m_J.linearA.y, t.m_angularVelocity += t.m_invI * o * this.m_J.angularA, i.m_linearVelocity.x += i.m_invMass * o * this.m_J.linearB.x, i.m_linearVelocity.y += i.m_invMass * o * this.m_J.linearB.y, i.m_angularVelocity += i.m_invI * o * this.m_J.angularB
            }, h.prototype.SolvePositionConstraints = function() {
                var i, o = this.m_bodyA,
                    e = this.m_bodyB,
                    n = 0;
                return n = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), i = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation(), n = -this.m_mass * (this.m_constant - (n + this.m_ratio * i)), o.m_sweep.c.x += o.m_invMass * n * this.m_J.linearA.x, o.m_sweep.c.y += o.m_invMass * n * this.m_J.linearA.y, o.m_sweep.a += o.m_invI * n * this.m_J.angularA, e.m_sweep.c.x += e.m_invMass * n * this.m_J.linearB.x, e.m_sweep.c.y += e.m_invMass * n * this.m_J.linearB.y, e.m_sweep.a += e.m_invI * n * this.m_J.angularB, o.SynchronizeTransform(), e.SynchronizeTransform(), 0 < t.b2_linearSlop
            }, o.inherit(_, o.Dynamics.Joints.b2JointDef), _.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, _.b2GearJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments)
            }, _.prototype.b2GearJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_gearJoint, this.joint2 = this.joint1 = null, this.ratio = 1
            }, p.b2Jacobian = function() {
                this.linearA = new s, this.linearB = new s
            }, p.prototype.SetZero = function() {
                this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0
            }, p.prototype.Set = function(t, i, o, e) {
                void 0 === i && (i = 0), void 0 === e && (e = 0), this.linearA.SetV(t), this.angularA = i, this.linearB.SetV(o), this.angularB = e
            }, p.prototype.Compute = function(t, i, o, e) {
                return void 0 === i && (i = 0), void 0 === e && (e = 0), this.linearA.x * t.x + this.linearA.y * t.y + this.angularA * i + (this.linearB.x * o.x + this.linearB.y * o.y) + this.angularB * e
            }, y.b2Joint = function() {
                this.m_edgeA = new x, this.m_edgeB = new x, this.m_localCenterA = new s, this.m_localCenterB = new s
            }, y.prototype.GetType = function() {
                return this.m_type
            }, y.prototype.GetAnchorA = function() {
                return null
            }, y.prototype.GetAnchorB = function() {
                return null
            }, y.prototype.GetReactionForce = function() {
                return null
            }, y.prototype.GetReactionTorque = function() {
                return 0
            }, y.prototype.GetBodyA = function() {
                return this.m_bodyA
            }, y.prototype.GetBodyB = function() {
                return this.m_bodyB
            }, y.prototype.GetNext = function() {
                return this.m_next
            }, y.prototype.GetUserData = function() {
                return this.m_userData
            }, y.prototype.SetUserData = function(t) {
                this.m_userData = t
            }, y.prototype.IsActive = function() {
                return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
            }, y.Create = function(t) {
                var i = null;
                switch (t.type) {
                    case y.e_distanceJoint:
                        i = new a(t instanceof l ? t : null);
                        break;
                    case y.e_mouseJoint:
                        i = new b(t instanceof v ? t : null);
                        break;
                    case y.e_prismaticJoint:
                        i = new C(t instanceof w ? t : null);
                        break;
                    case y.e_revoluteJoint:
                        i = new S(t instanceof B ? t : null);
                        break;
                    case y.e_pulleyJoint:
                        i = new A(t instanceof g ? t : null);
                        break;
                    case y.e_gearJoint:
                        i = new h(t instanceof _ ? t : null);
                        break;
                    case y.e_lineJoint:
                        i = new f(t instanceof d ? t : null);
                        break;
                    case y.e_weldJoint:
                        i = new M(t instanceof V ? t : null);
                        break;
                    case y.e_frictionJoint:
                        i = new m(t instanceof c ? t : null)
                }
                return i
            }, y.Destroy = function() {}, y.prototype.b2Joint = function(i) {
                t.b2Assert(i.bodyA != i.bodyB), this.m_type = i.type, this.m_next = this.m_prev = null, this.m_bodyA = i.bodyA, this.m_bodyB = i.bodyB, this.m_collideConnected = i.collideConnected, this.m_islandFlag = !1, this.m_userData = i.userData
            }, y.prototype.InitVelocityConstraints = function() {}, y.prototype.SolveVelocityConstraints = function() {}, y.prototype.FinalizeVelocityConstraints = function() {}, y.prototype.SolvePositionConstraints = function() {
                return !1
            }, o.postDefs.push(function() {
                o.Dynamics.Joints.b2Joint.e_unknownJoint = 0, o.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, o.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, o.Dynamics.Joints.b2Joint.e_distanceJoint = 3, o.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, o.Dynamics.Joints.b2Joint.e_mouseJoint = 5, o.Dynamics.Joints.b2Joint.e_gearJoint = 6, o.Dynamics.Joints.b2Joint.e_lineJoint = 7, o.Dynamics.Joints.b2Joint.e_weldJoint = 8, o.Dynamics.Joints.b2Joint.e_frictionJoint = 9, o.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, o.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, o.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, o.Dynamics.Joints.b2Joint.e_equalLimits = 3
            }), u.b2JointDef = function() {}, u.prototype.b2JointDef = function() {
                this.type = y.e_unknownJoint, this.bodyB = this.bodyA = this.userData = null, this.collideConnected = !1
            }, x.b2JointEdge = function() {}, o.inherit(f, o.Dynamics.Joints.b2Joint), f.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, f.b2LineJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_localXAxis1 = new s, this.m_localYAxis1 = new s, this.m_axis = new s, this.m_perp = new s, this.m_K = new i, this.m_impulse = new s
            }, f.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, f.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, f.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
            }, f.prototype.GetReactionTorque = function(t) {
                return void 0 === t && (t = 0), t * this.m_impulse.y
            }, f.prototype.GetJointTranslation = function() {
                var t = this.m_bodyA,
                    i = this.m_bodyB,
                    o = t.GetWorldPoint(this.m_localAnchor1),
                    e = i.GetWorldPoint(this.m_localAnchor2);
                return i = e.x - o.x, o = e.y - o.y, (t = t.GetWorldVector(this.m_localXAxis1)).x * i + t.y * o
            }, f.prototype.GetJointSpeed = function() {
                var t, i = this.m_bodyA,
                    o = this.m_bodyB;
                t = i.m_xf.R;
                var e = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                    n = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                    s = t.col1.x * e + t.col2.x * n;
                n = t.col1.y * e + t.col2.y * n, e = s, t = o.m_xf.R;
                var r = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                    a = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
                s = t.col1.x * r + t.col2.x * a, a = t.col1.y * r + t.col2.y * a, r = s, t = o.m_sweep.c.x + r - (i.m_sweep.c.x + e), s = o.m_sweep.c.y + a - (i.m_sweep.c.y + n);
                var l = i.GetWorldVector(this.m_localXAxis1),
                    m = i.m_linearVelocity,
                    c = o.m_linearVelocity;
                return i = i.m_angularVelocity, o = o.m_angularVelocity, t * -i * l.y + s * i * l.x + (l.x * (c.x + -o * a - m.x - -i * n) + l.y * (c.y + o * r - m.y - i * e))
            }, f.prototype.IsLimitEnabled = function() {
                return this.m_enableLimit
            }, f.prototype.EnableLimit = function(t) {
                this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t
            }, f.prototype.GetLowerLimit = function() {
                return this.m_lowerTranslation
            }, f.prototype.GetUpperLimit = function() {
                return this.m_upperTranslation
            }, f.prototype.SetLimits = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = i
            }, f.prototype.IsMotorEnabled = function() {
                return this.m_enableMotor
            }, f.prototype.EnableMotor = function(t) {
                this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
            }, f.prototype.SetMotorSpeed = function(t) {
                void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
            }, f.prototype.GetMotorSpeed = function() {
                return this.m_motorSpeed
            }, f.prototype.SetMaxMotorForce = function(t) {
                void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
            }, f.prototype.GetMaxMotorForce = function() {
                return this.m_maxMotorForce
            }, f.prototype.GetMotorForce = function() {
                return this.m_motorImpulse
            }, f.prototype.b2LineJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorImpulse = this.m_motorMass = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = y.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
            }, f.prototype.InitVelocityConstraints = function(i) {
                var o, e = this.m_bodyA,
                    s = this.m_bodyB,
                    r = 0;
                this.m_localCenterA.SetV(e.GetLocalCenter()), this.m_localCenterB.SetV(s.GetLocalCenter());
                var a = e.GetTransform();
                s.GetTransform(), o = e.m_xf.R;
                var l = this.m_localAnchor1.x - this.m_localCenterA.x,
                    m = this.m_localAnchor1.y - this.m_localCenterA.y;
                r = o.col1.x * l + o.col2.x * m, m = o.col1.y * l + o.col2.y * m, l = r, o = s.m_xf.R;
                var c = this.m_localAnchor2.x - this.m_localCenterB.x,
                    h = this.m_localAnchor2.y - this.m_localCenterB.y;
                r = o.col1.x * c + o.col2.x * h, h = o.col1.y * c + o.col2.y * h, c = r, o = s.m_sweep.c.x + c - e.m_sweep.c.x - l, r = s.m_sweep.c.y + h - e.m_sweep.c.y - m, this.m_invMassA = e.m_invMass, this.m_invMassB = s.m_invMass, this.m_invIA = e.m_invI, this.m_invIB = s.m_invI, this.m_axis.SetV(n.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (o + l) * this.m_axis.y - (r + m) * this.m_axis.x, this.m_a2 = c * this.m_axis.y - h * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0, this.m_perp.SetV(n.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (o + l) * this.m_perp.y - (r + m) * this.m_perp.x, this.m_s2 = c * this.m_perp.y - h * this.m_perp.x, a = this.m_invMassA, l = this.m_invMassB, m = this.m_invIA, c = this.m_invIB, this.m_K.col1.x = a + l + m * this.m_s1 * this.m_s1 + c * this.m_s2 * this.m_s2, this.m_K.col1.y = m * this.m_s1 * this.m_a1 + c * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = a + l + m * this.m_a1 * this.m_a1 + c * this.m_a2 * this.m_a2, this.m_enableLimit ? (o = this.m_axis.x * o + this.m_axis.y * r, n.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = y.e_equalLimits : o <= this.m_lowerTranslation ? this.m_limitState != y.e_atLowerLimit && (this.m_limitState = y.e_atLowerLimit, this.m_impulse.y = 0) : o >= this.m_upperTranslation ? this.m_limitState != y.e_atUpperLimit && (this.m_limitState = y.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = y.e_inactiveLimit, this.m_impulse.y = 0)) : this.m_limitState = y.e_inactiveLimit, 0 == this.m_enableMotor && (this.m_motorImpulse = 0), i.warmStarting ? (this.m_impulse.x *= i.dtRatio, this.m_impulse.y *= i.dtRatio, this.m_motorImpulse *= i.dtRatio, i = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, o = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, r = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, a = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2, e.m_linearVelocity.x -= this.m_invMassA * i, e.m_linearVelocity.y -= this.m_invMassA * o, e.m_angularVelocity -= this.m_invIA * r, s.m_linearVelocity.x += this.m_invMassB * i, s.m_linearVelocity.y += this.m_invMassB * o, s.m_angularVelocity += this.m_invIB * a) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
            }, f.prototype.SolveVelocityConstraints = function(t) {
                var i = this.m_bodyA,
                    o = this.m_bodyB,
                    e = i.m_linearVelocity,
                    r = i.m_angularVelocity,
                    a = o.m_linearVelocity,
                    l = o.m_angularVelocity,
                    m = 0,
                    c = 0,
                    h = 0,
                    _ = 0;
                this.m_enableMotor && this.m_limitState != y.e_equalLimits && (_ = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (a.x - e.x) + this.m_axis.y * (a.y - e.y) + this.m_a2 * l - this.m_a1 * r)), m = this.m_motorImpulse, c = t.dt * this.m_maxMotorForce, this.m_motorImpulse = n.Clamp(this.m_motorImpulse + _, -c, c), m = (_ = this.m_motorImpulse - m) * this.m_axis.x, c = _ * this.m_axis.y, h = _ * this.m_a1, _ *= this.m_a2, e.x -= this.m_invMassA * m, e.y -= this.m_invMassA * c, r -= this.m_invIA * h, a.x += this.m_invMassB * m, a.y += this.m_invMassB * c, l += this.m_invIB * _), c = this.m_perp.x * (a.x - e.x) + this.m_perp.y * (a.y - e.y) + this.m_s2 * l - this.m_s1 * r, this.m_enableLimit && this.m_limitState != y.e_inactiveLimit ? (h = this.m_axis.x * (a.x - e.x) + this.m_axis.y * (a.y - e.y) + this.m_a2 * l - this.m_a1 * r, m = this.m_impulse.Copy(), t = this.m_K.Solve(new s, -c, -h), this.m_impulse.Add(t), this.m_limitState == y.e_atLowerLimit ? this.m_impulse.y = n.Max(this.m_impulse.y, 0) : this.m_limitState == y.e_atUpperLimit && (this.m_impulse.y = n.Min(this.m_impulse.y, 0)), c = -c - (this.m_impulse.y - m.y) * this.m_K.col2.x, h = 0, h = 0 != this.m_K.col1.x ? c / this.m_K.col1.x + m.x : m.x, this.m_impulse.x = h, t.x = this.m_impulse.x - m.x, t.y = this.m_impulse.y - m.y, m = t.x * this.m_perp.x + t.y * this.m_axis.x, c = t.x * this.m_perp.y + t.y * this.m_axis.y, h = t.x * this.m_s1 + t.y * this.m_a1, _ = t.x * this.m_s2 + t.y * this.m_a2) : (t = 0, t = 0 != this.m_K.col1.x ? -c / this.m_K.col1.x : 0, this.m_impulse.x += t, m = t * this.m_perp.x, c = t * this.m_perp.y, h = t * this.m_s1, _ = t * this.m_s2), e.x -= this.m_invMassA * m, e.y -= this.m_invMassA * c, r -= this.m_invIA * h, a.x += this.m_invMassB * m, a.y += this.m_invMassB * c, l += this.m_invIB * _, i.m_linearVelocity.SetV(e), i.m_angularVelocity = r, o.m_linearVelocity.SetV(a), o.m_angularVelocity = l
            }, f.prototype.SolvePositionConstraints = function() {
                var o, e = this.m_bodyA,
                    r = this.m_bodyB,
                    a = e.m_sweep.c,
                    l = e.m_sweep.a,
                    m = r.m_sweep.c,
                    c = r.m_sweep.a,
                    h = 0,
                    _ = 0,
                    p = 0,
                    y = 0,
                    u = o = 0,
                    x = 0;
                _ = !1;
                var f = 0,
                    d = i.FromAngle(l);
                p = i.FromAngle(c), o = d, x = this.m_localAnchor1.x - this.m_localCenterA.x;
                var b = this.m_localAnchor1.y - this.m_localCenterA.y;
                if (h = o.col1.x * x + o.col2.x * b, b = o.col1.y * x + o.col2.y * b, x = h, o = p, p = this.m_localAnchor2.x - this.m_localCenterB.x, y = this.m_localAnchor2.y - this.m_localCenterB.y, h = o.col1.x * p + o.col2.x * y, y = o.col1.y * p + o.col2.y * y, p = h, o = m.x + p - a.x - x, h = m.y + y - a.y - b, this.m_enableLimit) {
                    this.m_axis = n.MulMV(d, this.m_localXAxis1), this.m_a1 = (o + x) * this.m_axis.y - (h + b) * this.m_axis.x, this.m_a2 = p * this.m_axis.y - y * this.m_axis.x;
                    var v = this.m_axis.x * o + this.m_axis.y * h;
                    n.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (f = n.Clamp(v, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), u = n.Abs(v), _ = !0) : v <= this.m_lowerTranslation ? (f = n.Clamp(v - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), u = this.m_lowerTranslation - v, _ = !0) : v >= this.m_upperTranslation && (f = n.Clamp(v - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), u = v - this.m_upperTranslation, _ = !0)
                }
                return this.m_perp = n.MulMV(d, this.m_localYAxis1), this.m_s1 = (o + x) * this.m_perp.y - (h + b) * this.m_perp.x, this.m_s2 = p * this.m_perp.y - y * this.m_perp.x, d = new s, b = this.m_perp.x * o + this.m_perp.y * h, u = n.Max(u, n.Abs(b)), x = 0, _ ? (_ = this.m_invMassA, p = this.m_invMassB, y = this.m_invIA, o = this.m_invIB, this.m_K.col1.x = _ + p + y * this.m_s1 * this.m_s1 + o * this.m_s2 * this.m_s2, this.m_K.col1.y = y * this.m_s1 * this.m_a1 + o * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = _ + p + y * this.m_a1 * this.m_a1 + o * this.m_a2 * this.m_a2, this.m_K.Solve(d, -b, -f)) : (_ = this.m_invMassA, p = this.m_invMassB, y = this.m_invIA, o = this.m_invIB, f = _ + p + y * this.m_s1 * this.m_s1 + o * this.m_s2 * this.m_s2, _ = 0, _ = 0 != f ? -b / f : 0, d.x = _, d.y = 0), f = d.x * this.m_perp.x + d.y * this.m_axis.x, _ = d.x * this.m_perp.y + d.y * this.m_axis.y, b = d.x * this.m_s1 + d.y * this.m_a1, d = d.x * this.m_s2 + d.y * this.m_a2, a.x -= this.m_invMassA * f, a.y -= this.m_invMassA * _, l -= this.m_invIA * b, m.x += this.m_invMassB * f, m.y += this.m_invMassB * _, c += this.m_invIB * d, e.m_sweep.a = l, r.m_sweep.a = c, e.SynchronizeTransform(), r.SynchronizeTransform(), u <= t.b2_linearSlop && x <= t.b2_angularSlop
            }, o.inherit(d, o.Dynamics.Joints.b2JointDef), d.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, d.b2LineJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s, this.localAxisA = new s
            }, d.prototype.b2LineJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = !1, this.upperTranslation = this.lowerTranslation = 0, this.enableMotor = !1, this.motorSpeed = this.maxMotorForce = 0
            }, d.prototype.Initialize = function(t, i, o, e) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA = this.bodyA.GetLocalPoint(o), this.localAnchorB = this.bodyB.GetLocalPoint(o), this.localAxisA = this.bodyA.GetLocalVector(e)
            }, o.inherit(b, o.Dynamics.Joints.b2Joint), b.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, b.b2MouseJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.m_localAnchor = new s, this.m_target = new s, this.m_impulse = new s, this.m_mass = new i, this.m_C = new s
            }, b.prototype.GetAnchorA = function() {
                return this.m_target
            }, b.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
            }, b.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse.x, t * this.m_impulse.y)
            }, b.prototype.GetReactionTorque = function() {
                return 0
            }, b.prototype.GetTarget = function() {
                return this.m_target
            }, b.prototype.SetTarget = function(t) {
                0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_target = t
            }, b.prototype.GetMaxForce = function() {
                return this.m_maxForce
            }, b.prototype.SetMaxForce = function(t) {
                void 0 === t && (t = 0), this.m_maxForce = t
            }, b.prototype.GetFrequency = function() {
                return this.m_frequencyHz
            }, b.prototype.SetFrequency = function(t) {
                void 0 === t && (t = 0), this.m_frequencyHz = t
            }, b.prototype.GetDampingRatio = function() {
                return this.m_dampingRatio
            }, b.prototype.SetDampingRatio = function(t) {
                void 0 === t && (t = 0), this.m_dampingRatio = t
            }, b.prototype.b2MouseJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_target.SetV(t.target);
                var i = this.m_target.x - this.m_bodyB.m_xf.position.x,
                    o = this.m_target.y - this.m_bodyB.m_xf.position.y,
                    e = this.m_bodyB.m_xf.R;
                this.m_localAnchor.x = i * e.col1.x + o * e.col1.y, this.m_localAnchor.y = i * e.col2.x + o * e.col2.y, this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_gamma = this.m_beta = 0
            }, b.prototype.InitVelocityConstraints = function(t) {
                var i = this.m_bodyB,
                    o = i.GetMass(),
                    e = 2 * Math.PI * this.m_frequencyHz,
                    n = o * e * e;
                this.m_gamma = t.dt * (2 * o * this.m_dampingRatio * e + t.dt * n), this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0, this.m_beta = t.dt * n * this.m_gamma, n = i.m_xf.R, o = this.m_localAnchor.x - i.m_sweep.localCenter.x, e = this.m_localAnchor.y - i.m_sweep.localCenter.y;
                var s = n.col1.x * o + n.col2.x * e;
                e = n.col1.y * o + n.col2.y * e, o = s, n = i.m_invMass, s = i.m_invI, this.K1.col1.x = n, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = n, this.K2.col1.x = s * e * e, this.K2.col2.x = -s * o * e, this.K2.col1.y = -s * o * e, this.K2.col2.y = s * o * o, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += this.m_gamma, this.K.col2.y += this.m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = i.m_sweep.c.x + o - this.m_target.x, this.m_C.y = i.m_sweep.c.y + e - this.m_target.y, i.m_angularVelocity *= .98, this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, i.m_linearVelocity.x += n * this.m_impulse.x, i.m_linearVelocity.y += n * this.m_impulse.y, i.m_angularVelocity += s * (o * this.m_impulse.y - e * this.m_impulse.x)
            }, b.prototype.SolveVelocityConstraints = function(t) {
                var i, o = this.m_bodyB,
                    e = 0,
                    n = 0;
                i = o.m_xf.R;
                var s = this.m_localAnchor.x - o.m_sweep.localCenter.x,
                    r = this.m_localAnchor.y - o.m_sweep.localCenter.y;
                e = i.col1.x * s + i.col2.x * r, r = i.col1.y * s + i.col2.y * r, s = e, e = o.m_linearVelocity.x + -o.m_angularVelocity * r;
                var a = o.m_linearVelocity.y + o.m_angularVelocity * s;
                i = this.m_mass, e = e + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, n = a + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y, a = -(i.col1.x * e + i.col2.x * n), n = -(i.col1.y * e + i.col2.y * n), i = this.m_impulse.x, e = this.m_impulse.y, this.m_impulse.x += a, this.m_impulse.y += n, t = t.dt * this.m_maxForce, this.m_impulse.LengthSquared() > t * t && this.m_impulse.Multiply(t / this.m_impulse.Length()), a = this.m_impulse.x - i, n = this.m_impulse.y - e, o.m_linearVelocity.x += o.m_invMass * a, o.m_linearVelocity.y += o.m_invMass * n, o.m_angularVelocity += o.m_invI * (s * n - r * a)
            }, b.prototype.SolvePositionConstraints = function() {
                return !0
            }, o.inherit(v, o.Dynamics.Joints.b2JointDef), v.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, v.b2MouseJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new s
            }, v.prototype.b2MouseJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = .7
            }, o.inherit(C, o.Dynamics.Joints.b2Joint), C.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, C.b2PrismaticJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_localXAxis1 = new s, this.m_localYAxis1 = new s, this.m_axis = new s, this.m_perp = new s, this.m_K = new e, this.m_impulse = new r
            }, C.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, C.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, C.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
            }, C.prototype.GetReactionTorque = function(t) {
                return void 0 === t && (t = 0), t * this.m_impulse.y
            }, C.prototype.GetJointTranslation = function() {
                var t = this.m_bodyA,
                    i = this.m_bodyB,
                    o = t.GetWorldPoint(this.m_localAnchor1),
                    e = i.GetWorldPoint(this.m_localAnchor2);
                return i = e.x - o.x, o = e.y - o.y, (t = t.GetWorldVector(this.m_localXAxis1)).x * i + t.y * o
            }, C.prototype.GetJointSpeed = function() {
                var t, i = this.m_bodyA,
                    o = this.m_bodyB;
                t = i.m_xf.R;
                var e = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                    n = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                    s = t.col1.x * e + t.col2.x * n;
                n = t.col1.y * e + t.col2.y * n, e = s, t = o.m_xf.R;
                var r = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                    a = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
                s = t.col1.x * r + t.col2.x * a, a = t.col1.y * r + t.col2.y * a, r = s, t = o.m_sweep.c.x + r - (i.m_sweep.c.x + e), s = o.m_sweep.c.y + a - (i.m_sweep.c.y + n);
                var l = i.GetWorldVector(this.m_localXAxis1),
                    m = i.m_linearVelocity,
                    c = o.m_linearVelocity;
                return i = i.m_angularVelocity, o = o.m_angularVelocity, t * -i * l.y + s * i * l.x + (l.x * (c.x + -o * a - m.x - -i * n) + l.y * (c.y + o * r - m.y - i * e))
            }, C.prototype.IsLimitEnabled = function() {
                return this.m_enableLimit
            }, C.prototype.EnableLimit = function(t) {
                this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t
            }, C.prototype.GetLowerLimit = function() {
                return this.m_lowerTranslation
            }, C.prototype.GetUpperLimit = function() {
                return this.m_upperTranslation
            }, C.prototype.SetLimits = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = i
            }, C.prototype.IsMotorEnabled = function() {
                return this.m_enableMotor
            }, C.prototype.EnableMotor = function(t) {
                this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t
            }, C.prototype.SetMotorSpeed = function(t) {
                void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
            }, C.prototype.GetMotorSpeed = function() {
                return this.m_motorSpeed
            }, C.prototype.SetMaxMotorForce = function(t) {
                void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t
            }, C.prototype.GetMotorForce = function() {
                return this.m_motorImpulse
            }, C.prototype.b2PrismaticJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_localXAxis1.SetV(t.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = this.m_localXAxis1.x, this.m_refAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = this.m_motorMass = 0, this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = y.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero()
            }, C.prototype.InitVelocityConstraints = function(i) {
                var o, e = this.m_bodyA,
                    s = this.m_bodyB,
                    r = 0;
                this.m_localCenterA.SetV(e.GetLocalCenter()), this.m_localCenterB.SetV(s.GetLocalCenter());
                var a = e.GetTransform();
                s.GetTransform(), o = e.m_xf.R;
                var l = this.m_localAnchor1.x - this.m_localCenterA.x,
                    m = this.m_localAnchor1.y - this.m_localCenterA.y;
                r = o.col1.x * l + o.col2.x * m, m = o.col1.y * l + o.col2.y * m, l = r, o = s.m_xf.R;
                var c = this.m_localAnchor2.x - this.m_localCenterB.x,
                    h = this.m_localAnchor2.y - this.m_localCenterB.y;
                r = o.col1.x * c + o.col2.x * h, h = o.col1.y * c + o.col2.y * h, c = r, o = s.m_sweep.c.x + c - e.m_sweep.c.x - l, r = s.m_sweep.c.y + h - e.m_sweep.c.y - m, this.m_invMassA = e.m_invMass, this.m_invMassB = s.m_invMass, this.m_invIA = e.m_invI, this.m_invIB = s.m_invI, this.m_axis.SetV(n.MulMV(a.R, this.m_localXAxis1)), this.m_a1 = (o + l) * this.m_axis.y - (r + m) * this.m_axis.x, this.m_a2 = c * this.m_axis.y - h * this.m_axis.x, this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass), this.m_perp.SetV(n.MulMV(a.R, this.m_localYAxis1)), this.m_s1 = (o + l) * this.m_perp.y - (r + m) * this.m_perp.x, this.m_s2 = c * this.m_perp.y - h * this.m_perp.x, a = this.m_invMassA, l = this.m_invMassB, m = this.m_invIA, c = this.m_invIB, this.m_K.col1.x = a + l + m * this.m_s1 * this.m_s1 + c * this.m_s2 * this.m_s2, this.m_K.col1.y = m * this.m_s1 + c * this.m_s2, this.m_K.col1.z = m * this.m_s1 * this.m_a1 + c * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = m + c, this.m_K.col2.z = m * this.m_a1 + c * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = a + l + m * this.m_a1 * this.m_a1 + c * this.m_a2 * this.m_a2, this.m_enableLimit ? (o = this.m_axis.x * o + this.m_axis.y * r, n.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = y.e_equalLimits : o <= this.m_lowerTranslation ? this.m_limitState != y.e_atLowerLimit && (this.m_limitState = y.e_atLowerLimit, this.m_impulse.z = 0) : o >= this.m_upperTranslation ? this.m_limitState != y.e_atUpperLimit && (this.m_limitState = y.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = y.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState = y.e_inactiveLimit, 0 == this.m_enableMotor && (this.m_motorImpulse = 0), i.warmStarting ? (this.m_impulse.x *= i.dtRatio, this.m_impulse.y *= i.dtRatio, this.m_motorImpulse *= i.dtRatio, i = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, o = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, r = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, a = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2, e.m_linearVelocity.x -= this.m_invMassA * i, e.m_linearVelocity.y -= this.m_invMassA * o, e.m_angularVelocity -= this.m_invIA * r, s.m_linearVelocity.x += this.m_invMassB * i, s.m_linearVelocity.y += this.m_invMassB * o, s.m_angularVelocity += this.m_invIB * a) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
            }, C.prototype.SolveVelocityConstraints = function(t) {
                var i = this.m_bodyA,
                    o = this.m_bodyB,
                    e = i.m_linearVelocity,
                    a = i.m_angularVelocity,
                    l = o.m_linearVelocity,
                    m = o.m_angularVelocity,
                    c = 0,
                    h = 0,
                    _ = 0,
                    p = 0;
                this.m_enableMotor && this.m_limitState != y.e_equalLimits && (p = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (l.x - e.x) + this.m_axis.y * (l.y - e.y) + this.m_a2 * m - this.m_a1 * a)), c = this.m_motorImpulse, t = t.dt * this.m_maxMotorForce, this.m_motorImpulse = n.Clamp(this.m_motorImpulse + p, -t, t), c = (p = this.m_motorImpulse - c) * this.m_axis.x, h = p * this.m_axis.y, _ = p * this.m_a1, p *= this.m_a2, e.x -= this.m_invMassA * c, e.y -= this.m_invMassA * h, a -= this.m_invIA * _, l.x += this.m_invMassB * c, l.y += this.m_invMassB * h, m += this.m_invIB * p), _ = this.m_perp.x * (l.x - e.x) + this.m_perp.y * (l.y - e.y) + this.m_s2 * m - this.m_s1 * a, h = m - a, this.m_enableLimit && this.m_limitState != y.e_inactiveLimit ? (t = this.m_axis.x * (l.x - e.x) + this.m_axis.y * (l.y - e.y) + this.m_a2 * m - this.m_a1 * a, c = this.m_impulse.Copy(), t = this.m_K.Solve33(new r, -_, -h, -t), this.m_impulse.Add(t), this.m_limitState == y.e_atLowerLimit ? this.m_impulse.z = n.Max(this.m_impulse.z, 0) : this.m_limitState == y.e_atUpperLimit && (this.m_impulse.z = n.Min(this.m_impulse.z, 0)), _ = -_ - (this.m_impulse.z - c.z) * this.m_K.col3.x, h = -h - (this.m_impulse.z - c.z) * this.m_K.col3.y, (h = this.m_K.Solve22(new s, _, h)).x += c.x, h.y += c.y, this.m_impulse.x = h.x, this.m_impulse.y = h.y, t.x = this.m_impulse.x - c.x, t.y = this.m_impulse.y - c.y, t.z = this.m_impulse.z - c.z, c = t.x * this.m_perp.x + t.z * this.m_axis.x, h = t.x * this.m_perp.y + t.z * this.m_axis.y, _ = t.x * this.m_s1 + t.y + t.z * this.m_a1, p = t.x * this.m_s2 + t.y + t.z * this.m_a2) : (t = this.m_K.Solve22(new s, -_, -h), this.m_impulse.x += t.x, this.m_impulse.y += t.y, c = t.x * this.m_perp.x, h = t.x * this.m_perp.y, _ = t.x * this.m_s1 + t.y, p = t.x * this.m_s2 + t.y), e.x -= this.m_invMassA * c, e.y -= this.m_invMassA * h, a -= this.m_invIA * _, l.x += this.m_invMassB * c, l.y += this.m_invMassB * h, m += this.m_invIB * p, i.m_linearVelocity.SetV(e), i.m_angularVelocity = a, o.m_linearVelocity.SetV(l), o.m_angularVelocity = m
            }, C.prototype.SolvePositionConstraints = function() {
                var o, e = this.m_bodyA,
                    a = this.m_bodyB,
                    l = e.m_sweep.c,
                    m = e.m_sweep.a,
                    c = a.m_sweep.c,
                    h = a.m_sweep.a,
                    _ = 0,
                    p = 0,
                    y = 0,
                    u = _ = o = 0,
                    x = 0;
                p = !1;
                var f = 0,
                    d = i.FromAngle(m),
                    b = i.FromAngle(h);
                o = d, x = this.m_localAnchor1.x - this.m_localCenterA.x;
                var v = this.m_localAnchor1.y - this.m_localCenterA.y;
                if (_ = o.col1.x * x + o.col2.x * v, v = o.col1.y * x + o.col2.y * v, x = _, o = b, b = this.m_localAnchor2.x - this.m_localCenterB.x, y = this.m_localAnchor2.y - this.m_localCenterB.y, _ = o.col1.x * b + o.col2.x * y, y = o.col1.y * b + o.col2.y * y, b = _, o = c.x + b - l.x - x, _ = c.y + y - l.y - v, this.m_enableLimit) {
                    this.m_axis = n.MulMV(d, this.m_localXAxis1), this.m_a1 = (o + x) * this.m_axis.y - (_ + v) * this.m_axis.x, this.m_a2 = b * this.m_axis.y - y * this.m_axis.x;
                    var C = this.m_axis.x * o + this.m_axis.y * _;
                    n.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (f = n.Clamp(C, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), u = n.Abs(C), p = !0) : C <= this.m_lowerTranslation ? (f = n.Clamp(C - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), u = this.m_lowerTranslation - C, p = !0) : C >= this.m_upperTranslation && (f = n.Clamp(C - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), u = C - this.m_upperTranslation, p = !0)
                }
                return this.m_perp = n.MulMV(d, this.m_localYAxis1), this.m_s1 = (o + x) * this.m_perp.y - (_ + v) * this.m_perp.x, this.m_s2 = b * this.m_perp.y - y * this.m_perp.x, d = new r, v = this.m_perp.x * o + this.m_perp.y * _, b = h - m - this.m_refAngle, u = n.Max(u, n.Abs(v)), x = n.Abs(b), p ? (p = this.m_invMassA, y = this.m_invMassB, o = this.m_invIA, _ = this.m_invIB, this.m_K.col1.x = p + y + o * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, this.m_K.col1.y = o * this.m_s1 + _ * this.m_s2, this.m_K.col1.z = o * this.m_s1 * this.m_a1 + _ * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = o + _, this.m_K.col2.z = o * this.m_a1 + _ * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = p + y + o * this.m_a1 * this.m_a1 + _ * this.m_a2 * this.m_a2, this.m_K.Solve33(d, -v, -b, -f)) : (p = this.m_invMassA, y = this.m_invMassB, o = this.m_invIA, _ = this.m_invIB, f = o * this.m_s1 + _ * this.m_s2, C = o + _, this.m_K.col1.Set(p + y + o * this.m_s1 * this.m_s1 + _ * this.m_s2 * this.m_s2, f, 0), this.m_K.col2.Set(f, C, 0), f = this.m_K.Solve22(new s, -v, -b), d.x = f.x, d.y = f.y, d.z = 0), f = d.x * this.m_perp.x + d.z * this.m_axis.x, p = d.x * this.m_perp.y + d.z * this.m_axis.y, v = d.x * this.m_s1 + d.y + d.z * this.m_a1, d = d.x * this.m_s2 + d.y + d.z * this.m_a2, l.x -= this.m_invMassA * f, l.y -= this.m_invMassA * p, m -= this.m_invIA * v, c.x += this.m_invMassB * f, c.y += this.m_invMassB * p, h += this.m_invIB * d, e.m_sweep.a = m, a.m_sweep.a = h, e.SynchronizeTransform(), a.SynchronizeTransform(), u <= t.b2_linearSlop && x <= t.b2_angularSlop
            }, o.inherit(w, o.Dynamics.Joints.b2JointDef), w.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, w.b2PrismaticJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s, this.localAxisA = new s
            }, w.prototype.b2PrismaticJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.upperTranslation = this.lowerTranslation = 0, this.enableMotor = !1, this.motorSpeed = this.maxMotorForce = 0
            }, w.prototype.Initialize = function(t, i, o, e) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA = this.bodyA.GetLocalPoint(o), this.localAnchorB = this.bodyB.GetLocalPoint(o), this.localAxisA = this.bodyA.GetLocalVector(e), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
            }, o.inherit(A, o.Dynamics.Joints.b2Joint), A.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, A.b2PulleyJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new s, this.m_groundAnchor2 = new s, this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_u1 = new s, this.m_u2 = new s
            }, A.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, A.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, A.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse * this.m_u2.x, t * this.m_impulse * this.m_u2.y)
            }, A.prototype.GetReactionTorque = function() {
                return 0
            }, A.prototype.GetGroundAnchorA = function() {
                var t = this.m_ground.m_xf.position.Copy();
                return t.Add(this.m_groundAnchor1), t
            }, A.prototype.GetGroundAnchorB = function() {
                var t = this.m_ground.m_xf.position.Copy();
                return t.Add(this.m_groundAnchor2), t
            }, A.prototype.GetLength1 = function() {
                var t = this.m_bodyA.GetWorldPoint(this.m_localAnchor1),
                    i = t.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x);
                return t = t.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y), Math.sqrt(i * i + t * t)
            }, A.prototype.GetLength2 = function() {
                var t = this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
                    i = t.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor2.x);
                return t = t.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor2.y), Math.sqrt(i * i + t * t)
            }, A.prototype.GetRatio = function() {
                return this.m_ratio
            }, A.prototype.b2PulleyJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_ground = this.m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = t.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = t.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = t.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = t.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_maxLength1 = n.Min(t.maxLengthA, this.m_constant - this.m_ratio * A.b2_minPulleyLength), this.m_maxLength2 = n.Min(t.maxLengthB, (this.m_constant - A.b2_minPulleyLength) / this.m_ratio), this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
            }, A.prototype.InitVelocityConstraints = function(i) {
                var o, e = this.m_bodyA,
                    n = this.m_bodyB;
                o = e.m_xf.R;
                var s = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                    r = this.m_localAnchor1.y - e.m_sweep.localCenter.y,
                    a = o.col1.x * s + o.col2.x * r;
                r = o.col1.y * s + o.col2.y * r, s = a, o = n.m_xf.R;
                var l = this.m_localAnchor2.x - n.m_sweep.localCenter.x,
                    m = this.m_localAnchor2.y - n.m_sweep.localCenter.y;
                a = o.col1.x * l + o.col2.x * m, m = o.col1.y * l + o.col2.y * m, l = a, o = n.m_sweep.c.x + l, a = n.m_sweep.c.y + m;
                var c = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                    h = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
                this.m_u1.Set(e.m_sweep.c.x + s - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), e.m_sweep.c.y + r - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y)), this.m_u2.Set(o - c, a - h), o = this.m_u1.Length(), a = this.m_u2.Length(), o > t.b2_linearSlop ? this.m_u1.Multiply(1 / o) : this.m_u1.SetZero(), a > t.b2_linearSlop ? this.m_u2.Multiply(1 / a) : this.m_u2.SetZero(), this.m_constant - o - this.m_ratio * a > 0 ? (this.m_state = y.e_inactiveLimit, this.m_impulse = 0) : this.m_state = y.e_atUpperLimit, o < this.m_maxLength1 ? (this.m_limitState1 = y.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = y.e_atUpperLimit, a < this.m_maxLength2 ? (this.m_limitState2 = y.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = y.e_atUpperLimit, o = s * this.m_u1.y - r * this.m_u1.x, a = l * this.m_u2.y - m * this.m_u2.x, this.m_limitMass1 = e.m_invMass + e.m_invI * o * o, this.m_limitMass2 = n.m_invMass + n.m_invI * a * a, this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, i.warmStarting ? (this.m_impulse *= i.dtRatio, this.m_limitImpulse1 *= i.dtRatio, this.m_limitImpulse2 *= i.dtRatio, i = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, o = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, a = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, c = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y, e.m_linearVelocity.x += e.m_invMass * i, e.m_linearVelocity.y += e.m_invMass * o, e.m_angularVelocity += e.m_invI * (s * o - r * i), n.m_linearVelocity.x += n.m_invMass * a, n.m_linearVelocity.y += n.m_invMass * c, n.m_angularVelocity += n.m_invI * (l * c - m * a)) : this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
            }, A.prototype.SolveVelocityConstraints = function() {
                var t, i = this.m_bodyA,
                    o = this.m_bodyB;
                t = i.m_xf.R;
                var e = this.m_localAnchor1.x - i.m_sweep.localCenter.x,
                    s = this.m_localAnchor1.y - i.m_sweep.localCenter.y,
                    r = t.col1.x * e + t.col2.x * s;
                s = t.col1.y * e + t.col2.y * s, e = r, t = o.m_xf.R;
                var a = this.m_localAnchor2.x - o.m_sweep.localCenter.x,
                    l = this.m_localAnchor2.y - o.m_sweep.localCenter.y;
                r = t.col1.x * a + t.col2.x * l, l = t.col1.y * a + t.col2.y * l, a = r;
                var m = r = t = 0,
                    c = 0;
                t = c = t = c = m = r = t = 0, this.m_state == y.e_atUpperLimit && (t = i.m_linearVelocity.x + -i.m_angularVelocity * s, r = i.m_linearVelocity.y + i.m_angularVelocity * e, m = o.m_linearVelocity.x + -o.m_angularVelocity * l, c = o.m_linearVelocity.y + o.m_angularVelocity * a, t = -(this.m_u1.x * t + this.m_u1.y * r) - this.m_ratio * (this.m_u2.x * m + this.m_u2.y * c), c = this.m_pulleyMass * -t, t = this.m_impulse, this.m_impulse = n.Max(0, this.m_impulse + c), t = -(c = this.m_impulse - t) * this.m_u1.x, r = -c * this.m_u1.y, m = -this.m_ratio * c * this.m_u2.x, c = -this.m_ratio * c * this.m_u2.y, i.m_linearVelocity.x += i.m_invMass * t, i.m_linearVelocity.y += i.m_invMass * r, i.m_angularVelocity += i.m_invI * (e * r - s * t), o.m_linearVelocity.x += o.m_invMass * m, o.m_linearVelocity.y += o.m_invMass * c, o.m_angularVelocity += o.m_invI * (a * c - l * m)), this.m_limitState1 == y.e_atUpperLimit && (t = i.m_linearVelocity.x + -i.m_angularVelocity * s, r = i.m_linearVelocity.y + i.m_angularVelocity * e, t = -(this.m_u1.x * t + this.m_u1.y * r), c = -this.m_limitMass1 * t, t = this.m_limitImpulse1, this.m_limitImpulse1 = n.Max(0, this.m_limitImpulse1 + c), t = -(c = this.m_limitImpulse1 - t) * this.m_u1.x, r = -c * this.m_u1.y, i.m_linearVelocity.x += i.m_invMass * t, i.m_linearVelocity.y += i.m_invMass * r, i.m_angularVelocity += i.m_invI * (e * r - s * t)), this.m_limitState2 == y.e_atUpperLimit && (m = o.m_linearVelocity.x + -o.m_angularVelocity * l, c = o.m_linearVelocity.y + o.m_angularVelocity * a, t = -(this.m_u2.x * m + this.m_u2.y * c), c = -this.m_limitMass2 * t, t = this.m_limitImpulse2, this.m_limitImpulse2 = n.Max(0, this.m_limitImpulse2 + c), m = -(c = this.m_limitImpulse2 - t) * this.m_u2.x, c = -c * this.m_u2.y, o.m_linearVelocity.x += o.m_invMass * m, o.m_linearVelocity.y += o.m_invMass * c, o.m_angularVelocity += o.m_invI * (a * c - l * m))
            }, A.prototype.SolvePositionConstraints = function() {
                var i, o = this.m_bodyA,
                    e = this.m_bodyB,
                    s = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
                    r = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
                    a = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
                    l = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
                    m = 0,
                    c = 0,
                    h = 0,
                    _ = 0,
                    p = i = 0,
                    u = 0,
                    x = 0,
                    f = p = x = i = p = i = 0;
                return this.m_state == y.e_atUpperLimit && (i = o.m_xf.R, m = this.m_localAnchor1.x - o.m_sweep.localCenter.x, c = this.m_localAnchor1.y - o.m_sweep.localCenter.y, p = i.col1.x * m + i.col2.x * c, c = i.col1.y * m + i.col2.y * c, m = p, i = e.m_xf.R, h = this.m_localAnchor2.x - e.m_sweep.localCenter.x, _ = this.m_localAnchor2.y - e.m_sweep.localCenter.y, p = i.col1.x * h + i.col2.x * _, _ = i.col1.y * h + i.col2.y * _, h = p, i = o.m_sweep.c.x + m, p = o.m_sweep.c.y + c, u = e.m_sweep.c.x + h, x = e.m_sweep.c.y + _, this.m_u1.Set(i - s, p - r), this.m_u2.Set(u - a, x - l), i = this.m_u1.Length(), p = this.m_u2.Length(), i > t.b2_linearSlop ? this.m_u1.Multiply(1 / i) : this.m_u1.SetZero(), p > t.b2_linearSlop ? this.m_u2.Multiply(1 / p) : this.m_u2.SetZero(), i = this.m_constant - i - this.m_ratio * p, f = n.Max(f, -i), i = n.Clamp(i + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), i = -(x = -this.m_pulleyMass * i) * this.m_u1.x, p = -x * this.m_u1.y, u = -this.m_ratio * x * this.m_u2.x, x = -this.m_ratio * x * this.m_u2.y, o.m_sweep.c.x += o.m_invMass * i, o.m_sweep.c.y += o.m_invMass * p, o.m_sweep.a += o.m_invI * (m * p - c * i), e.m_sweep.c.x += e.m_invMass * u, e.m_sweep.c.y += e.m_invMass * x, e.m_sweep.a += e.m_invI * (h * x - _ * u), o.SynchronizeTransform(), e.SynchronizeTransform()), this.m_limitState1 == y.e_atUpperLimit && (i = o.m_xf.R, m = this.m_localAnchor1.x - o.m_sweep.localCenter.x, c = this.m_localAnchor1.y - o.m_sweep.localCenter.y, p = i.col1.x * m + i.col2.x * c, c = i.col1.y * m + i.col2.y * c, m = p, i = o.m_sweep.c.x + m, p = o.m_sweep.c.y + c, this.m_u1.Set(i - s, p - r), (i = this.m_u1.Length()) > t.b2_linearSlop ? (this.m_u1.x *= 1 / i, this.m_u1.y *= 1 / i) : this.m_u1.SetZero(), i = this.m_maxLength1 - i, f = n.Max(f, -i), i = n.Clamp(i + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), i = -(x = -this.m_limitMass1 * i) * this.m_u1.x, p = -x * this.m_u1.y, o.m_sweep.c.x += o.m_invMass * i, o.m_sweep.c.y += o.m_invMass * p, o.m_sweep.a += o.m_invI * (m * p - c * i), o.SynchronizeTransform()), this.m_limitState2 == y.e_atUpperLimit && (i = e.m_xf.R, h = this.m_localAnchor2.x - e.m_sweep.localCenter.x, _ = this.m_localAnchor2.y - e.m_sweep.localCenter.y, p = i.col1.x * h + i.col2.x * _, _ = i.col1.y * h + i.col2.y * _, h = p, u = e.m_sweep.c.x + h, x = e.m_sweep.c.y + _, this.m_u2.Set(u - a, x - l), (p = this.m_u2.Length()) > t.b2_linearSlop ? (this.m_u2.x *= 1 / p, this.m_u2.y *= 1 / p) : this.m_u2.SetZero(), i = this.m_maxLength2 - p, f = n.Max(f, -i), i = n.Clamp(i + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), u = -(x = -this.m_limitMass2 * i) * this.m_u2.x, x = -x * this.m_u2.y, e.m_sweep.c.x += e.m_invMass * u, e.m_sweep.c.y += e.m_invMass * x, e.m_sweep.a += e.m_invI * (h * x - _ * u), e.SynchronizeTransform()), f < t.b2_linearSlop
            }, o.postDefs.push(function() {
                o.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2
            }), o.inherit(g, o.Dynamics.Joints.b2JointDef), g.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, g.b2PulleyJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new s, this.groundAnchorB = new s, this.localAnchorA = new s, this.localAnchorB = new s
            }, g.prototype.b2PulleyJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.maxLengthB = this.lengthB = this.maxLengthA = this.lengthA = 0, this.ratio = 1, this.collideConnected = !0
            }, g.prototype.Initialize = function(t, i, o, e, n, s, r) {
                void 0 === r && (r = 0), this.bodyA = t, this.bodyB = i, this.groundAnchorA.SetV(o), this.groundAnchorB.SetV(e), this.localAnchorA = this.bodyA.GetLocalPoint(n), this.localAnchorB = this.bodyB.GetLocalPoint(s), t = n.x - o.x, o = n.y - o.y, this.lengthA = Math.sqrt(t * t + o * o), o = s.x - e.x, e = s.y - e.y, this.lengthB = Math.sqrt(o * o + e * e), this.ratio = r, r = this.lengthA + this.ratio * this.lengthB, this.maxLengthA = r - this.ratio * A.b2_minPulleyLength, this.maxLengthB = (r - A.b2_minPulleyLength) / this.ratio
            }, o.inherit(S, o.Dynamics.Joints.b2Joint), S.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, S.b2RevoluteJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new i, this.K1 = new i, this.K2 = new i, this.K3 = new i, this.impulse3 = new r, this.impulse2 = new s, this.reduced = new s, this.m_localAnchor1 = new s, this.m_localAnchor2 = new s, this.m_impulse = new r, this.m_mass = new e
            }, S.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
            }, S.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
            }, S.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse.x, t * this.m_impulse.y)
            }, S.prototype.GetReactionTorque = function(t) {
                return void 0 === t && (t = 0), t * this.m_impulse.z
            }, S.prototype.GetJointAngle = function() {
                return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
            }, S.prototype.GetJointSpeed = function() {
                return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
            }, S.prototype.IsLimitEnabled = function() {
                return this.m_enableLimit
            }, S.prototype.EnableLimit = function(t) {
                this.m_enableLimit = t
            }, S.prototype.GetLowerLimit = function() {
                return this.m_lowerAngle
            }, S.prototype.GetUpperLimit = function() {
                return this.m_upperAngle
            }, S.prototype.SetLimits = function(t, i) {
                void 0 === t && (t = 0), void 0 === i && (i = 0), this.m_lowerAngle = t, this.m_upperAngle = i
            }, S.prototype.IsMotorEnabled = function() {
                return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor
            }, S.prototype.EnableMotor = function(t) {
                this.m_enableMotor = t
            }, S.prototype.SetMotorSpeed = function(t) {
                void 0 === t && (t = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t
            }, S.prototype.GetMotorSpeed = function() {
                return this.m_motorSpeed
            }, S.prototype.SetMaxMotorTorque = function(t) {
                void 0 === t && (t = 0), this.m_maxMotorTorque = t
            }, S.prototype.GetMotorTorque = function() {
                return this.m_maxMotorTorque
            }, S.prototype.b2RevoluteJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchor1.SetV(t.localAnchorA), this.m_localAnchor2.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = y.e_inactiveLimit
            }, S.prototype.InitVelocityConstraints = function(i) {
                var o, e = this.m_bodyA,
                    s = this.m_bodyB,
                    r = 0;
                o = e.m_xf.R;
                var a = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
                    l = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
                r = o.col1.x * a + o.col2.x * l, l = o.col1.y * a + o.col2.y * l, a = r, o = s.m_xf.R;
                var m = this.m_localAnchor2.x - s.m_sweep.localCenter.x,
                    c = this.m_localAnchor2.y - s.m_sweep.localCenter.y;
                r = o.col1.x * m + o.col2.x * c, c = o.col1.y * m + o.col2.y * c, m = r, o = e.m_invMass, r = s.m_invMass;
                var h = e.m_invI,
                    _ = s.m_invI;
                if (this.m_mass.col1.x = o + r + l * l * h + c * c * _, this.m_mass.col2.x = -l * a * h - c * m * _, this.m_mass.col3.x = -l * h - c * _, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = o + r + a * a * h + m * m * _, this.m_mass.col3.y = a * h + m * _, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = h + _, this.m_motorMass = 1 / (h + _), 0 == this.m_enableMotor && (this.m_motorImpulse = 0), this.m_enableLimit) {
                    var p = s.m_sweep.a - e.m_sweep.a - this.m_referenceAngle;
                    n.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * t.b2_angularSlop ? this.m_limitState = y.e_equalLimits : p <= this.m_lowerAngle ? (this.m_limitState != y.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = y.e_atLowerLimit) : p >= this.m_upperAngle ? (this.m_limitState != y.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = y.e_atUpperLimit) : (this.m_limitState = y.e_inactiveLimit, this.m_impulse.z = 0)
                } else this.m_limitState = y.e_inactiveLimit;
                i.warmStarting ? (this.m_impulse.x *= i.dtRatio, this.m_impulse.y *= i.dtRatio, this.m_motorImpulse *= i.dtRatio, i = this.m_impulse.x, p = this.m_impulse.y, e.m_linearVelocity.x -= o * i, e.m_linearVelocity.y -= o * p, e.m_angularVelocity -= h * (a * p - l * i + this.m_motorImpulse + this.m_impulse.z), s.m_linearVelocity.x += r * i, s.m_linearVelocity.y += r * p, s.m_angularVelocity += _ * (m * p - c * i + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
            }, S.prototype.SolveVelocityConstraints = function(t) {
                var i = this.m_bodyA,
                    o = this.m_bodyB,
                    e = 0,
                    s = e = 0,
                    r = 0,
                    a = 0,
                    l = 0,
                    m = i.m_linearVelocity,
                    c = i.m_angularVelocity,
                    h = o.m_linearVelocity,
                    _ = o.m_angularVelocity,
                    p = i.m_invMass,
                    u = o.m_invMass,
                    x = i.m_invI,
                    f = o.m_invI;
                if (this.m_enableMotor && this.m_limitState != y.e_equalLimits && (s = this.m_motorMass * -(_ - c - this.m_motorSpeed), r = this.m_motorImpulse, a = t.dt * this.m_maxMotorTorque, this.m_motorImpulse = n.Clamp(this.m_motorImpulse + s, -a, a), c -= x * (s = this.m_motorImpulse - r), _ += f * s), this.m_enableLimit && this.m_limitState != y.e_inactiveLimit) {
                    t = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, r = this.m_localAnchor1.y - i.m_sweep.localCenter.y, e = t.col1.x * s + t.col2.x * r, r = t.col1.y * s + t.col2.y * r, s = e, t = o.m_xf.R, a = this.m_localAnchor2.x - o.m_sweep.localCenter.x, l = this.m_localAnchor2.y - o.m_sweep.localCenter.y, e = t.col1.x * a + t.col2.x * l, l = t.col1.y * a + t.col2.y * l, a = e, t = h.x + -_ * l - m.x - -c * r;
                    var d = h.y + _ * a - m.y - c * s;
                    this.m_mass.Solve33(this.impulse3, -t, -d, -(_ - c)), this.m_limitState == y.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == y.e_atLowerLimit ? (e = this.m_impulse.z + this.impulse3.z) < 0 && (this.m_mass.Solve22(this.reduced, -t, -d), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0) : this.m_limitState == y.e_atUpperLimit && (e = this.m_impulse.z + this.impulse3.z) > 0 && (this.m_mass.Solve22(this.reduced, -t, -d), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0), m.x -= p * this.impulse3.x, m.y -= p * this.impulse3.y, c -= x * (s * this.impulse3.y - r * this.impulse3.x + this.impulse3.z), h.x += u * this.impulse3.x, h.y += u * this.impulse3.y, _ += f * (a * this.impulse3.y - l * this.impulse3.x + this.impulse3.z)
                } else t = i.m_xf.R, s = this.m_localAnchor1.x - i.m_sweep.localCenter.x, r = this.m_localAnchor1.y - i.m_sweep.localCenter.y, e = t.col1.x * s + t.col2.x * r, r = t.col1.y * s + t.col2.y * r, s = e, t = o.m_xf.R, a = this.m_localAnchor2.x - o.m_sweep.localCenter.x, l = this.m_localAnchor2.y - o.m_sweep.localCenter.y, e = t.col1.x * a + t.col2.x * l, l = t.col1.y * a + t.col2.y * l, a = e, this.m_mass.Solve22(this.impulse2, -(h.x + -_ * l - m.x - -c * r), -(h.y + _ * a - m.y - c * s)), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, m.x -= p * this.impulse2.x, m.y -= p * this.impulse2.y, c -= x * (s * this.impulse2.y - r * this.impulse2.x), h.x += u * this.impulse2.x, h.y += u * this.impulse2.y, _ += f * (a * this.impulse2.y - l * this.impulse2.x);
                i.m_linearVelocity.SetV(m), i.m_angularVelocity = c, o.m_linearVelocity.SetV(h), o.m_angularVelocity = _
            }, S.prototype.SolvePositionConstraints = function() {
                var i, o = 0,
                    e = this.m_bodyA,
                    s = this.m_bodyB,
                    r = 0,
                    a = i = 0,
                    l = 0,
                    m = 0;
                if (this.m_enableLimit && this.m_limitState != y.e_inactiveLimit) {
                    o = s.m_sweep.a - e.m_sweep.a - this.m_referenceAngle;
                    var c = 0;
                    this.m_limitState == y.e_equalLimits ? (o = n.Clamp(o - this.m_lowerAngle, -t.b2_maxAngularCorrection, t.b2_maxAngularCorrection), c = -this.m_motorMass * o, r = n.Abs(o)) : this.m_limitState == y.e_atLowerLimit ? (r = -(o -= this.m_lowerAngle), o = n.Clamp(o + t.b2_angularSlop, -t.b2_maxAngularCorrection, 0), c = -this.m_motorMass * o) : this.m_limitState == y.e_atUpperLimit && (r = o -= this.m_upperAngle, o = n.Clamp(o - t.b2_angularSlop, 0, t.b2_maxAngularCorrection), c = -this.m_motorMass * o), e.m_sweep.a -= e.m_invI * c, s.m_sweep.a += s.m_invI * c, e.SynchronizeTransform(), s.SynchronizeTransform()
                }
                i = e.m_xf.R, c = this.m_localAnchor1.x - e.m_sweep.localCenter.x, o = this.m_localAnchor1.y - e.m_sweep.localCenter.y, a = i.col1.x * c + i.col2.x * o, o = i.col1.y * c + i.col2.y * o, c = a, i = s.m_xf.R;
                var h = this.m_localAnchor2.x - s.m_sweep.localCenter.x,
                    _ = this.m_localAnchor2.y - s.m_sweep.localCenter.y;
                a = i.col1.x * h + i.col2.x * _, _ = i.col1.y * h + i.col2.y * _, h = a;
                var p = (l = s.m_sweep.c.x + h - e.m_sweep.c.x - c) * l + (m = s.m_sweep.c.y + _ - e.m_sweep.c.y - o) * m;
                i = Math.sqrt(p), a = e.m_invMass;
                var u = s.m_invMass,
                    x = e.m_invI,
                    f = s.m_invI,
                    d = 10 * t.b2_linearSlop;
                return p > d * d && (l = (p = 1 / (a + u)) * -l, m = p * -m, e.m_sweep.c.x -= .5 * a * l, e.m_sweep.c.y -= .5 * a * m, s.m_sweep.c.x += .5 * u * l, s.m_sweep.c.y += .5 * u * m, l = s.m_sweep.c.x + h - e.m_sweep.c.x - c, m = s.m_sweep.c.y + _ - e.m_sweep.c.y - o), this.K1.col1.x = a + u, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = a + u, this.K2.col1.x = x * o * o, this.K2.col2.x = -x * c * o, this.K2.col1.y = -x * c * o, this.K2.col2.y = x * c * c, this.K3.col1.x = f * _ * _, this.K3.col2.x = -f * h * _, this.K3.col1.y = -f * h * _, this.K3.col2.y = f * h * h, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(S.tImpulse, -l, -m), l = S.tImpulse.x, m = S.tImpulse.y, e.m_sweep.c.x -= e.m_invMass * l, e.m_sweep.c.y -= e.m_invMass * m, e.m_sweep.a -= e.m_invI * (c * m - o * l), s.m_sweep.c.x += s.m_invMass * l, s.m_sweep.c.y += s.m_invMass * m, s.m_sweep.a += s.m_invI * (h * m - _ * l), e.SynchronizeTransform(), s.SynchronizeTransform(), i <= t.b2_linearSlop && r <= t.b2_angularSlop
            }, o.postDefs.push(function() {
                o.Dynamics.Joints.b2RevoluteJoint.tImpulse = new s
            }), o.inherit(B, o.Dynamics.Joints.b2JointDef), B.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, B.b2RevoluteJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s
            }, B.prototype.b2RevoluteJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.motorSpeed = this.maxMotorTorque = this.upperAngle = this.lowerAngle = this.referenceAngle = 0, this.enableMotor = this.enableLimit = !1
            }, B.prototype.Initialize = function(t, i, o) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA = this.bodyA.GetLocalPoint(o), this.localAnchorB = this.bodyB.GetLocalPoint(o), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
            }, o.inherit(M, o.Dynamics.Joints.b2Joint), M.prototype.__super = o.Dynamics.Joints.b2Joint.prototype, M.b2WeldJoint = function() {
                o.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new s, this.m_localAnchorB = new s, this.m_impulse = new r, this.m_mass = new e
            }, M.prototype.GetAnchorA = function() {
                return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
            }, M.prototype.GetAnchorB = function() {
                return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
            }, M.prototype.GetReactionForce = function(t) {
                return void 0 === t && (t = 0), new s(t * this.m_impulse.x, t * this.m_impulse.y)
            }, M.prototype.GetReactionTorque = function(t) {
                return void 0 === t && (t = 0), t * this.m_impulse.z
            }, M.prototype.b2WeldJoint = function(t) {
                this.__super.b2Joint.call(this, t), this.m_localAnchorA.SetV(t.localAnchorA), this.m_localAnchorB.SetV(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new e
            }, M.prototype.InitVelocityConstraints = function(t) {
                var i, o = 0,
                    e = this.m_bodyA,
                    n = this.m_bodyB;
                i = e.m_xf.R;
                var s = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
                    r = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
                o = i.col1.x * s + i.col2.x * r, r = i.col1.y * s + i.col2.y * r, s = o, i = n.m_xf.R;
                var a = this.m_localAnchorB.x - n.m_sweep.localCenter.x,
                    l = this.m_localAnchorB.y - n.m_sweep.localCenter.y;
                o = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = o, i = e.m_invMass, o = n.m_invMass;
                var m = e.m_invI,
                    c = n.m_invI;
                this.m_mass.col1.x = i + o + r * r * m + l * l * c, this.m_mass.col2.x = -r * s * m - l * a * c, this.m_mass.col3.x = -r * m - l * c, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = i + o + s * s * m + a * a * c, this.m_mass.col3.y = s * m + a * c, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = m + c, t.warmStarting ? (this.m_impulse.x *= t.dtRatio, this.m_impulse.y *= t.dtRatio, this.m_impulse.z *= t.dtRatio, e.m_linearVelocity.x -= i * this.m_impulse.x, e.m_linearVelocity.y -= i * this.m_impulse.y, e.m_angularVelocity -= m * (s * this.m_impulse.y - r * this.m_impulse.x + this.m_impulse.z), n.m_linearVelocity.x += o * this.m_impulse.x, n.m_linearVelocity.y += o * this.m_impulse.y, n.m_angularVelocity += c * (a * this.m_impulse.y - l * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
            }, M.prototype.SolveVelocityConstraints = function() {
                var t, i = 0,
                    o = this.m_bodyA,
                    e = this.m_bodyB,
                    n = o.m_linearVelocity,
                    s = o.m_angularVelocity,
                    a = e.m_linearVelocity,
                    l = e.m_angularVelocity,
                    m = o.m_invMass,
                    c = e.m_invMass,
                    h = o.m_invI,
                    _ = e.m_invI;
                t = o.m_xf.R;
                var p = this.m_localAnchorA.x - o.m_sweep.localCenter.x,
                    y = this.m_localAnchorA.y - o.m_sweep.localCenter.y;
                i = t.col1.x * p + t.col2.x * y, y = t.col1.y * p + t.col2.y * y, p = i, t = e.m_xf.R;
                var u = this.m_localAnchorB.x - e.m_sweep.localCenter.x,
                    x = this.m_localAnchorB.y - e.m_sweep.localCenter.y;
                i = t.col1.x * u + t.col2.x * x, x = t.col1.y * u + t.col2.y * x, u = i, t = a.x - l * x - n.x + s * y, i = a.y + l * u - n.y - s * p;
                var f = l - s,
                    d = new r;
                this.m_mass.Solve33(d, -t, -i, -f), this.m_impulse.Add(d), n.x -= m * d.x, n.y -= m * d.y, s -= h * (p * d.y - y * d.x + d.z), a.x += c * d.x, a.y += c * d.y, l += _ * (u * d.y - x * d.x + d.z), o.m_angularVelocity = s, e.m_angularVelocity = l
            }, M.prototype.SolvePositionConstraints = function() {
                var i, o = 0,
                    e = this.m_bodyA,
                    s = this.m_bodyB;
                i = e.m_xf.R;
                var a = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
                    l = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
                o = i.col1.x * a + i.col2.x * l, l = i.col1.y * a + i.col2.y * l, a = o, i = s.m_xf.R;
                var m = this.m_localAnchorB.x - s.m_sweep.localCenter.x,
                    c = this.m_localAnchorB.y - s.m_sweep.localCenter.y;
                o = i.col1.x * m + i.col2.x * c, c = i.col1.y * m + i.col2.y * c, m = o, i = e.m_invMass, o = s.m_invMass;
                var h = e.m_invI,
                    _ = s.m_invI,
                    p = s.m_sweep.c.x + m - e.m_sweep.c.x - a,
                    y = s.m_sweep.c.y + c - e.m_sweep.c.y - l,
                    u = s.m_sweep.a - e.m_sweep.a - this.m_referenceAngle,
                    x = 10 * t.b2_linearSlop,
                    f = Math.sqrt(p * p + y * y),
                    d = n.Abs(u);
                return f > x && (h *= 1, _ *= 1), this.m_mass.col1.x = i + o + l * l * h + c * c * _, this.m_mass.col2.x = -l * a * h - c * m * _, this.m_mass.col3.x = -l * h - c * _, this.m_mass.col1.y = this.m_mass.col2.x, this.m_mass.col2.y = i + o + a * a * h + m * m * _, this.m_mass.col3.y = a * h + m * _, this.m_mass.col1.z = this.m_mass.col3.x, this.m_mass.col2.z = this.m_mass.col3.y, this.m_mass.col3.z = h + _, x = new r, this.m_mass.Solve33(x, -p, -y, -u), e.m_sweep.c.x -= i * x.x, e.m_sweep.c.y -= i * x.y, e.m_sweep.a -= h * (a * x.y - l * x.x + x.z), s.m_sweep.c.x += o * x.x, s.m_sweep.c.y += o * x.y, s.m_sweep.a += _ * (m * x.y - c * x.x + x.z), e.SynchronizeTransform(), s.SynchronizeTransform(), f <= t.b2_linearSlop && d <= t.b2_angularSlop
            }, o.inherit(V, o.Dynamics.Joints.b2JointDef), V.prototype.__super = o.Dynamics.Joints.b2JointDef.prototype, V.b2WeldJointDef = function() {
                o.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s, this.localAnchorB = new s
            }, V.prototype.b2WeldJointDef = function() {
                this.__super.b2JointDef.call(this), this.type = y.e_weldJoint, this.referenceAngle = 0
            }, V.prototype.Initialize = function(t, i, o) {
                this.bodyA = t, this.bodyB = i, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(o)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(o)), this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
            }
        }(), function() {
            var t = o.Dynamics.b2DebugDraw;
            t.b2DebugDraw = function() {
                this.m_xformScale = this.m_fillAlpha = this.m_alpha = this.m_lineThickness = this.m_drawScale = 1;
                var t = this;
                this.m_sprite = {
                    graphics: {
                        clear: function() {
                            t.m_ctx.clearRect(0, 0, t.m_ctx.canvas.width, t.m_ctx.canvas.height)
                        }
                    }
                }
            }, t.prototype._color = function(t, i) {
                return "rgba(" + ((16711680 & t) >> 16) + "," + ((65280 & t) >> 8) + "," + (255 & t) + "," + i + ")"
            }, t.prototype.b2DebugDraw = function() {
                this.m_drawFlags = 0
            }, t.prototype.SetFlags = function(t) {
                void 0 === t && (t = 0), this.m_drawFlags = t
            }, t.prototype.GetFlags = function() {
                return this.m_drawFlags
            }, t.prototype.AppendFlags = function(t) {
                void 0 === t && (t = 0), this.m_drawFlags |= t
            }, t.prototype.ClearFlags = function(t) {
                void 0 === t && (t = 0), this.m_drawFlags &= ~t
            }, t.prototype.SetSprite = function(t) {
                this.m_ctx = t
            }, t.prototype.GetSprite = function() {
                return this.m_ctx
            }, t.prototype.SetDrawScale = function(t) {
                void 0 === t && (t = 0), this.m_drawScale = t
            }, t.prototype.GetDrawScale = function() {
                return this.m_drawScale
            }, t.prototype.SetLineThickness = function(t) {
                void 0 === t && (t = 0), this.m_lineThickness = t, this.m_ctx.strokeWidth = t
            }, t.prototype.GetLineThickness = function() {
                return this.m_lineThickness
            }, t.prototype.SetAlpha = function(t) {
                void 0 === t && (t = 0), this.m_alpha = t
            }, t.prototype.GetAlpha = function() {
                return this.m_alpha
            }, t.prototype.SetFillAlpha = function(t) {
                void 0 === t && (t = 0), this.m_fillAlpha = t
            }, t.prototype.GetFillAlpha = function() {
                return this.m_fillAlpha
            }, t.prototype.SetXFormScale = function(t) {
                void 0 === t && (t = 0), this.m_xformScale = t
            }, t.prototype.GetXFormScale = function() {
                return this.m_xformScale
            }, t.prototype.DrawPolygon = function(t, i, o) {
                if (i) {
                    var e = this.m_ctx,
                        n = this.m_drawScale;
                    for (e.beginPath(), e.strokeStyle = this._color(o.color, this.m_alpha), e.moveTo(t[0].x * n, t[0].y * n), o = 1; o < i; o++) e.lineTo(t[o].x * n, t[o].y * n);
                    e.lineTo(t[0].x * n, t[0].y * n), e.closePath(), e.stroke()
                }
            }, t.prototype.DrawSolidPolygon = function(t, i, o) {
                if (i) {
                    var e = this.m_ctx,
                        n = this.m_drawScale;
                    for (e.beginPath(), e.strokeStyle = this._color(o.color, this.m_alpha), e.fillStyle = this._color(o.color, this.m_fillAlpha), e.moveTo(t[0].x * n, t[0].y * n), o = 1; o < i; o++) e.lineTo(t[o].x * n, t[o].y * n);
                    e.lineTo(t[0].x * n, t[0].y * n), e.closePath(), e.fill(), e.stroke()
                }
            }, t.prototype.DrawCircle = function(t, i, o) {
                if (i) {
                    var e = this.m_ctx,
                        n = this.m_drawScale;
                    e.beginPath(), e.strokeStyle = this._color(o.color, this.m_alpha), e.arc(t.x * n, t.y * n, i * n, 0, 2 * Math.PI, !0), e.closePath(), e.stroke()
                }
            }, t.prototype.DrawSolidCircle = function(t, i, o, e) {
                if (i) {
                    var n = this.m_ctx,
                        s = this.m_drawScale,
                        r = t.x * s,
                        a = t.y * s;
                    n.moveTo(0, 0), n.beginPath(), n.strokeStyle = this._color(e.color, this.m_alpha), n.fillStyle = this._color(e.color, this.m_fillAlpha), n.arc(r, a, i * s, 0, 2 * Math.PI, !0), n.moveTo(r, a), n.lineTo((t.x + o.x * i) * s, (t.y + o.y * i) * s), n.closePath(), n.fill(), n.stroke()
                }
            }, t.prototype.DrawSegment = function(t, i, o) {
                var e = this.m_ctx,
                    n = this.m_drawScale;
                e.strokeStyle = this._color(o.color, this.m_alpha), e.beginPath(), e.moveTo(t.x * n, t.y * n), e.lineTo(i.x * n, i.y * n), e.closePath(), e.stroke()
            }, t.prototype.DrawTransform = function(t) {
                var i = this.m_ctx,
                    o = this.m_drawScale;
                i.beginPath(), i.strokeStyle = this._color(16711680, this.m_alpha), i.moveTo(t.position.x * o, t.position.y * o), i.lineTo((t.position.x + this.m_xformScale * t.R.col1.x) * o, (t.position.y + this.m_xformScale * t.R.col1.y) * o), i.strokeStyle = this._color(65280, this.m_alpha), i.moveTo(t.position.x * o, t.position.y * o), i.lineTo((t.position.x + this.m_xformScale * t.R.col2.x) * o, (t.position.y + this.m_xformScale * t.R.col2.y) * o), i.closePath(), i.stroke()
            }
        }(), N = 0; N < o.postDefs.length; ++N) o.postDefs[N]();
    delete o.postDefs, ig.module("plugins.box2d.lib").defines(function() {})
}, function(t, i) {
    var o;
    o = function() {
        return this
    }();
    try {
        o = o || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (o = window)
    }
    t.exports = o
}, function(t, i, o) {
    "use strict";
    o.d(i, "a", function() {
        return n
    }), o.d(i, "b", function() {
        return e
    });
    class e {
        constructor(t, i) {
            var o = {
                elapsed: 0,
                tframe: 1e3 / i,
                before: window.performance.now(),
                main: function() {
                    o.startLoop = window.requestAnimationFrame(o.main), o.fps = Math.round(1e3 / (window.performance.now() - o.before) * 100 / 100), window.performance.now() < o.before + o.tframe || (o.before = window.performance.now(), o.stopLoop = () => {
                        window.cancelAnimationFrame(o.startLoop)
                    }, t.update(o.elapsed, o.fps), t.render(o.elapsed, o.fps), o.elapsed++)
                }
            };
            return o.main(), o
        }
    }
    class n {
        constructor(t, i, o) {
            o = document.querySelector(o || "body");
            var e = document.createElement("canvas"),
                n = e.getContext("2d"),
                s = window.devicePixelRatio / ["webkitBackingStorePixelRatio", "mozBackingStorePixelRatio", "msBackingStorePixelRatio", "oBackingStorePixelRatio", "backingStorePixelRatio"].reduce(function(t, i) {
                    return Object.prototype.hasOwnProperty.call(n, i) ? n[i] : 1
                });
            return e.width = Math.round(t * s), e.height = Math.round(i * s), e.style.width = t + "px", e.style.height = i + "px", n.setTransform(s, 0, 0, s, 0, 0), o.insertBefore(e, o.firstChild), e.context = e.getContext("2d"), e.resize = (t, i) => {
                e.style.width = i.x + "px", e.style.height = i.y + "px", e.width = Math.round(i.x * s), e.height = Math.round(i.y * s), n.setTransform(s, 0, 0, s, 0, 0), t.state.size.x = i.x, t.state.size.y = i.y
            }, e.clear = (t, i, o, n) => {
                t = t || 0, i = i || 0, o = o || e.width, n = n || e.height, e.context.clearRect(t, i, o, n)
            }, e.camera = (t, i) => {
                e.context.setTransform(1, 0, 0, 1, 0, 0), e.context.translate(-t, -i)
            }, e
        }
    }
}, function(t, i, o) {
    "use strict";
    o.r(i), o.d(i, "Vector", function() {
        return l
    }), o.d(i, "boundary", function() {
        return a
    }), o.d(i, "degToRad", function() {
        return e
    }), o.d(i, "radToDeg", function() {
        return n
    }), o.d(i, "distance", function() {
        return s
    }), o.d(i, "map", function() {
        return r
    });
    const e = function(t) {
            return t * Math.PI / 180
        },
        n = function(t) {
            return 180 * t / Math.PI
        },
        s = function(t, i, o, e) {
            return Math.sqrt((o - t) * (o - t) + (e - i) * (e - i))
        },
        r = function(t, i, o, e, n) {
            return e + (n - e) * (t - i) / (o - i)
        },
        a = function(t, i, o) {
            return Math.min(Math.max(t, i), o)
        },
        l = function(t, i) {
            this.x = t || 0, this.y = i || 0
        };
    l.prototype = {
        clone: function() {
            return new l(this.x, this.y)
        },
        set: function(t, i) {
            return "x" === t ? this.x = i : "y" === t && (this.y = i), this
        },
        add: function() {
            let t, i, o = arguments;
            if (1 === o.length) {
                let e = o[0];
                "object" == typeof e && (t = e.x, i = e.y)
            } else 2 === o.length && "number" == typeof o[0] && "number" == typeof o[1] && (t = o[0], i = o[1]);
            return this.x += t, this.y += i, this
        },
        subtract: function(t) {
            return this.x -= t.x, this.y -= t.y, this
        },
        multiply: function(t) {
            return "object" == typeof t ? (this.x *= t.x, this.y *= t.y) : "number" == typeof t && (this.x *= t, this.y *= t), this
        },
        magnitude: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        magnitudeSq: function() {
            return this.x * this.x + this.y * this.y
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        rotate: function(t) {
            let i = Math.sin(t),
                o = Math.cos(t),
                e = this.x * o - this.y * i,
                n = this.x * i + this.y * o;
            return this.x = e, this.y = n, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function(t) {
            return this.x * t.y - this.y * t.x
        },
        angleTo: function(t) {
            let i = this.magnitude(),
                o = t.magnitude(),
                e = this.dot(t);
            return Math.acos(e / (i * o))
        },
        getAngle: function(t) {
            if ("DEGREES" === t) return n(Math.atan(this.y / this.x));
            let i = Math.atan2(this.y, this.x);
            return i < 0 ? 2 * Math.PI + i : i
        },
        normalize: function() {
            let t = this.magnitude();
            return this.x /= t, this.y /= t, this
        },
        perp: function(t) {
            if ("right" === t) {
                let t = this.x;
                this.x = this.y, this.y = -t
            } else {
                let t = this.x;
                this.x = -this.y, this.y = t
            }
            return this
        },
        distanceTo: function(t) {
            return Math.sqrt((t.x - this.x) * (t.x - this.x) + (t.y - this.y) * (t.y - this.y))
        },
        scalarProject: function(t) {
            return this.dot(t) / t.magnitude()
        },
        scalarProjectUnit: function(t) {
            return this.dot(t)
        },
        vectorProject: function(t) {
            let i = this.dot(t) / t.magnitudeSq();
            return this.x = t.x * i, this.y = t.y * i, this
        },
        vectorProjectUnit: function(t) {
            let i = this.dot(t);
            return this.x = t.x * i, this.y = t.y * i, this
        }
    }, l.prototype.translate = l.prototype.add;
    l.add = function(t, i) {
        return new l(t.x + i.x, t.y + i.y)
    }, l.subtract = function(t, i) {
        return new l(t.x - i.x, t.y - i.y)
    }, l.multiply = function(t, i) {
        return "number" == typeof t && "number" == typeof i ? t * i : "object" == typeof t && "number" == typeof i ? new l(t.x * i, t.y * i) : "object" == typeof i && "number" == typeof t ? new l(t * i.x, t * i.y) : new l(t.x * i.x, t.y * i.y)
    }, l.dot = function(t, i) {
        return t.x * i.x + t.y * i.y
    }, l.angleBetween = function(t, i) {
        let o = t.magnitude(),
            e = i.magnitude(),
            n = t.dot(i);
        return Math.acos(n / (o * e))
    }, l.perp = function(t, i) {
        switch (i) {
            case "right":
                return new l(t.y, -t.x);
            default:
                return new l(-t.y, t.x)
        }
    }, l.negate = function(t) {
        return new l(-t.x, -t.y)
    }
}, function(t, i, o) {
    "use strict";
    o.d(i, "a", function() {
        return e
    });
    class e {
        constructor() {
            this.rescache = {}
        }
        load(t, i) {
            var o = this;
            t instanceof Array ? t.forEach(function(t) {
                o.rescache[t] = !1, o.fetch(t, i)
            }) : (o.rescache[t] = !1, o.fetch(t, i))
        }
        fetch(t, i) {
            var o = this;
            if (o.rescache[t]) return o.rescache[t];
            var e = new Image;
            e.onload = function() {
                o.rescache[t] = e, o.ready(i)
            }, e.src = t
        }
        ready(t) {
            if ("function" == typeof t) {
                var i = !0;
                for (var o in this.rescache) Object.prototype.hasOwnProperty.call(this.rescache, o) && !this.rescache[o] && (i = !1);
                i && t()
            }
        }
    }
}, function(t, i, o) {
    "use strict";
    o.d(i, "a", function() {
        return e
    });
    class e {
        constructor() {
            this.sounds = {}, this.instances = [], this.defaultVolume = 1
        }
        load(t, i, o) {
            if (this.sounds[t] = new Audio(i), "function" != typeof o) return new Promise((i, o) => {
                this.sounds[t].addEventListener("canplaythrough", i), this.sounds[t].addEventListener("error", o)
            });
            this.sounds[t].addEventListener("canplaythrough", o)
        }
        remove(t) {
            void 0 !== this.sounds && delete this.sounds[t]
        }
        unlock(t, i, o, e) {
            var n = this,
                s = ["touchstart", "touchend", "mousedown", "keydown"],
                r = function r() {
                    s.forEach(function(t) {
                        document.body.removeEventListener(t, r)
                    }), n.play(t, i, o, e)
                };
            s.forEach(function(t) {
                document.body.addEventListener(t, r, !1)
            })
        }
        play(t, i, o, e) {
            if (e = e || !1, void 0 === this.sounds[t]) return console.error("Can't find sound called '" + t + "'."), !1;
            var n = this.sounds[t].cloneNode(!0);
            return n.volume = "number" == typeof o ? o : this.defaultVolume, n.loop = e, n.play(), this.instances.push(n), n.addEventListener("ended", () => {
                var t = this.instances.indexOf(n); - 1 !== t && this.instances.splice(t, 1)
            }), "function" == typeof i ? (n.addEventListener("ended", i), !0) : new Promise((t, i) => n.addEventListener("ended", t))
        }
        stopAll() {
            var t = this.instances.slice();
            for (var i of t) i.pause(), i.dispatchEvent(new Event("ended"))
        }
    }
}, function(t, i, o) {
    "use strict";
    o.r(i);
    var e = o(1),
        n = o(2);
    new class extends e.Game {
        constructor(t, i, o) {
            super(), this.state.size = {
                x: i,
                y: o
            }, this.loop = new e.Loop(this, 60), this.viewport = new e.Canvas(this.state.size.x, this.state.size.y, t), this.context = this.viewport.context, this.viewport.style.background = "#eee", this.viewport.resize(this, {
                x: window.innerWidth,
                y: window.innerHeight
            });
            var s = new n.Common.Math.b2Vec2(0, this.state.gravity.y * n.SCALE);
            this.world = new n.Dynamics.b2World(s, !0)
        }
        update(t, i) {
            this.world.Step(), this.world.ClearForces()
        }
        render() {
            super.render(), this.viewport.clear(), this.context.fillStyle = "#fff", this.context.font = "2em Arial", this.context.fillText("Box2D.️", 65, this.state.size.y / 2, this.state.size.x)
        }
    }("#container", 1024, 512)
}, function(t, i, o) {
    "use strict";
    o.r(i),
        function(t, e) {
            o.d(i, "Craters", function() {
                return m
            });
            var n = o(5);
            o.d(i, "Maths", function() {
                return n
            });
            var s = o(4);
            o.d(i, "Canvas", function() {
                return s.a
            }), o.d(i, "Loop", function() {
                return s.b
            });
            var r = o(0);
            o.d(i, "Game", function() {
                return r.b
            }), o.d(i, "Entity", function() {
                return r.a
            }), o.d(i, "Sprite", function() {
                return r.c
            });
            var a = o(6);
            o.d(i, "Loader", function() {
                return a.a
            });
            var l = o(7);
            o.d(i, "Sound", function() {
                return l.a
            }), "undefined" == typeof window && t && (t.window = {
                performance: {
                    now: function(t) {
                        if (!t) return Date.now();
                        var i = Date.now(t);
                        return Math.round(1e3 * i[0] + i[1] / 1e6)
                    }
                },
                requestAnimationFrame: function(t) {
                    e(() => t(this.performance.now()))
                }
            });
            class m {
                static version() {
                    return "1.2.2"
                }
            }
        }.call(this, o(3), o(10).setImmediate)
}, function(t, i, o) {
    (function(t) {
        var e = void 0 !== t && t || "undefined" != typeof self && self || window,
            n = Function.prototype.apply;

        function s(t, i) {
            this._id = t, this._clearFn = i
        }
        i.setTimeout = function() {
            return new s(n.call(setTimeout, e, arguments), clearTimeout)
        }, i.setInterval = function() {
            return new s(n.call(setInterval, e, arguments), clearInterval)
        }, i.clearTimeout = i.clearInterval = function(t) {
            t && t.close()
        }, s.prototype.unref = s.prototype.ref = function() {}, s.prototype.close = function() {
            this._clearFn.call(e, this._id)
        }, i.enroll = function(t, i) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = i
        }, i.unenroll = function(t) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = -1
        }, i._unrefActive = i.active = function(t) {
            clearTimeout(t._idleTimeoutId);
            var i = t._idleTimeout;
            i >= 0 && (t._idleTimeoutId = setTimeout(function() {
                t._onTimeout && t._onTimeout()
            }, i))
        }, o(11), i.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, i.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate
    }).call(this, o(3))
}, function(t, i, o) {
    (function(t, i) {
        ! function(t, o) {
            "use strict";
            if (!t.setImmediate) {
                var e, n, s, r, a, l = 1,
                    m = {},
                    c = !1,
                    h = t.document,
                    _ = Object.getPrototypeOf && Object.getPrototypeOf(t);
                _ = _ && _.setTimeout ? _ : t, "[object process]" === {}.toString.call(t.process) ? e = function(t) {
                    i.nextTick(function() {
                        y(t)
                    })
                } : ! function() {
                    if (t.postMessage && !t.importScripts) {
                        var i = !0,
                            o = t.onmessage;
                        return t.onmessage = function() {
                            i = !1
                        }, t.postMessage("", "*"), t.onmessage = o, i
                    }
                }() ? t.MessageChannel ? ((s = new MessageChannel).port1.onmessage = function(t) {
                    y(t.data)
                }, e = function(t) {
                    s.port2.postMessage(t)
                }) : h && "onreadystatechange" in h.createElement("script") ? (n = h.documentElement, e = function(t) {
                    var i = h.createElement("script");
                    i.onreadystatechange = function() {
                        y(t), i.onreadystatechange = null, n.removeChild(i), i = null
                    }, n.appendChild(i)
                }) : e = function(t) {
                    setTimeout(y, 0, t)
                } : (r = "setImmediate$" + Math.random() + "$", a = function(i) {
                    i.source === t && "string" == typeof i.data && 0 === i.data.indexOf(r) && y(+i.data.slice(r.length))
                }, t.addEventListener ? t.addEventListener("message", a, !1) : t.attachEvent("onmessage", a), e = function(i) {
                    t.postMessage(r + i, "*")
                }), _.setImmediate = function(t) {
                    "function" != typeof t && (t = new Function("" + t));
                    for (var i = new Array(arguments.length - 1), o = 0; o < i.length; o++) i[o] = arguments[o + 1];
                    var n = {
                        callback: t,
                        args: i
                    };
                    return m[l] = n, e(l), l++
                }, _.clearImmediate = p
            }

            function p(t) {
                delete m[t]
            }

            function y(t) {
                if (c) setTimeout(y, 0, t);
                else {
                    var i = m[t];
                    if (i) {
                        c = !0;
                        try {
                            ! function(t) {
                                var i = t.callback,
                                    e = t.args;
                                switch (e.length) {
                                    case 0:
                                        i();
                                        break;
                                    case 1:
                                        i(e[0]);
                                        break;
                                    case 2:
                                        i(e[0], e[1]);
                                        break;
                                    case 3:
                                        i(e[0], e[1], e[2]);
                                        break;
                                    default:
                                        i.apply(o, e)
                                }
                            }(i)
                        } finally {
                            p(t), c = !1
                        }
                    }
                }
            }
        }("undefined" == typeof self ? void 0 === t ? this : t : self)
    }).call(this, o(3), o(12))
}, function(t, i) {
    var o, e, n = t.exports = {};

    function s() {
        throw new Error("setTimeout has not been defined")
    }

    function r() {
        throw new Error("clearTimeout has not been defined")
    }

    function a(t) {
        if (o === setTimeout) return setTimeout(t, 0);
        if ((o === s || !o) && setTimeout) return o = setTimeout, setTimeout(t, 0);
        try {
            return o(t, 0)
        } catch (i) {
            try {
                return o.call(null, t, 0)
            } catch (i) {
                return o.call(this, t, 0)
            }
        }
    }! function() {
        try {
            o = "function" == typeof setTimeout ? setTimeout : s
        } catch (t) {
            o = s
        }
        try {
            e = "function" == typeof clearTimeout ? clearTimeout : r
        } catch (t) {
            e = r
        }
    }();
    var l, m = [],
        c = !1,
        h = -1;

    function _() {
        c && l && (c = !1, l.length ? m = l.concat(m) : h = -1, m.length && p())
    }

    function p() {
        if (!c) {
            var t = a(_);
            c = !0;
            for (var i = m.length; i;) {
                for (l = m, m = []; ++h < i;) l && l[h].run();
                h = -1, i = m.length
            }
            l = null, c = !1,
                function(t) {
                    if (e === clearTimeout) return clearTimeout(t);
                    if ((e === r || !e) && clearTimeout) return e = clearTimeout, clearTimeout(t);
                    try {
                        e(t)
                    } catch (i) {
                        try {
                            return e.call(null, t)
                        } catch (i) {
                            return e.call(this, t)
                        }
                    }
                }(t)
        }
    }

    function y(t, i) {
        this.fun = t, this.array = i
    }

    function u() {}
    n.nextTick = function(t) {
        var i = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var o = 1; o < arguments.length; o++) i[o - 1] = arguments[o];
        m.push(new y(t, i)), 1 !== m.length || c || a(p)
    }, y.prototype.run = function() {
        this.fun.apply(null, this.array)
    }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = u, n.addListener = u, n.once = u, n.off = u, n.removeListener = u, n.removeAllListeners = u, n.emit = u, n.prependListener = u, n.prependOnceListener = u, n.listeners = function(t) {
        return []
    }, n.binding = function(t) {
        throw new Error("process.binding is not supported")
    }, n.cwd = function() {
        return "/"
    }, n.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }, n.umask = function() {
        return 0
    }
}]);