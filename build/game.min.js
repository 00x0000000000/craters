/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/game.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/craters/craters.js":
/*!********************************!*\
  !*** ./app/craters/craters.js ***!
  \********************************/
/*! exports provided: Craters, Loader, Game, Canvas, Loop, Entity, Sprite, Collision, Sound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Craters\", function() { return Craters; });\n/* harmony import */ var _system_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./system.js */ \"./app/craters/system.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Canvas\", function() { return _system_js__WEBPACK_IMPORTED_MODULE_0__[\"Canvas\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Loop\", function() { return _system_js__WEBPACK_IMPORTED_MODULE_0__[\"Loop\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Collision\", function() { return _system_js__WEBPACK_IMPORTED_MODULE_0__[\"Collision\"]; });\n\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity.js */ \"./app/craters/entity.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return _entity_js__WEBPACK_IMPORTED_MODULE_1__[\"Game\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _entity_js__WEBPACK_IMPORTED_MODULE_1__[\"Entity\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Sprite\", function() { return _entity_js__WEBPACK_IMPORTED_MODULE_1__[\"Sprite\"]; });\n\n/* harmony import */ var _loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader.js */ \"./app/craters/loader.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return _loader_js__WEBPACK_IMPORTED_MODULE_2__[\"Loader\"]; });\n\n/* harmony import */ var _sound_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sound.js */ \"./app/craters/sound.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Sound\", function() { return _sound_js__WEBPACK_IMPORTED_MODULE_3__[\"Sound\"]; });\n\n// Craters.js micro game framework\n// This module contains the basics fundamental starting point calling game loop, which handles\n// updating the game state and re-rendering the canvas\n// (using the updated state) at the configured FPS.\n\n\n\n\n\n\nconst boundary = function numberboundary (min, max) {\n  return Math.min(Math.max(this, min), max)\n}\n// Expose methods\nNumber.prototype.boundary = boundary\n\nclass Craters {\n  static version () {\n    return '0.0.0.5'\n  }\n}\n\n\n\n//# sourceURL=webpack:///./app/craters/craters.js?");

/***/ }),

/***/ "./app/craters/entity.js":
/*!*******************************!*\
  !*** ./app/craters/entity.js ***!
  \*******************************/
/*! exports provided: Entity, Game, Sprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return Entity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return Game; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sprite\", function() { return Sprite; });\nclass Game {\n  constructor (container, width, height, fps, debug) {\n    this.entities = []\n    this.state = {\n      container: container,\n      size: {\n\t      x: 10,\n\t      y: 10\n      },\n      \n      bgcolor: 'rgba(0,0,0,0)',\n      color: '#ff0',\n      font: '1em Arial'\n    }\n  }\n\n  update () {\n    for (var entity = 0; entity < this.entities.length; entity++) {\n      // Fire off each active entities `render` method\n      this.entities[entity].update()\n    }\n  }\n  \n  render () {\n\tfor (var entity = 0; entity < this.entities.length; entity++) {\n    // Fire off each active entities `render` method\n    this.entities[entity].render() }\n  }\n  \n  clearContext (context, size) {\n\t  context.clearRect(0, 0, size.x, size.y)\n  }\n}\n\nclass Entity extends Game {\n  constructor () {\n    super();\n    this.state = {\n      size: {\n        x: 10,\n        y: 10\n      },\n      pos: {\n        x: 0,\n        y: 0\n      },\n      vel: {\n        x: 0,\n        y: 0\n      },\n      accel: {\n        x: 0,\n        y: 0\n      },\n      radius: 10,\n      angle: 0\n    }\n  }\n\n  update () {\n    super.update ();\n    \n    this.state.vel.x += this.state.accel.x\n    this.state.vel.y += this.state.accel.y\n    this.state.pos.x += this.state.vel.x\n    this.state.pos.y += this.state.vel.y\n  }\n}\n\nclass Sprite extends Entity {\n  constructor (scope, args) {\n    super()\n\n    this.scope = scope\n    this.state.pos = args.pos || {\n        x: 0,\n        y: 0\n      }\n      this.state.crop = {\n        x: 0,\n        y: 0\n      }\n      this.state.size = args.size || {\n        x: 0,\n        y: 0\n      }\n      \n      this.state.frames = args.frames || []\n      this.state.angle = args.angle || 0\n      this.state.image = args.image || new Image()\n      this.state.delay = args.delay || 5\n      this.state.tick = args.tick || 0\n      this.state.orientation = args.orientation || 'horizontal'\n    }\n\n  update () {\n  super.update ();\n  \n    if (this.state.tick <= 0) {\n      if (this.orientation === 'vertical') {\n        this.state.crop.y = this.state.frames.shift()\n        this.state.frames.push(this.state.crop.y)\n      } else {\n        this.state.crop.x = this.state.frames.shift()\n        this.state.frames.push(this.state.crop.x)\n      }\n\n      this.state.tick = this.state.delay\n    }\n\n    this.state.tick--\n  }\n\n  render () {\n    super.render()\n\n    this.scope.context.save()\n    this.scope.context.translate(this.state.crop.x + (this.state.size.x / 2), this.state.crop.y + (this.state.size.y / 2))\n    this.scope.context.rotate((this.state.angle) * (Math.PI / 180))\n    this.scope.context.translate(-(this.state.crop.x + (this.state.size.x / 2)), -(this.state.crop.y + (this.state.size.y / 2)))\n\n    this.scope.context.drawImage(this.state.image,\n      (this.state.crop.x * this.state.size.x), (this.state.crop.y * this.state.size.y), this.state.size.x, this.state.size.y,\n      this.state.pos.x, this.state.pos.y, this.state.size.x, this.state.size.y)\n\n    this.scope.context.restore()\n  }\n}\n\n\n\n//# sourceURL=webpack:///./app/craters/entity.js?");

/***/ }),

/***/ "./app/craters/loader.js":
/*!*******************************!*\
  !*** ./app/craters/loader.js ***!
  \*******************************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return Loader; });\nclass Loader {\n  constructor () {\n    this.rescache = {}\n  };\n\n  load (res, cbk) {\n    var that = this\n    if (res instanceof Array) {\n      res.forEach(function (i) {\n        that.rescache[i] = false\n        that.fetch(i, cbk)\n      })\n    } else {\n      that.rescache[res] = false\n      that.fetch(res, cbk)\n    }\n  }\n\n  fetch (url, cbk) {\n    var that = this\n    if (that.rescache[url]) {\n      return that.rescache[url]\n    } else {\n      var img = new Image()\n      img.onload = function () {\n        that.rescache[url] = img\n        that.ready(cbk)\n      }\n\n      img.src = url\n    }\n  }\n\n  ready (cbk) {\n    var that = this\n    if (typeof cbk === 'function') {\n      var ready = true\n      for (var item in that.rescache) {\n        if (Object.prototype.hasOwnProperty.call(that.rescache, item) && !that.rescache[item]) {\n          ready = false\n        }\n      }\n\n      if (ready) cbk()\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./app/craters/loader.js?");

/***/ }),

/***/ "./app/craters/sound.js":
/*!******************************!*\
  !*** ./app/craters/sound.js ***!
  \******************************/
/*! exports provided: Sound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sound\", function() { return Sound; });\n// modified soundbox.js lib\nclass Sound {\n  constructor () {\n    this.sounds = {} // The loaded sounds and their instances\n    this.instances = [] // Sounds that are currently playing\n    this.defaultVolume = 1\n  };\n\n  load (name, path, callback) {\n    this.sounds[name] = new Audio(path)\n    if (typeof callback === 'function') {\n      this.sounds[name].addEventListener('canplaythrough', callback)\n    } else {\n      return new Promise((resolve, reject) => {\n        this.sounds[name].addEventListener('canplaythrough', resolve)\n        this.sounds[name].addEventListener('error', reject)\n      })\n    }\n  };\n\n  remove (name) {\n    if (typeof this.sounds !== 'undefined') {\n      delete this.sounds[name]\n    }\n  };\n\n  unlock (name, callback, volume, loop) {\n    var that = this\n    var events = ['touchstart', 'touchend', 'mousedown', 'keydown']\n    var unlock = function unlock () {\n      events.forEach(function (event) {\n        document.body.removeEventListener(event, unlock)\n      })\n      that.play(name, callback, volume, loop)\n    }\n\n    events.forEach(function (event) {\n      document.body.addEventListener(event, unlock, false)\n    })\n  };\n\n  play (name, callback, volume, loop) {\n    loop = loop || false\n\n    if (typeof this.sounds[name] === 'undefined') {\n      console.error(\"Can't find sound called '\" + name + \"'.\")\n      return false\n    };\n\n    var soundInstance = this.sounds[name].cloneNode(true)\n    soundInstance.volume = typeof volume === 'number' ? volume : this.defaultVolume\n    soundInstance.loop = loop\n    soundInstance.play()\n    this.instances.push(soundInstance)\n\n    // Don't forget to remove the instance from the instances array\n    soundInstance.addEventListener('ended', () => {\n      var index = this.instances.indexOf(soundInstance)\n      if (index !== -1) this.instances.splice(index, 1)\n    })\n\n    // Attach the callback / promise\n    if (typeof callback === 'function') {\n      soundInstance.addEventListener('ended', callback)\n      return true\n    };\n\n    return new Promise((resolve, reject) => soundInstance.addEventListener('ended', resolve))\n  };\n\n  stopAll () {\n    // Pause all currently playing sounds\n\n    // Shallow clone the array to avoid issues with instances auto-removing themselves\n    var instancesToStop = this.instances.slice()\n    for (var instance of instancesToStop) {\n      instance.pause()\n      instance.dispatchEvent(new Event('ended'))\n    }\n  }\n};\n\n\n\n\n//# sourceURL=webpack:///./app/craters/sound.js?");

/***/ }),

/***/ "./app/craters/system.js":
/*!*******************************!*\
  !*** ./app/craters/system.js ***!
  \*******************************/
/*! exports provided: Canvas, Loop, Collision */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Canvas\", function() { return Canvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loop\", function() { return Loop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Collision\", function() { return Collision; });\n// Rect collision tests the edges of each rect to\n// test whether the objects are overlapping the other\nclass Collision {\n\tstatic detector (collider, collidee) {\n\t    // Store the collider and collidee edges\n\t    var l1 = collider.state.pos.x;\n\t    var t1 = collider.state.pos.y;\n\t    var r1 = l1 + collider.state.size.x;\n\t    var b1 = t1 + collider.state.size.y;\n\t    \n\t    var l2 = collidee.state.pos.x;\n\t    var t2 = collidee.state.pos.y;\n\t    var r2 = l2 + collidee.state.size.x;\n\t    var b2 = t2 + collidee.state.size.y;\n\t    \n\t    // If the any of the edges are beyond any of the\n\t    // others, then we know that the box cannot be\n\t    // colliding\n\t    if (b1 < t2 || t1 > b2 || r1 < l2 || l1 > r2) {\n\t        return false;\n\t    }\n\t    \n\t    // If the algorithm made it here, it had to collide\n\t    return true;\n    }\n}\n\n// Game Loop Module\n// This module contains the game loop, which handles\n// updating the game state and re-rendering the canvas\n// (using the updated state) at the configured FPS.\nclass Loop {\n  constructor (scope, fps) {\n    var loop = {}\n    // Initialize timer variables so we can calculate FPS\n    var fpsInterval = 1000 / fps\n    var before = window.performance.now()\n    // Set up an object to contain our alternating FPS calculations\n    var cycles = {\n      new: {\n        frameCount: 0,\n        startTime: before,\n        sinceStart: 0\n      },\n      old: {\n        frameCount: 0,\n        startTime: before,\n        sineStart: 0\n      }\n    }\n\n    // Alternating Frame Rate vars\n    var resetInterval = 5\n    var resetState = 'new'\n\n    loop.fps = 0\n\n    // Main game rendering loop\n    loop.main = function mainLoop (tframe) {\n      // Request a new Animation Frame\n      // setting to `stopLoop` so animation can be stopped via\n      // `window.cancelAnimationFrame( loop.stopLoop )`\n      loop.stopLoop = window.requestAnimationFrame(loop.main)\n\n      // How long ago since last loop?\n      var now = tframe\n      var elapsed = now - before\n      var activeCycle\n      var targetResetInterval\n\n      // If it's been at least our desired interval, render\n      if (elapsed > fpsInterval) {\n        // Set before = now for next frame, also adjust for\n        // specified fpsInterval not being a multiple of rAF's interval (16.7ms)\n        // ( http://stackoverflow.com/a/19772220 )\n        before = now - (elapsed % fpsInterval)\n\n        // Increment the vals for both the active and the alternate FPS calculations\n        for (var calc in cycles) {\n          ++cycles[calc].frameCount\n          cycles[calc].sinceStart = now - cycles[calc].startTime\n        }\n\n        // Choose the correct FPS calculation, then update the exposed fps value\n        activeCycle = cycles[resetState]\n        loop.fps = Math.round(1000 / (activeCycle.sinceStart / activeCycle.frameCount) * 100) / 100\n\n        // If our frame counts are equal....\n        targetResetInterval = (cycles.new.frameCount === cycles.old.frameCount\n          ? resetInterval * fps // Wait our interval\n          : (resetInterval * 2) * fps) // Wait double our interval\n\n        // If the active calculation goes over our specified interval,\n        // reset it to 0 and flag our alternate calculation to be active\n        // for the next series of animations.\n        if (activeCycle.frameCount > targetResetInterval) {\n          cycles[resetState].frameCount = 0\n          cycles[resetState].startTime = now\n          cycles[resetState].sinceStart = 0\n\n          resetState = (resetState === 'new' ? 'old' : 'new')\n        }\n\n        // Update the game state\n        scope.update(scope, now)\n        // Render the next frame\n        scope.render(scope, now)\n      }\n    }\n\n    // Start off main loop\n    loop.main()\n    return loop\n  }\n}\n\nclass Canvas {\n\tconstructor (width, height, container) {\n\t\tvar container = document.querySelector(container || 'body');\n\t\t// Generate a canvas and store it as our viewport\n\t    var canvas = document.createElement('canvas')\n\t    var context = canvas.getContext('2d')\n\t    // Pass our canvas' context to our getPixelRatio method\n\t    var backingStores = ['webkitBackingStorePixelRatio', 'mozBackingStorePixelRatio', 'msBackingStorePixelRatio', 'oBackingStorePixelRatio', 'backingStorePixelRatio']\n\t    var deviceRatio = window.devicePixelRatio\n\t    // Iterate through our backing store props and determine the proper backing ratio.\n\t    var backingRatio = backingStores.reduce(function (prev, curr) {\n\t      return (Object.prototype.hasOwnProperty.call(context, curr) ? context[curr] : 1)\n\t    })\n\t    // Return the proper pixel ratio by dividing the device ratio by the backing ratio\n\t    var ratio = deviceRatio / backingRatio\n\t\n\t    // Set the canvas' width then downscale via CSS\n\t    canvas.width = Math.round(width * ratio)\n\t    canvas.height = Math.round(height * ratio)\n\t    canvas.style.width = width + 'px'\n\t    canvas.style.height = height + 'px'\n\t    // Scale the context so we get accurate pixel density\n\t    context.setTransform(ratio, 0, 0, ratio, 0, 0)\n\t    // Append viewport into our game within the dom\n\t    container.insertBefore(canvas, container.firstChild)\n\t    \n\t    return canvas // return the canvas\n\t}\n}\n\n\n\n//# sourceURL=webpack:///./app/craters/system.js?");

/***/ }),

/***/ "./app/game.js":
/*!*********************!*\
  !*** ./app/game.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _craters_craters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./craters/craters.js */ \"./app/craters/craters.js\");\n\n\n\nclass mygame extends _craters_craters_js__WEBPACK_IMPORTED_MODULE_0__[\"Game\"] {\n\tconstructor (container, width, height){\n\t\tsuper ();\n\t\t\n\t\tthis.state.size = {x: width, y: height}\n\t\tthis.viewport = new _craters_craters_js__WEBPACK_IMPORTED_MODULE_0__[\"Canvas\"](this.state.size.x, this.state.size.y, container);\n\t\tthis.context = this.viewport.getContext('2d')\n\t\tthis.loop = new _craters_craters_js__WEBPACK_IMPORTED_MODULE_0__[\"Loop\"](this, 60)\n\t}\n\t\n    render () {\n        super.render()\n        this.clearContext(this.context, this.state.size)\n        \n        this.context.font = '2em Arial'\n        this.context.fillText('It\\'s working.️', 65, (this.state.size.y / 2), (this.state.size.x))\n    }\n}\n\nwindow.game = new mygame('#container', window.innerWidth, window.innerHeight, 60, true)\n\n//# sourceURL=webpack:///./app/game.js?");

/***/ })

/******/ });